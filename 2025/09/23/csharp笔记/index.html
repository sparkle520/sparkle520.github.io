<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>c# 笔记 | SPARKLE</title><meta name="keywords" content="c#"><meta name="author" content="sparkle520"><meta name="copyright" content="sparkle520"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="c# 笔记"><meta name="application-name" content="c# 笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="c# 笔记"><meta property="og:url" content="http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="SPARKLE"><meta property="og:description" content="在 C# 中，协变 ( Covariance ) 和逆变 ( Contravariance ) 是用于描述泛型接口和委托中类型参数转换关系的概念，它们允许在泛型类型之间进行更灵活的转换. 协变 ( Covariance ) 协变允许将派生类型的泛型对象赋值给基类型的泛型对象，使用 out 关"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pic1.imgdb.cn/item/68d363acc5157e1a882c5be1.jpg"><meta property="article:author" content="sparkle520"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic1.imgdb.cn/item/68d363acc5157e1a882c5be1.jpg"><meta name="description" content="在 C# 中，协变 ( Covariance ) 和逆变 ( Contravariance ) 是用于描述泛型接口和委托中类型参数转换关系的概念，它们允许在泛型类型之间进行更灵活的转换. 协变 ( Covariance ) 协变允许将派生类型的泛型对象赋值给基类型的泛型对象，使用 out 关"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://sparkle521.xyz',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["(❤ ω ❤)"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: sparkle520","link":"链接: ","source":"来源: SPARKLE","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#883ced","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'SPARKLE',
  title: 'c# 笔记',
  postAI: '',
  pageFillDescription: '协变 ( Covariance ), 逆变 ( Contravariance ), 委托中的协变和逆变, 关键规则, C 反射机制详解 ( 含泛型操作 ), 反射的核心概念, 反射的核心价值, 反射的基础操作 ( 非泛型 ), 获取 Type 对象, 查看类型成员信息, 核心成员获取方法, BindingFlags 枚举 ( 关键 ), 动态操作类型成员, 动态创建对象, 动态访问/修改字段/属性, 动态调用方法, 泛型的反射操作 ( 重点 ), 泛型的核心概念, 泛型类型的反射, 获取泛型类型, 动态创建泛型对象, 调用泛型类的非泛型方法, 泛型方法的反射, 静态泛型方法的反射, 反射的优缺点与注意事项, 优点, 缺点, 注意事项, 常见应用场景, C 特性 ( Attribute ) 详解, 特性的基本概念, 什么是特性, 特性的命名规范, 特性的应用目标, AttributeUsage 特性, 常用内置特性, Obsolete 特性, Conditional 特性, Serializable 特性, Deprecated 特性 ( .NET 5+ ), 程序集特性, 数据验证特性, 自定义特性, 创建自定义特性类, 应用自定义特性, 通过反射读取特性, 特性的高级应用, 带参数的特性, 泛型特性 ( C 11+ ), 特性与 AOP ( 面向切面编程 ), 特性在框架中的应用, ASP.NET Core 中的特性, 序列化中的特性, 特性的优缺点, 优点, 缺点, 最佳实践, C 委托 ( Delegate ), 委托的基本定义, 本质与作用, 语法规则, 声明委托, 关联方法 ( 实例化委托 ), 调用委托, 委托的核心特性, 添加/移除方法, 委托与方法的签名匹配, 系统内置委托 ( 无需自定义 ), Action 委托, Func 委托, Predicate 委托, 委托的典型应用场景, 方法作为参数传递 ( 解耦 ), 事件驱动编程 ( 基础 ), 异步回调 ( 简化版 ), 委托与 Lambda 表达式的关系, 常见问题与注意事项, 总结, C 事件 ( Event ), 事件的基本概念, 本质与作用, 与委托的关系, 事件的声明与使用, 声明事件的标准步骤, 在发布者类中声明事件, 订阅者订阅事件并处理, 使用事件机制, 事件的核心语法规则, .NET 事件约定与最佳实践, 命名规范, 推荐使用内置委托, 线程安全考量, 避免过度使用静态事件, 事件与委托的关键区别, 典型应用场景, GUI 控件事件, 状态变化通知, 异步操作完成通知, 常见问题与注意事项, 总结, C Lambda 表达式, 核心概念与语法结构, 无参数 Lambda, 单参数 Lambda, 多参数 Lambda, 类型推断机制, 与委托的关系, 与匿名方法的对比, 表达式树, 闭包特性, 在 LINQ 中的应用, 在事件处理中的应用, 异步 Lambda, 最佳实践与注意事项, 总结, C LINQ, 什么是 LINQ, LINQ 的两种语法形式, 查询语法 ( Query Syntax ), 方法语法 ( Method Syntax ), LINQ 核心命名空间, LINQ 的类型, LINQ to Objects, LINQ to Entities, LINQ to SQL, LINQ to XML, 常用 LINQ 操作符, 筛选操作符, 投影操作符, 排序操作符, 分组操作符, 连接操作符, 聚合操作符, 元素操作符, 集合操作符, 延迟执行与立即执行, IQueryable 与 IEnumerable, IEnumerable, IQueryable, LINQ 中的匿名类型, LINQ 性能考量, 总结在中协变和逆变是用于描述泛型接口和委托中类型参数转换关系的概念它们允许在泛型类型之间进行更灵活的转换协变协变允许将派生类型的泛型对象赋值给基类型的泛型对象使用关键字标记类型参数适用场景当泛型接口委托的类型参数仅作为返回值使用时示例协变接口使用关键字使用示例协变转换合法逆变逆变允许将基类型的泛型对象赋值给派生类型的泛型对象使用关键字标记类型参数适用场景当泛型接口委托的类型参数仅作为输入参数使用时示例逆变接口使用关键字使用示例逆变转换合法委托中的协变和逆变中的委托也支持协变和逆变协变委托返回值协变逆变委托参数逆变关键规则协变使用关键字类型参数只能作为返回值逆变使用关键字类型参数只能作为输入参数只有接口和委托支持协变和逆变类和结构不支持数组也支持协变但可能导致运行时错误应谨慎使用理解协变和逆变有助于编写更灵活更通用的代码特别是在处理集合事件和委托时非常有用反射机制详解含泛型操作反射的核心概念反射是中一种运行时元数据访问机制允许程序在不依赖编译时类型信息的前提下动态检查访问和操作类型类接口结构体等的成员字段属性方法构造函数等其本质是通过命名空间提供的解析程序集中存储的类型元数据实现动态探测和动态操作反射的核心价值打破封装限制可访问类的私有成员需显式指定访问权限提升代码灵活性动态创建对象调用方法适配多变的业务场景如插件系统配置驱动开发支撑框架级功能是序列化反序列化如解析依赖注入框架如单元测试框架的底层核心技术反射的基础操作非泛型基础反射围绕获取类型信息操作类型成员展开核心入口是类每个类型在内存中对应唯一的对象获取对象获取对象是反射的第一步常见方式有种方式语法适用场景运算符目标类型已知编译时类型直接获取方法对象实例已知对象实例动态获取其类型程序集对象完整类型名已知类型的完整名称含命名空间从指定程序集获取示例定义示例类获取对象方式方式查看类型成员信息通过对象的方法可获取类型的字段属性方法构造函数等成员信息返回对应的对象核心成员获取方法方法功能常用重载获取字段指定访问权限如公共私有静态实例获取属性同上获取方法同上需过滤继承的方法获取构造函数同上枚举关键用于筛选成员的访问范围常用组合公共实例成员私有实例成员公共静态成员示例获取类的公共字段和属性公共字段类型公共属性类型获取私有方法指定参数类型避免方法重载歧义动态操作类型成员获取成员信息如后可通过其提供的方法动态操作动态创建对象通过或实现方式无参构造函数方式带参构造函数参数顺序需与构造函数一致方式通过调用更灵活支持重载动态访问修改字段属性字段对象实例对象实例新值属性对象实例对象实例新值示例操作字段修改的输出操作属性修改会触发属性的逻辑输出动态调用方法通过对象实例参数数组实现静态方法的第一个参数为调用公共方法输出调用私有方法输出泛型的反射操作重点泛型的反射比非泛型更复杂核心是区分未构造泛型类型和构造泛型类型并通过特定处理类型参数泛型的核心概念概念定义示例未构造泛型类型未指定类型参数的泛型类型是模板构造泛型类型已指定具体类型参数的泛型类型是可实例化的类型泛型方法定义未指定类型参数的泛型方法构造泛型方法已指定类型参数的泛型方法泛型类型的反射获取泛型类型未构造泛型类型通过泛型类型名获取注意尖括号内的占位符数量与泛型参数数量一致构造泛型类型通过未构造类型类型参数数组生成示例以自定义泛型类为例定义泛型类获取未构造泛型类型尖括号内个占位符对应个泛型参数输出输出是否为未构造类型获取泛型类型参数泛型参数输出生成构造泛型类型输出动态创建泛型对象与非泛型类似通过构造泛型类型构造函数参数实现创建的实例构造函数参数访问泛型字段和属性输出输出调用泛型类的非泛型方法与非泛型类的方法调用一致通过实现输出泛型方法的反射泛型方法分为泛型方法定义和构造泛型方法需先获取方法定义再指定类型参数生成构造方法最后调用示例以泛型方法为例在中添加泛型方法泛型方法将类型转换为类型并返回获取泛型方法定义先获取构造泛型类型输出输出生成构造泛型方法指定泛型方法的类型参数调用构造泛型方法参数解析结果输出静态泛型方法的反射静态泛型方法的反射与实例泛型方法类似仅需注意调用时的第一个参数为在中添加静态泛型方法类型获取静态泛型方法定义未构造泛型类型生成构造静态泛型方法输出类型生成另一个构造静态泛型方法输出类型反射的优缺点与注意事项优点灵活性高动态适配未知类型支撑插件化配置驱动等场景通用性强可编写通用框架如序列化工具无需针对具体类型编码打破封装可访问私有成员方便单元测试或特殊场景需谨慎使用缺点性能损耗反射需解析元数据比直接调用慢倍高频场景需缓存等对象编译时无检查成员名称参数类型错误仅在运行时抛出异常增加调试难度破坏封装性访问私有成员可能违反面向对象设计原则导致代码耦合度升高注意事项缓存反射对象等对象是线程安全的可缓存复用减少性能损耗指定获取非公共成员或静态成员时必须显式指定否则会返回处理泛型歧义泛型方法重载时需通过的参数类型数组区分避免获取错误的方法权限控制部分环境如沙箱可能限制反射访问私有成员需提前确认权限常见应用场景序列化反序列化如通过反射遍历对象成员将对象转换为字符串或反之依赖注入如通过反射创建服务实例注入到依赖对象中框架如通过反射映射实体类属性与数据库表字段生成语句插件系统如插件通过反射加载外部程序集调用插件中的方法单元测试如通过反射调用测试方法访问私有成员验证内部逻辑特性详解特性是中一种强大的元数据机制允许开发者在代码中嵌入额外信息这些信息可以在编译时被编译器使用或在运行时通过反射读取特性为程序提供了一种声明式编程方式广泛应用于框架开发代码分析和运行时行为控制特性的基本概念什么是特性特性是一种特殊的类继承自用于为代码元素类方法属性等添加元数据它们不会直接影响代码的执行逻辑而是通过工具或运行时反射来使用这些元数据特性的基本形式特性的实现应用特性可省略后缀特性的命名规范特性类通常以结尾如应用时可以省略后缀如等价于特性类必须直接或间接继承自特性的应用目标特性可以应用于几乎所有代码元素包括程序集模块类结构体枚举构造函数方法属性字段事件接口参数返回值特性是一个特殊的特性用于控制自定义特性的使用规则它有三个重要参数指定特性可以应用到的代码元素允许应用于类和方法指定是否允许在同一元素上多次应用该特性允许多次应用默认不允许指定特性是否可以被派生类继承默认可以继承不能继承常用内置特性提供了许多内置特性以下是最常用的几种特性标记代码元素为过时编译器会产生警告或错误此方法已过时请使用替代此方法已禁用不应该再使用第二个参数为会产生错误特性根据条件编译符号决定是否保留方法调用定义条件编译符号只有在定义了符号时下面的调用才会生效程序启动特性标记类可以被序列化标记不序列化的字段特性比更现代的替代提供更丰富的废弃信息请使用程序集特性应用于整个程序集通常在中定义这是一个示例应用程序数据验证特性在等框架中用于模型验证不能为空姓名不能超过个字符请输入有效的邮箱地址年龄必须在到之间自定义特性创建自定义特性可以为代码添加特定领域的元数据步骤如下创建自定义特性类定义特性可以应用的目标是否允许多次应用是否可继承位置参数必须在构造函数中指定命名参数可选构造函数定义位置参数应用自定义特性应用到类张三用户服务类应用到方法李四张三优化了查询逻辑实现代码通过反射读取特性获取类上的特性类上的特性作者版本描述创建日期获取方法上的特性方法上的特性作者版本特性的高级应用带参数的特性特性可以包含复杂的参数但只能使用常量值表达式或数组应用泛型特性及以上版本支持泛型特性应用特性与面向切面编程特性常与结合实现日志缓存事务等横切关注点定义日志特性使用特性标记需要日志的方法订单创建逻辑通过框架如拦截并实现日志功能特性在框架中的应用中的特性大量使用特性进行配置实现代码实现代码序列化中的特性等序列化库使用特性控制序列化行为序列化时的字段名序列化时忽略该属性指定枚举的序列化方式特性的优缺点优点声明式编程使代码更简洁意图更明确元数据分离将元数据与业务逻辑分离灵活性高可以在不修改代码逻辑的情况下扩展功能框架友好是许多框架如的基础缺点性能开销通过反射读取特性会有性能损耗编译时验证有限大部分特性逻辑在运行时才会验证调试困难特性相关逻辑不易调试过度使用会导致代码混乱最佳实践明确适用范围使用严格限制特性的应用目标命名规范遵循命名约定提供清晰文档说明特性的用途和参数含义避免复杂逻辑特性应仅存储元数据不应包含复杂业务逻辑考虑性能高频操作中避免频繁反射读取特性缓存反射结果对于需要频繁访问的特性信息缓存反射结果特性是中实现元编程的核心机制掌握特性的使用可以极大提高代码的灵活性和可维护性尤其是在开发框架或通用库时合理使用特性可以使代码更简洁更具表达力委托委托是中的核心概念本质是引用方法的类型安全指针用于实现方法作为参数传递事件驱动等场景是后续学习事件表达式的基础委托的基本定义本质与作用本质委托是一种自定义类型专门用来包装与它签名返回值参数列表匹配的方法核心作用实现方法作为参数传递解耦调用者与被调用者实现多播一个委托关联多个方法调用时依次执行作为事件的底层支撑事件本质是受限制的委托语法规则声明委托委托的声明需指定返回值类型和参数列表即方法签名语法格式语法返回值类型委托名参数列表声明一个接收两个返回的委托关键字委托名遵循命名法首字母大写签名要求后续关联的方法必须与委托的返回值参数数量参数类型完全匹配关联方法实例化委托委托实例化时需传入与签名匹配的方法支持静态方法和实例方法静态方法无需实例化类实例方法需先创建类实例实例化委托并关联方法关联静态方法关联实例方法调用委托委托调用方式与普通方法一致直接传入参数即可调用委托本质是调用关联的方法等价于结果等价于结果若委托未关联任何方法直接调用会抛出建议调用前判断简化写法空条件运算符若为返回委托的核心特性多播委托一个委托可以关联多个方法需与委托签名匹配调用时会按关联顺序依次执行所有方法添加移除方法添加方法移除方法需确保方法已关联否则无效果定义多个匹配签名的方法结果多播委托关联多个方法初始关联新增关联新增关联表达式后续讲解调用多播委托依次执行返回最后一个方法的结果执行过程最终返回移除方法移除方法注意多播委托中若有方法抛出异常后续方法会终止执行需自行处理异常委托与方法的签名匹配委托严格要求关联的方法签名与委托一致以下情况会编译报错错误返回值不匹配委托返回方法返回编译错误错误参数数量不匹配委托需个参数方法仅个编译错误错误参数类型不匹配委托参数为方法为编译错误系统内置委托无需自定义提供了个通用内置委托覆盖绝大多数场景无需手动声明委托直接使用即可委托类型用途签名返回值参数示例场景无返回值的方法参数列表执行一段逻辑如打印修改值有返回值的方法参数列表计算并返回结果如求和排序返回的方法用于判断筛选数据如判断数字是否为偶数委托无返回值支持个参数如示例无参数的输出示例带个参数的姓名年龄输出姓名年龄委托有返回值支持个输入参数最后一个泛型参数是返回值类型如示例无输入参数返回输出当前时间如示例个输入返回求和结果委托专门用于判断逻辑输入个参数返回等价于示例判断数字是否为偶数结合列表筛选筛选偶数结果委托的典型应用场景方法作为参数传递解耦场景定义一个通用计算方法允许外部传入不同的计算逻辑如加减乘通用方法接收计算逻辑委托作为参数调用外部传入的逻辑调用时传入不同逻辑无需修改方法优势方法与具体计算逻辑解耦后续新增逻辑如取余无需修改原有代码事件驱动编程基础委托是事件的底层支撑例如按钮点击事件本质是通过委托关联点击后的处理方法简化的按钮类模拟系统声明事件本质是受限制的委托模拟按钮被点击触发事件调用所有关联的方法使用按钮关联点击事件按钮被点击了关联处理逻辑模拟点击输出按钮被点击了异步回调简化版场景异步操作完成后通过委托调用回调方法通知结果如文件读取完成后处理数据异步读取文件完成后调用回调委托异步读取文件模拟耗时操作调用回调方法传递结果调用指定回调逻辑文件内容长度委托与表达式的关系表达式是匿名方法的简写可直接作为参数传递给委托避免定义单独的方法简化代码传统方式定义单独方法关联委托方式直接写匿名方法无需单独定义等价于上面的方法复杂逻辑的多行本质表达式会被编译器转换为匿名方法最终与委托签名匹配常见问题与注意事项委托为时调用必须判断委托是否为否则抛出推荐用简化多播委托的返回值多播委托调用时仅返回最后一个方法的结果前面方法的返回值会被忽略若需获取所有结果需手动遍历委托的委托与接口的区别委托侧重方法引用适合传递单一逻辑接口侧重多方法契约适合定义类的行为规范避免过度使用委托简单场景如固定逻辑无需用委托否则会增加代码复杂度优先使用系统内置委托避免重复声明自定义委托总结委托是类型安全的方法指针核心是实现方法作为参数传递优先使用系统内置的减少自定义委托多播委托支持关联多个方法但需注意异常处理和返回值问题表达式是委托的简化语法糖大幅提升代码简洁性委托是事件异步编程的基础掌握委托是深入高级特性的关键事件事件是中基于委托的核心机制用于实现发布订阅模式是编程异步通信等场景的基础事件本质是受限制的委托提供了更安全的封装事件的基本概念本质与作用本质事件是特殊的委托实例但添加了访问限制仅允许在声明它的类内部触发外部只能订阅取消订阅核心作用实现对象间的松耦合通信发布者通知订阅者双方无需知道彼此细节确保委托调用的安全性防止外部随意修改或触发是控件如按钮点击消息系统的底层实现方式与委托的关系事件依赖委托必须基于某个委托类型声明事件的本质是该委托的一个实例事件是委托的安全包装外部代码只能通过订阅取消订阅事件只有声明事件的类内部才能触发事件调用委托避免了直接使用委托时可能被外部恶意修改的风险事件的声明与使用声明事件的标准步骤定义事件参数类可选用于传递数据通常继承自约定用于在事件触发时传递额外数据事件参数类存储事件相关数据定义委托类型或使用内置委托事件需要基于委托类型声明推荐遵循标准签名委托名事件参数类型自定义委托遵循标准签名或直接使用内置的泛型委托推荐无需自定义委托等价于在发布者类中声明事件使用关键字基于委托类型声明事件温度传感器发布者声明事件基于自定义委托或使用内置更简洁推荐温度变化时触发事件触发事件的保护方法约定命名事件名触发事件调用所有订阅的方法使用避免空引用异常无订阅者时订阅者订阅事件并处理订阅者通过注册事件处理方法方法签名需与事件的委托匹配空调订阅者空调温度过高启动制冷空调温度过低启动制热日志记录器另一个订阅者日志温度从变为使用事件机制创建发布者和订阅者订阅事件注册处理方法改变温度会触发事件输出空调温度过高启动制冷日志温度从变为取消订阅移除处理方法输出日志温度从变为空调已取消订阅不再响应事件的核心语法规则声明方式委托类型事件名订阅发布者事件名订阅者处理方法取消订阅发布者事件名订阅者处理方法触发事件仅能在声明事件的类内部通过事件名参数触发处理方法签名必须与事件的委托类型匹配返回值参数事件参数事件约定与最佳实践命名规范事件名使用过去分词如事件参数类事件名如触发事件的方法事件名如供子类重写推荐使用内置委托无参数事件使用签名带参数事件使用泛型为继承的参数类避免自定义委托减少代码冗余线程安全考量触发事件前建议先将事件引用赋值给临时变量防止多线程环境下订阅者突然取消订阅导致的临时变量存储事件引用调用临时变量避免多线程问题避免过度使用静态事件静态事件的生命周期与应用程序一致容易导致内存泄漏订阅者对象被静态事件引用而无法回收非必要场景优先使用实例事件事件与委托的关键区别特性委托事件本质引用方法的类型安全指针受限制的委托实例安全包装外部访问权限可直接调用赋值修改仅允许订阅和取消订阅触发权限任何地方都可调用只要能访问委托实例仅声明事件的类内部可触发调用使用场景方法作为参数传递多播方法调用发布订阅模式事件通知如按钮点击安全性较低可能被外部恶意修改或调用较高严格限制外部操作典型应用场景控件事件如按钮点击文本框内容变化等模拟按钮点击事件按钮被点击了状态变化通知如温度库存等状态变化时通知相关组件库存管理系统中库存不足时通知采购模块异步操作完成通知如文件下载完成后触发处理逻辑文件下载完成保存路径常见问题与注意事项事件未订阅时触发必须使用或判断否则会抛出处理方法未正确移除若订阅者对象已销毁但未取消订阅会导致内存泄漏事件仍持有对象引用事件参数类未继承虽然允许但不符合约定可能降低代码可读性滥用事件导致性能问题过多订阅者会增加事件触发的耗时需合理设计订阅关系总结事件是受保护的委托核心用于实现发布订阅模式遵循事件约定命名规范继承触发方法优先使用内置和委托减少自定义委托事件确保了委托调用的安全性是松耦合系统设计的关键机制掌握事件是理解编程异步编程的基础表达式表达式是引入的重要特性本质是一种简洁的匿名函数表示方式允许将代码块作为参数传递极大简化了委托和事件的使用是异步编程等现代开发的基础核心概念与语法结构表达式的核心是将方法作为数据传递其基本语法结构为参数列表表达式或语句块其中称为运算符读作左侧是输入参数右侧是要执行的代码根据参数数量和代码复杂度表达式有多种形式无参数当不需要输入参数时使用空括号表示无参数返回字符串无参数多行语句块需用包裹显式单参数单个参数时可省略括号编译器会自动推断参数类型单参数省略括号显式指定参数类型可选单参数多行语句块多参数多个参数需用逗号分隔放在括号中两个参数自动类型推断三个参数显式类型多参数复杂逻辑类型推断机制表达式的强大之处在于编译器的类型推断能力它能根据上下文自动确定参数类型和返回类型上下文的方法需要参数编译器推断是类型表达式返回类型上下文委托类型显式指定编译器知道需要参数和返回值因此被推断为类型推断的限制当表达式单独存在未赋值给委托或作为方法参数时无法推断类型复杂场景下可能需要显式指定参数类型以避免歧义与委托的关系表达式最常见的用途是作为委托的实现任何委托类型都可以接受匹配签名的表达式自定义委托使用表达式实例化委托作为方法参数传递调用时使用返回提供的内置委托类型特别适合与配合使用无返回值的委托有返回值的委托返回的判断委托使用委托使用委托使用委托与匿名方法的对比表达式是匿名方法的进化形式两者都可以创建未命名的方法但更加简洁匿名方法等效的表达式主要区别支持类型推断匿名方法需要显式声明参数类型单表达式可省略和大括号匿名方法必须显式可转换为表达式树匿名方法不能语法更简洁适合编写简短的函数逻辑表达式树表达式可以被编译为两种形式委托可执行的代码表达式树代码的抽象语法树表示编译为委托可直接执行执行得到编译为表达式树表示代码结构解析表达式树输出表达式树的应用场景将表达式转换为语句动态查询构建在运行时创建查询逻辑代码分析和生成检查或动态生成代码闭包特性表达式可以捕获并访问其定义范围内的变量这种特性称为闭包输出外部变量修改会影响的行为输出闭包注意事项捕获的是变量引用而非变量的值变量的生命周期会被延长至表达式的生命周期多线程环境下使用闭包需注意线程安全过度使用闭包可能导致意外行为和内存泄漏在中的应用表达式是方法语法的核心几乎所有操作都依赖来定义查询逻辑筛选部门且薪资高于的员工按部门分组并计算平均薪资在事件处理中的应用表达式简化了事件处理程序的编写无需单独定义方法触发事件使用表达式订阅事件可以包含复杂的处理逻辑发送消息会触发事件处理异步结合关键字表达式可以处理异步操作异步表达式作为参数的异步调用模拟延迟最佳实践与注意事项保持简洁适合实现简短逻辑复杂逻辑应使用命名方法以提高可读性参数命名使用有意义的参数名避免单字母命名除非上下文明确含义避免副作用尽量让表达式无副作用不修改外部状态使代码更可预测注意闭包生命周期避免在长时间运行的中捕获短期变量防止内存泄漏类型推断平衡适当利用类型推断简化代码但在复杂场景中可显式指定类型以提高可读性多播委托注意当用于多播委托时返回值仅最后一个方法的返回值会被保留调试考量复杂的表达式难以调试必要时可临时转换为命名方法总结表达式是中编写简洁灵活代码的强大工具它使开发者能够将函数逻辑作为数据传递极大简化了委托事件和的使用通过理解的语法结构类型推断闭包特性以及与表达式树的关系开发者可以更有效地利用这一特性编写现代高效的代码无论是处理集合数据响应事件实现回调还是构建复杂查询表达式都提供了简洁而强大的语法支持是每个开发者必须掌握的核心技能什么是语言集成查询是引入的重要特性它将查询功能直接集成到语言中提供了一种统一的方式来查询和操作各种数据源如集合数据库等的核心优势在于提供一致的查询语法无论数据源类型如何支持编译时类型检查减少运行时错误允许使用语言本身编写查询无需学习不同的查询语言支持智能提示提高开发效率可将查询逻辑与业务逻辑无缝集成的两种语法形式查询语法基于类语法更接近自然语言可读性强查询语法示例方法语法基于方法调用使用表达式定义查询条件更灵活方法语法示例与上面查询语法等效两种语法可以混合使用编译器会将查询语法转换为对应的方法语法混合语法示例等效于混合使用方法语法核心命名空间使用需引入以下命名空间核心方法表达式树用于的类型根据数据源类型主要分为以下几类用于查询内存中的集合实现的类型查询所有成绩大于的学生按班级分组并计算平均成绩用于查询中的数据库查询计算机系的所有学生统计每个系的学生数量用于直接查询数据库较旧技术逐渐被取代用于查询和操作数据查询所有价格低于的书籍常用操作符筛选操作符筛选满足条件的元素筛选价格大于且库存大于的产品投影操作符将元素转换为新的形式只选择产品名称和价格创建匿名类型嵌套投影到复杂类型将序列的每个元素投影为并平展结果获取所有订单中的所有产品平展结果排序操作符按指定键升序排序按指定键降序排序二次排序升序二次排序降序先按类别升序再按价格降序排序分组操作符按指定键对元素分组按类别分组产品分组并计算每组的统计信息连接操作符基于键相等连接两个序列类似的基于键相等连接两个序列并对结果分组类似的内连接连接客户和他们的订单左连接获取所有客户及其订单包括没有订单的客户聚合操作符计算序列中的元素数量计算序列中数值的总和计算序列中数值的平均值获取序列中的最小值获取序列中的最大值对序列应用自定义聚合操作基本聚合自定义聚合计算所有数字的乘积结果元素操作符返回序列中的第一个元素在序列为空时返回默认值返回序列中的最后一个元素返回序列中唯一的元素若存在多个元素则抛出异常返回指定索引处的元素获取第一个价格大于的产品获取最后一个订单若没有订单则返回获取为的唯一客户获取索引为的产品集合操作符移除序列中的重复元素返回两个序列的并集不包含重复元素返回两个序列的交集返回两个序列的差集获取所有不重复的产品类别获取两个列表中所有不重复的产品获取两个列表中都存在的产品获取在第一个列表中但不在第二个列表中的产品延迟执行与立即执行查询有两种执行方式理解这一点对正确使用至关重要延迟执行大多数操作符如是延迟执行的即查询定义时不会立即执行直到实际需要结果时才执行定义查询此时不执行修改数据源执行查询此时会包含刚添加的产品延迟执行的好处提高性能避免不必要的计算可以构建复杂的查询链数据源的后续更改会反映在查询结果中立即执行以下操作会立即执行查询并返回结果聚合操作符等转换为集合的方法等元素操作符等立即执行转换为列表此时执行查询并创建列表修改数据源不会影响已创建的列表列表中不包含刚添加的产品与有两种主要的接口用于内存中的集合使用委托等表示查询逻辑查询在客户端执行执行时会在客户端内存中筛选所有产品用于远程数据源如数据库使用表达式树表示查询逻辑查询可以转换为数据源的原生查询语言如在服务器端执行执行时会转换为在数据库服务器上执行查询只返回符合条件的结果关键区别在客户端内存中处理所有数据而尽可能在数据源端处理查询只返回需要的数据通常性能更好中的匿名类型经常使用匿名类型来存储查询结果的子集创建匿名类型使用匿名类型匿名类型的特点编译器自动生成的只读类型只能在声明的方法内部使用属性名称和类型由初始化表达式推断适合临时存储查询结果性能考量尽量使用而非处理数据库查询低效将所有产品加载到内存后再筛选高效在数据库中筛选只加载符合条件的产品避免查询问题低效会产生个查询获取所有订单然后为每个订单产生个查询获取订单项每个订单产生一个新查询高效使用一次性加载相关数据适当使用延迟执行高效只获取需要的字段对大型集合使用分页分页查询只获取第页的条记录总结是中强大的查询技术它提供了统一的方式来查询和操作各种数据源通过开发者可以使用熟悉的语法编写查询而不必学习不同数据源的查询语言有两种语法形式类的查询语法和基于方法的方法语法两者可以互换使用理解延迟执行和立即执行的区别以及和的不同对于编写高效的查询至关重要掌握可以显著提高代码的可读性和开发效率尤其是在处理集合数据和数据库操作时通过合理使用各种操作符可以简洁地实现复杂的数据筛选转换和聚合功能',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-25 17:53:15',
  postMainColor: '#3AC9E7',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.min.css"><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/sparkle520?tab=repositories" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">SPARKLE</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Deep-Learning/" style="font-size: 1.05rem;">Deep Learning<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/JSR303/" style="font-size: 1.05rem;">JSR303<sup>1</sup></a><a href="/tags/Matplotlib/" style="font-size: 1.05rem;">Matplotlib<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>4</sup></a><a href="/tags/npc%E5%88%86%E6%9E%90%E6%B3%95/" style="font-size: 1.05rem;">npc分析法<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>5</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>1</sup></a><a href="/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/" style="font-size: 1.05rem;">二次型<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%82/" style="font-size: 1.05rem;">你的名字。<sup>3</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">你的名字同名小说<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%A4%96%E4%BC%A0%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">你的名字外传小说<sup>1</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">包管理<sup>1</sup></a><a href="/tags/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/" style="font-size: 1.05rem;">卷积公式<sup>1</sup></a><a href="/tags/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" style="font-size: 1.05rem;">向量代数与空间解析几何<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/" style="font-size: 1.05rem;">天气之子<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">天气之子同名小说<sup>1</sup></a><a href="/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/" style="font-size: 1.05rem;">定积分<sup>2</sup></a><a href="/tags/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/" style="font-size: 1.05rem;">导数与微分<sup>1</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">小说<sup>10</sup></a><a href="/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" style="font-size: 1.05rem;">微分方程<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" style="font-size: 1.05rem;">数据校验<sup>1</sup></a><a href="/tags/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/" style="font-size: 1.05rem;">无穷级数<sup>1</sup></a><a href="/tags/%E6%9E%81%E9%99%90/" style="font-size: 1.05rem;">极限<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 1.05rem;">概率论<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" style="font-size: 1.05rem;">概率论与数理统计<sup>7</sup></a><a href="/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" style="font-size: 1.05rem;">泰勒展开<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%80%BC/" style="font-size: 1.05rem;">特征值<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" style="font-size: 1.05rem;">特征向量<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/" style="font-size: 1.05rem;">网络层<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/" style="font-size: 1.05rem;">英语听力<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 1.05rem;">英语语法<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/" style="font-size: 1.05rem;">词根词缀<sup>1</sup></a><a href="/tags/%E8%B4%A5%E5%8C%97%E5%A5%B3%E8%A7%92%E5%A4%AA%E5%A4%9A%E4%BA%86/" style="font-size: 1.05rem;">败北女角太多了!<sup>7</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" style="font-size: 1.05rem;">高等代数<sup>2</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">高等数学<sup>9</sup></a><a href="/tags/%E9%AB%98%E9%A2%91%E8%AF%8D%E7%BB%84/" style="font-size: 1.05rem;">高频词组<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url">计算机</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/c/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>c#</span></a></span></div></div><h1 class="post-title" itemprop="name headline">c# 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-09-23T15:00:27.000Z" title="发表于 2025-09-23 23:00:27">2025-09-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-09-25T09:53:15.074Z" title="更新于 2025-09-25 17:53:15">2025-09-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">14k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="c# 笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为系守镇"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>系守镇</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/09/23/csharp%E7%AC%94%E8%AE%B0/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic1.imgdb.cn/item/68d363acc5157e1a882c5be1.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url">计算机</a><a href="/tags/c/" tabindex="-1" itemprop="url">c#</a><h1 id="CrawlerTitle" itemprop="name headline">c# 笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">sparkle520</span><time itemprop="dateCreated datePublished" datetime="2025-09-23T15:00:27.000Z" title="发表于 2025-09-23 23:00:27">2025-09-23</time><time itemprop="dateCreated datePublished" datetime="2025-09-25T09:53:15.074Z" title="更新于 2025-09-25 17:53:15">2025-09-25</time></header><p>在 C# 中，协变 ( Covariance ) 和逆变 ( Contravariance )
是用于描述泛型接口和委托中类型参数转换关系的概念，它们允许在泛型类型之间进行更灵活的转换.</p>
<h1 id="协变-covariance">协变 ( Covariance )</h1>
<p>协变允许将派生类型的泛型对象赋值给基类型的泛型对象，使用
<code>out</code> 关键字标记类型参数.</p>
<p><strong>适用场景</strong> :
当泛型接口/委托的类型参数仅作为返回值使用时.</p>
<p>示例:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协变接口 ( 使用 out 关键字 ) </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICovariant</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="function">T <span class="title">GetItem</span>()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> { }</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> { }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CovariantImplementation</span>&lt;<span class="title">T</span>&gt; : <span class="title">ICovariant</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetItem</span>()</span> =&gt; <span class="literal">default</span>(T);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">ICovariant&lt;Dog&gt; dogCovariant = <span class="keyword">new</span> CovariantImplementation&lt;Dog&gt;();</span><br><span class="line">ICovariant&lt;Animal&gt; animalCovariant = dogCovariant; <span class="comment">// 协变转换，合法</span></span><br></pre></td></tr></table></figure>
<h1 id="逆变-contravariance">逆变 ( Contravariance )</h1>
<p>逆变允许将基类型的泛型对象赋值给派生类型的泛型对象，使用
<code>in</code> 关键字标记类型参数.</p>
<p><strong>适用场景</strong> :
当泛型接口/委托的类型参数仅作为输入参数使用时.</p>
<p>示例: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆变接口 ( 使用 in 关键字 ) </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IContravariant</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetItem</span>(<span class="params">T item</span>)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContravariantImplementation</span>&lt;<span class="title">T</span>&gt; : <span class="title">IContravariant</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetItem</span>(<span class="params">T item</span>)</span> { }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">IContravariant&lt;Animal&gt; animalContravariant = <span class="keyword">new</span> ContravariantImplementation&lt;Animal&gt;();</span><br><span class="line">IContravariant&lt;Dog&gt; dogContravariant = animalContravariant; <span class="comment">// 逆变转换，合法</span></span><br></pre></td></tr></table></figure></p>
<h1 id="委托中的协变和逆变">委托中的协变和逆变</h1>
<p>C# 中的委托也支持协变和逆变:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协变委托 ( 返回值 ) </span></span><br><span class="line">Func&lt;Dog&gt; dogFunc = () =&gt; <span class="keyword">new</span> Dog();</span><br><span class="line">Func&lt;Animal&gt; animalFunc = dogFunc; <span class="comment">// 协变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆变委托 ( 参数 ) </span></span><br><span class="line">Action&lt;Animal&gt; animalAction = (a) =&gt; { };</span><br><span class="line">Action&lt;Dog&gt; dogAction = animalAction; <span class="comment">// 逆变</span></span><br></pre></td></tr></table></figure>
<h1 id="关键规则">关键规则</h1>
<ul>
<li>协变使用 <code>out</code> 关键字，类型参数只能作为返回值</li>
<li>逆变使用 <code>in</code> 关键字，类型参数只能作为输入参数</li>
<li>只有接口和委托支持协变和逆变，类和结构不支持</li>
<li>数组也支持协变，但可能导致运行时错误，应谨慎使用</li>
</ul>
<p>理解协变和逆变有助于编写更灵活、更通用的代码，特别是在处理集合、事件和委托时非常有用.</p>
<h1 id="c-反射机制详解-含泛型操作">C# 反射机制详解 ( 含泛型操作 )</h1>
<h2 id="反射的核心概念">反射的核心概念</h2>
<p>反射 ( Reflection ) 是 C# 中一种运行时元数据访问机制，允许程序在
<strong>不依赖编译时类型信息</strong> 的前提下，动态检查、访问和操作类型
( 类、接口、结构体等 ) 的成员 ( 字段、属性、方法、构造函数等 ) .
其本质是通过 <code>System.Reflection</code> 命名空间提供的
API，解析程序集 ( Assembly )
中存储的类型元数据，实现"动态探测"和"动态操作".</p>
<h5 id="反射的核心价值">反射的核心价值</h5>
<ul>
<li><strong>打破封装限制</strong> : 可访问类的私有成员 (
需显式指定访问权限 ) .</li>
<li><strong>提升代码灵活性</strong> :
动态创建对象、调用方法，适配多变的业务场景 ( 如插件系统、配置驱动开发 )
.</li>
<li><strong>支撑框架级功能</strong> : 是序列化/反序列化 ( 如 JSON 解析 )
、依赖注入 ( DI ) 、ORM 框架 ( 如 EF Core )
、单元测试框架的底层核心技术.</li>
</ul>
<h2 id="反射的基础操作-非泛型">反射的基础操作 ( 非泛型 )</h2>
<p>基础反射围绕"获取类型信息 → 操作类型成员"展开，核心入口是
<code>System.Type</code> 类 ( 每个类型在内存中对应唯一的
<code>Type</code> 对象 ) .</p>
<h3 id="获取-type-对象">获取 Type 对象</h3>
<p>获取 <code>Type</code> 对象是反射的第一步，常见方式有 3 种:</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 45%">
</colgroup>
<thead>
<tr>
<th>方式</th>
<th>语法</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>typeof()</strong> 运算符</td>
<td>Type type = typeof(目标类型);</td>
<td>已知编译时类型，直接获取</td>
</tr>
<tr>
<td><strong>GetType()</strong> 方法</td>
<td>Type type = 对象实例.GetType();</td>
<td>已知对象实例，动态获取其类型</td>
</tr>
<tr>
<td><strong>Assembly.GetType()</strong></td>
<td>Type type = 程序集对象.GetType("完整类型名");</td>
<td>已知类型的完整名称 ( 含命名空间 ) ，从指定程序集获取</td>
</tr>
</tbody>
</table>
<p>示例: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义示例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age { <span class="keyword">get</span> =&gt; _age; <span class="keyword">set</span> =&gt; _age = <span class="keyword">value</span> &gt; <span class="number">0</span> ? <span class="keyword">value</span> : <span class="number">0</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> { }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span> { Name = name; Age = age; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> =&gt; Console.WriteLine(<span class="string">$"Hello, <span class="subst">{Name}</span>!"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetSecret</span>(<span class="params"><span class="built_in">string</span> pwd</span>)</span> =&gt; pwd == <span class="string">"123"</span> ? <span class="string">"Secret"</span> : <span class="string">"Denied"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type 对象</span></span><br><span class="line">Type personType1 = <span class="keyword">typeof</span>(Person); <span class="comment">// 方式1: typeof</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="number">20</span>);</span><br><span class="line">Type personType2 = p.GetType();    <span class="comment">// 方式2: GetType()</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查看类型成员信息">查看类型成员信息</h3>
<p>通过 <code>Type</code>
对象的方法，可获取类型的字段、属性、方法、构造函数等成员信息，返回对应的
<code>FieldInfo</code>、<code>PropertyInfo</code>、<code>MethodInfo</code>、<code>ConstructorInfo</code>
对象.</p>
<h4 id="核心成员获取方法">核心成员获取方法</h4>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 45%">
</colgroup>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>常用重载</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetFields()</td>
<td>获取字段</td>
<td>GetFields(BindingFlags) : 指定访问权限 ( 如公共/私有、静态/实例
)</td>
</tr>
<tr>
<td>GetProperties()</td>
<td>获取属性</td>
<td>同上</td>
</tr>
<tr>
<td>GetMethods()</td>
<td>获取方法</td>
<td>同上 ( 需过滤 Object 继承的方法 )</td>
</tr>
<tr>
<td>GetConstructors()</td>
<td>获取构造函数</td>
<td>同上</td>
</tr>
</tbody>
</table>
<h4 id="bindingflags-枚举-关键">BindingFlags 枚举 ( 关键 )</h4>
<p>用于筛选成员的访问范围，常用组合:</p>
<ul>
<li>公共实例成员:
<code>BindingFlags.Public | BindingFlags.Instance</code></li>
<li>私有实例成员:
<code>BindingFlags.NonPublic | BindingFlags.Instance</code></li>
<li>公共静态成员:
<code>BindingFlags.Public | BindingFlags.Static</code></li>
</ul>
<p>示例: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Person 类的公共字段和属性</span></span><br><span class="line">FieldInfo[] publicFields = personType1.GetFields(BindingFlags.Public | BindingFlags.Instance);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> field <span class="keyword">in</span> publicFields)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"公共字段: <span class="subst">{field.Name}</span> ( 类型: <span class="subst">{field.FieldType.Name}</span> ) "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">PropertyInfo[] publicProps = personType1.GetProperties(BindingFlags.Public | BindingFlags.Instance);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> publicProps)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"公共属性: <span class="subst">{prop.Name}</span> ( 类型: <span class="subst">{prop.PropertyType.Name}</span> ) "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有方法 GetSecret</span></span><br><span class="line">MethodInfo secretMethod = personType1.GetMethod(</span><br><span class="line">    <span class="string">"GetSecret"</span>, </span><br><span class="line">    BindingFlags.NonPublic | BindingFlags.Instance, </span><br><span class="line">    <span class="keyword">new</span>[] { <span class="keyword">typeof</span>(<span class="built_in">string</span>) } <span class="comment">// 指定参数类型 ( 避免方法重载歧义 ) </span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="动态操作类型成员">动态操作类型成员</h3>
<p>获取成员信息 ( 如 <code>FieldInfo</code>、<code>MethodInfo</code> )
后，可通过其提供的方法动态操作.</p>
<h4 id="动态创建对象">动态创建对象</h4>
<p>通过 <code>Activator.CreateInstance()</code> 或
<code>ConstructorInfo.Invoke()</code> 实现: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: 无参构造函数</span></span><br><span class="line"><span class="built_in">object</span> person1 = Activator.CreateInstance(personType1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 带参构造函数 ( 参数顺序需与构造函数一致 ) </span></span><br><span class="line"><span class="built_in">object</span>[] ctorParams = { <span class="string">"Bob"</span>, <span class="number">25</span> };</span><br><span class="line"><span class="built_in">object</span> person2 = Activator.CreateInstance(personType1, ctorParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3: 通过 ConstructorInfo 调用 ( 更灵活，支持重载 ) </span></span><br><span class="line">ConstructorInfo ctor = personType1.GetConstructor(<span class="keyword">new</span>[] { <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) });</span><br><span class="line"><span class="built_in">object</span> person3 = ctor.Invoke(ctorParams);</span><br></pre></td></tr></table></figure></p>
<h4 id="动态访问修改字段属性">动态访问/修改字段/属性</h4>
<ul>
<li>字段: <code>FieldInfo.GetValue(对象实例)</code> /
<code>FieldInfo.SetValue(对象实例, 新值)</code></li>
<li>属性: <code>PropertyInfo.GetValue(对象实例)</code> /
<code>PropertyInfo.SetValue(对象实例, 新值)</code></li>
</ul>
<p>示例: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作字段 Name</span></span><br><span class="line">FieldInfo nameField = personType1.GetField(<span class="string">"Name"</span>);</span><br><span class="line">nameField.SetValue(person2, <span class="string">"Charlie"</span>); <span class="comment">// 修改 person2 的 Name</span></span><br><span class="line">Console.WriteLine(nameField.GetValue(person2)); <span class="comment">// 输出: Charlie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作属性 Age</span></span><br><span class="line">PropertyInfo ageProp = personType1.GetProperty(<span class="string">"Age"</span>);</span><br><span class="line">ageProp.SetValue(person2, <span class="number">30</span>); <span class="comment">// 修改 Age ( 会触发属性的 set 逻辑 ) </span></span><br><span class="line">Console.WriteLine(ageProp.GetValue(person2)); <span class="comment">// 输出: 30</span></span><br></pre></td></tr></table></figure></p>
<h4 id="动态调用方法">动态调用方法</h4>
<p>通过 <code>MethodInfo.Invoke(对象实例, 参数数组)</code>
实现，静态方法的第一个参数为 <code>null</code>: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用公共方法 SayHello</span></span><br><span class="line">MethodInfo sayHelloMethod = personType1.GetMethod(<span class="string">"SayHello"</span>);</span><br><span class="line">sayHelloMethod.Invoke(person2, <span class="literal">null</span>); <span class="comment">// 输出: Hello, Charlie!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用私有方法 GetSecret</span></span><br><span class="line">MethodInfo secretMethod = personType1.GetMethod(</span><br><span class="line">    <span class="string">"GetSecret"</span>, </span><br><span class="line">    BindingFlags.NonPublic | BindingFlags.Instance</span><br><span class="line">);</span><br><span class="line"><span class="built_in">object</span> secretResult = secretMethod.Invoke(person2, <span class="keyword">new</span>[] { <span class="string">"123"</span> });</span><br><span class="line">Console.WriteLine(secretResult); <span class="comment">// 输出: Secret</span></span><br></pre></td></tr></table></figure></p>
<h2 id="泛型的反射操作-重点">泛型的反射操作 ( 重点 )</h2>
<p>泛型的反射比非泛型更复杂，核心是区分"未构造泛型类型"和"构造泛型类型"，并通过特定
API 处理类型参数.</p>
<h3 id="泛型的核心概念">泛型的核心概念</h3>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>概念</th>
<th>定义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>未构造泛型类型 ( Open Generic Type )</td>
<td>未指定类型参数的泛型类型，是"模板"</td>
<td>List<t>、Dictionary&lt;TKey, TValue&gt;</t></td>
</tr>
<tr>
<td>构造泛型类型 ( Closed Generic Type )</td>
<td>已指定具体类型参数的泛型类型，是"可实例化的类型"</td>
<td>List<int>、Dictionary&lt;string, int&gt;</int></td>
</tr>
<tr>
<td>泛型方法定义</td>
<td>未指定类型参数的泛型方法</td>
<td>void Add<t>(T item)</t></td>
</tr>
<tr>
<td>构造泛型方法</td>
<td>已指定类型参数的泛型方法</td>
<td>void Add<int>(int item)</int></td>
</tr>
</tbody>
</table>
<h3 id="泛型类型的反射">泛型类型的反射</h3>
<h4 id="获取泛型类型">获取泛型类型</h4>
<ul>
<li>未构造泛型类型: 通过 <code>typeof(泛型类型名&lt;&gt;)</code> 获取 (
注意尖括号内的占位符数量与泛型参数数量一致 ) .</li>
<li>构造泛型类型: 通过
<code>未构造类型.MakeGenericType(类型参数数组)</code> 生成.</li>
</ul>
<p>示例 ( 以自定义泛型类 <code>GenericDemo&lt;T, U&gt;</code> 为例 ) :
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericDemo</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> T GenericField;</span><br><span class="line">    <span class="keyword">public</span> U GenericProp { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericDemo</span>(<span class="params">T field, U prop</span>)</span> { GenericField = field; GenericProp = prop; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Combine</span>()</span> =&gt; <span class="string">$"<span class="subst">{GenericField}</span> - <span class="subst">{GenericProp}</span>"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取未构造泛型类型 ( GenericDemo&lt;T, U&gt; ) </span></span><br><span class="line">Type openGenericType = <span class="keyword">typeof</span>(GenericDemo&lt;,&gt;); <span class="comment">// 尖括号内 2 个占位符 ( 对应 2 个泛型参数 ) </span></span><br><span class="line">Console.WriteLine(openGenericType.IsGenericType); <span class="comment">// 输出: True</span></span><br><span class="line">Console.WriteLine(openGenericType.IsGenericTypeDefinition); <span class="comment">// 输出: True ( 是否为未构造类型 ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取泛型类型参数 ( T、U ) </span></span><br><span class="line">Type[] typeParams = openGenericType.GetGenericArguments();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> param <span class="keyword">in</span> typeParams)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"泛型参数: <span class="subst">{param.Name}</span>"</span>); <span class="comment">// 输出: T、U</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成构造泛型类型 ( GenericDemo&lt;int, string&gt; ) </span></span><br><span class="line">Type[] concreteTypes = { <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) };</span><br><span class="line">Type closedGenericType = openGenericType.MakeGenericType(concreteTypes);</span><br><span class="line">Console.WriteLine(closedGenericType.FullName); <span class="comment">// 输出: GenericDemo`2[[System.Int32],[System.String]]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="动态创建泛型对象">动态创建泛型对象</h4>
<p>与非泛型类似，通过
<code>Activator.CreateInstance(构造泛型类型, 构造函数参数)</code> 实现:
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 GenericDemo&lt;int, string&gt; 的实例 ( 构造函数参数: 100, "Test" ) </span></span><br><span class="line"><span class="built_in">object</span> genericInstance = Activator.CreateInstance(closedGenericType, <span class="number">100</span>, <span class="string">"Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问泛型字段和属性</span></span><br><span class="line">FieldInfo genericField = closedGenericType.GetField(<span class="string">"GenericField"</span>);</span><br><span class="line">Console.WriteLine(genericField.GetValue(genericInstance)); <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">PropertyInfo genericProp = closedGenericType.GetProperty(<span class="string">"GenericProp"</span>);</span><br><span class="line">Console.WriteLine(genericProp.GetValue(genericInstance)); <span class="comment">// 输出: Test</span></span><br></pre></td></tr></table></figure></p>
<h4 id="调用泛型类的非泛型方法">调用泛型类的非泛型方法</h4>
<p>与非泛型类的方法调用一致，通过 <code>MethodInfo.Invoke()</code> 实现:
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo combineMethod = closedGenericType.GetMethod(<span class="string">"Combine"</span>);</span><br><span class="line"><span class="built_in">object</span> combineResult = combineMethod.Invoke(genericInstance, <span class="literal">null</span>);</span><br><span class="line">Console.WriteLine(combineResult); <span class="comment">// 输出: 100 - Test</span></span><br></pre></td></tr></table></figure></p>
<h3 id="泛型方法的反射">泛型方法的反射</h3>
<p>泛型方法分为"泛型方法定义"和"构造泛型方法"，需先获取方法定义，再指定类型参数生成构造方法，最后调用.</p>
<h4 id="示例-以泛型方法-converttovvt-input-为例">示例 ( 以泛型方法
<code>ConvertToV&lt;V&gt;(T input)</code> 为例 )</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 GenericDemo&lt;T, U&gt; 中添加泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericDemo</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 泛型方法: 将 T 类型转换为 V 类型，并返回 List&lt;V&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">V</span>&gt; <span class="title">ConvertToV</span>&lt;<span class="title">V</span>&gt;(<span class="params">T input</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;V&gt; { (V)Convert.ChangeType(input, <span class="keyword">typeof</span>(V)) };</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取泛型方法定义 ( ConvertToV&lt;V&gt; ) </span></span><br><span class="line">Type closedGenericType = <span class="keyword">typeof</span>(GenericDemo&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;); <span class="comment">// 先获取构造泛型类型</span></span><br><span class="line">MethodInfo openGenericMethod = closedGenericType.GetMethod(<span class="string">"ConvertToV"</span>);</span><br><span class="line">Console.WriteLine(openGenericMethod.IsGenericMethod); <span class="comment">// 输出: True</span></span><br><span class="line">Console.WriteLine(openGenericMethod.IsGenericMethodDefinition); <span class="comment">// 输出: True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成构造泛型方法 ( ConvertToV&lt;double&gt; ) </span></span><br><span class="line">Type[] methodTypeParams = { <span class="keyword">typeof</span>(<span class="built_in">double</span>) }; <span class="comment">// 指定泛型方法的类型参数 V = double</span></span><br><span class="line">MethodInfo closedGenericMethod = openGenericMethod.MakeGenericMethod(methodTypeParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造泛型方法 ( 参数: input = 15 ) </span></span><br><span class="line"><span class="built_in">object</span> genericInstance = Activator.CreateInstance(closedGenericType, <span class="number">100</span>, <span class="string">"Test"</span>);</span><br><span class="line"><span class="built_in">object</span> methodResult = closedGenericMethod.Invoke(genericInstance, <span class="keyword">new</span> <span class="built_in">object</span>[] { <span class="number">15</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析结果 ( List&lt;double&gt; ) </span></span><br><span class="line"><span class="keyword">if</span> (methodResult <span class="keyword">is</span> List&lt;<span class="built_in">double</span>&gt; doubleList)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(doubleList[<span class="number">0</span>]); <span class="comment">// 输出: 15.0</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="静态泛型方法的反射">静态泛型方法的反射</h3>
<p>静态泛型方法的反射与实例泛型方法类似，仅需注意调用时
<code>Invoke()</code> 的第一个参数为 <code>null</code>:
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 GenericDemo&lt;T, U&gt; 中添加静态泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StaticGenericMethod</span>&lt;<span class="title">W</span>&gt;(<span class="params">W <span class="keyword">value</span></span>)</span></span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"Static: <span class="subst">{<span class="keyword">value</span>}</span> ( 类型: <span class="subst">{<span class="keyword">typeof</span>(W).Name}</span> ) "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态泛型方法定义</span></span><br><span class="line">Type openGenericType = <span class="keyword">typeof</span>(GenericDemo&lt;,&gt;); <span class="comment">// 未构造泛型类型</span></span><br><span class="line">MethodInfo staticOpenMethod = openGenericType.GetMethod(<span class="string">"StaticGenericMethod"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成构造静态泛型方法 ( W = string ) </span></span><br><span class="line">MethodInfo staticClosedMethod1 = staticOpenMethod.MakeGenericMethod(<span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">staticClosedMethod1.Invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] { <span class="string">"Hello Static"</span> }); <span class="comment">// 输出: Static: Hello Static ( 类型: String ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成另一个构造静态泛型方法 ( W = DateTime ) </span></span><br><span class="line">MethodInfo staticClosedMethod2 = staticOpenMethod.MakeGenericMethod(<span class="keyword">typeof</span>(DateTime));</span><br><span class="line">staticClosedMethod2.Invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] { DateTime.Now }); <span class="comment">// 输出: Static: 2024/5/20 10:00:00 ( 类型: DateTime ) </span></span><br></pre></td></tr></table></figure></p>
<h2 id="反射的优缺点与注意事项">反射的优缺点与注意事项</h2>
<h3 id="优点">优点</h3>
<ol type="1">
<li><strong>灵活性高</strong> :
动态适配未知类型，支撑插件化、配置驱动等场景.</li>
<li><strong>通用性强</strong> : 可编写通用框架 ( 如序列化工具 )
，无需针对具体类型编码.</li>
<li><strong>打破封装</strong> : 可访问私有成员，方便单元测试或特殊场景 (
需谨慎使用 ) .</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol type="1">
<li><strong>性能损耗</strong> : 反射需解析元数据，比直接调用慢 10~100 倍
( 高频场景需缓存 <code>Type</code>、<code>MethodInfo</code> 等对象 )
.</li>
<li><strong>编译时无检查</strong> :
成员名称、参数类型错误仅在运行时抛出异常，增加调试难度.</li>
<li><strong>破坏封装性</strong> :
访问私有成员可能违反面向对象设计原则，导致代码耦合度升高.</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<ol type="1">
<li><strong>缓存反射对象</strong> :
<code>Type</code>、<code>MethodInfo</code>、<code>PropertyInfo</code>
等对象是线程安全的，可缓存复用，减少性能损耗.</li>
<li><strong>指定 BindingFlags</strong> :
获取非公共成员或静态成员时，必须显式指定
<code>BindingFlags</code>，否则会返回 <code>null</code>.</li>
<li><strong>处理泛型歧义</strong> : 泛型方法重载时，需通过
<code>GetMethod()</code> 的参数类型数组区分，避免获取错误的方法.</li>
<li><strong>权限控制</strong> : 部分环境 ( 如沙箱 )
可能限制反射访问私有成员，需提前确认权限.</li>
</ol>
<h2 id="常见应用场景">常见应用场景</h2>
<ol type="1">
<li><strong>序列化/反序列化</strong> : 如
Newtonsoft.Json，通过反射遍历对象成员，将对象转换为 JSON 字符串 ( 或反之
) .</li>
<li><strong>依赖注入 ( DI ) </strong> : 如
Autofac、Microsoft.Extensions.DependencyInjection，通过反射创建服务实例，注入到依赖对象中.</li>
<li><strong>ORM 框架</strong> : 如 EF
Core，通过反射映射实体类属性与数据库表字段，生成 SQL 语句.</li>
<li><strong>插件系统</strong> : 如 Visual Studio
插件，通过反射加载外部程序集，调用插件中的方法.</li>
<li><strong>单元测试</strong> : 如
xUnit，通过反射调用测试方法，访问私有成员验证内部逻辑.</li>
</ol>
<h1 id="c-特性-attribute-详解">C# 特性 ( Attribute ) 详解</h1>
<p>特性 ( Attribute ) 是 C#
中一种强大的元数据机制，允许开发者在代码中嵌入额外信息，这些信息可以在编译时被编译器使用或在运行时通过反射读取.
特性为程序提供了一种声明式编程方式，广泛应用于框架开发、代码分析和运行时行为控制.</p>
<h2 id="特性的基本概念">特性的基本概念</h2>
<h3 id="什么是特性">什么是特性</h3>
<p>特性是一种特殊的类，继承自
<code>System.Attribute</code>，用于为代码元素 ( 类、方法、属性等 )
添加元数据.
它们不会直接影响代码的执行逻辑，而是通过工具或运行时反射来使用这些元数据.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特性的基本形式</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 特性的实现</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用特性</span></span><br><span class="line">[<span class="meta">My</span>] <span class="comment">// 可省略 Attribute 后缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span> { }</span><br></pre></td></tr></table></figure>
<h3 id="特性的命名规范">特性的命名规范</h3>
<ul>
<li>特性类通常以 <code>Attribute</code> 结尾 ( 如
<code>ObsoleteAttribute</code> )</li>
<li>应用时可以省略 <code>Attribute</code> 后缀 ( 如
<code>[Obsolete]</code> 等价于 <code>[ObsoleteAttribute]</code> )</li>
<li>特性类必须直接或间接继承自 <code>System.Attribute</code></li>
</ul>
<h3 id="特性的应用目标">特性的应用目标</h3>
<p>特性可以应用于几乎所有代码元素，包括 : 程序集 ( Assembly ) 、模块 (
Module ) 、类 ( Class ) 、结构体 ( Struct ) 、枚举 ( Enum ) 、构造函数 (
Constructor ) 、方法 ( Method ) 、属性 ( Property ) 、字段 ( Field )
、事件 ( Event ) 、接口 ( Interface ) 、参数 ( Parameter ) 、返回值 (
ReturnValue )</p>
<h2 id="attributeusage-特性">AttributeUsage 特性</h2>
<p><code>[AttributeUsage]</code>
是一个特殊的特性，用于控制自定义特性的使用规则，它有三个重要参数 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(</span></span><br><span class="line"><span class="meta">    AttributeTargets.Target1 | AttributeTargets.Target2,</span></span><br><span class="line"><span class="meta">    AllowMultiple = false,</span></span><br><span class="line"><span class="meta">    Inherited = true</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyAttribute</span> : <span class="title">Attribute</span> { }</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p><strong>AttributeTargets</strong> : 指定特性可以应用到的代码元素
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许应用于类和方法</span></span><br><span class="line">AttributeTargets.Class | AttributeTargets.Method</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>AllowMultiple</strong> :
指定是否允许在同一元素上多次应用该特性</p>
<ul>
<li><code>true</code> : 允许多次应用</li>
<li><code>false</code> ( 默认 ) : 不允许</li>
</ul></li>
<li><p><strong>Inherited</strong> : 指定特性是否可以被派生类继承</p>
<ul>
<li><code>true</code> ( 默认 ) : 可以继承</li>
<li><code>false</code> : 不能继承</li>
</ul></li>
</ol>
<h2 id="常用内置特性">常用内置特性</h2>
<p>C# 提供了许多内置特性，以下是最常用的几种 :</p>
<h3 id="obsolete-特性">Obsolete 特性</h3>
<p>标记代码元素为过时，编译器会产生警告或错误</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Obsolete(<span class="string">"此方法已过时，请使用 NewMethod() 替代"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldMethod</span>()</span> { }</span><br><span class="line"></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">"此方法已禁用，不应该再使用"</span>, true)</span>] <span class="comment">// 第二个参数为 true 会产生错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisabledMethod</span>()</span> { }</span><br></pre></td></tr></table></figure>
<h3 id="conditional-特性">Conditional 特性</h3>
<p>根据条件编译符号决定是否保留方法调用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG // 定义条件编译符号</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="string">"DEBUG"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DebugLog</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"Debug: <span class="subst">{message}</span>"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有在定义了 DEBUG 符号时，下面的调用才会生效</span></span><br><span class="line">DebugLog(<span class="string">"程序启动"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="serializable-特性">Serializable 特性</h3>
<p>标记类可以被序列化</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记不序列化的字段</span></span><br><span class="line">    [<span class="meta">NonSerialized</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _password;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="deprecated-特性-.net-5">Deprecated 特性 ( .NET 5+ )</h3>
<p>比 <code>Obsolete</code> 更现代的替代，提供更丰富的废弃信息</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Deprecated(<span class="string">"2.0.0"</span>, <span class="string">"3.0.0"</span>, Message = <span class="string">"请使用 NewFeature()"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldFeature</span>()</span> { }</span><br></pre></td></tr></table></figure>
<h3 id="程序集特性">程序集特性</h3>
<p>应用于整个程序集，通常在 AssemblyInfo.cs 中定义</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">assembly: AssemblyTitle(<span class="string">"My Application"</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyVersion(<span class="string">"1.0.0.0"</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyDescription(<span class="string">"这是一个示例应用程序"</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyCompany(<span class="string">"My Company"</span>)</span>]</span><br></pre></td></tr></table></figure>
<h3 id="数据验证特性">数据验证特性</h3>
<p>在 ASP.NET 等框架中用于模型验证</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">Required(ErrorMessage = <span class="string">"ID 不能为空"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MaxLength(50, ErrorMessage = <span class="string">"姓名不能超过 50 个字符"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">EmailAddress(ErrorMessage = <span class="string">"请输入有效的邮箱地址"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Email { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(18, 120, ErrorMessage = <span class="string">"年龄必须在 18 到 120 之间"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="自定义特性">自定义特性</h2>
<p>创建自定义特性可以为代码添加特定领域的元数据，步骤如下 :</p>
<h3 id="创建自定义特性类">创建自定义特性类</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义特性可以应用的目标、是否允许多次应用、是否可继承</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, </span></span><br><span class="line"><span class="meta">                AllowMultiple = true, </span></span><br><span class="line"><span class="meta">                Inherited = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CodeInfoAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 位置参数 ( 必须在构造函数中指定 ) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Author { <span class="keyword">get</span>; }</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Version { <span class="keyword">get</span>; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命名参数 ( 可选 ) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="keyword">public</span> DateTime CreatedDate { <span class="keyword">get</span>; <span class="keyword">set</span>; } = DateTime.Now;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数 - 定义位置参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeInfoAttribute</span>(<span class="params"><span class="built_in">string</span> author, <span class="built_in">string</span> version</span>)</span></span><br><span class="line">    {</span><br><span class="line">        Author = author;</span><br><span class="line">        Version = version;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="应用自定义特性">应用自定义特性</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用到类</span></span><br><span class="line">[<span class="meta">CodeInfo(<span class="string">"张三"</span>, <span class="string">"1.0.0"</span>, </span></span><br><span class="line"><span class="meta">          Description = <span class="string">"用户服务类"</span>, </span></span><br><span class="line"><span class="meta">          CreatedDate = <span class="string">"2024-01-15"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserService</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 应用到方法</span></span><br><span class="line">    [<span class="meta">CodeInfo(<span class="string">"李四"</span>, <span class="string">"1.0.0"</span>)</span>]</span><br><span class="line">    [<span class="meta">CodeInfo(<span class="string">"张三"</span>, <span class="string">"1.1.0"</span>, Description = <span class="string">"优化了查询逻辑"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">GetUserById</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="通过反射读取特性">通过反射读取特性</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">AttributeReader</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadAttributes</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取类上的特性</span></span><br><span class="line">        Type userServiceType = <span class="keyword">typeof</span>(UserService);</span><br><span class="line">        Console.WriteLine(<span class="string">"类上的特性 : "</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> classAttributes = userServiceType.GetCustomAttributes&lt;CodeInfoAttribute&gt;(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> classAttributes)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">$"作者: <span class="subst">{attr.Author}</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$"版本: <span class="subst">{attr.Version}</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$"描述: <span class="subst">{attr.Description}</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$"创建日期: <span class="subst">{attr.CreatedDate:yyyy-MM-dd}</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"---"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取方法上的特性</span></span><br><span class="line">        MethodInfo getUserMethod = userServiceType.GetMethod(<span class="string">"GetUserById"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"\n方法上的特性 : "</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> methodAttributes = getUserMethod.GetCustomAttributes&lt;CodeInfoAttribute&gt;(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> methodAttributes)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">$"作者: <span class="subst">{attr.Author}</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$"版本: <span class="subst">{attr.Version}</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"---"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="特性的高级应用">特性的高级应用</h2>
<h3 id="带参数的特性">带参数的特性</h3>
<p>特性可以包含复杂的参数，但只能使用常量值、typeof 表达式或数组 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SupportedPlatformsAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] Platforms { <span class="keyword">get</span>; }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SupportedPlatformsAttribute</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] platforms</span>)</span></span><br><span class="line">    {</span><br><span class="line">        Platforms = platforms;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line">[<span class="meta">SupportedPlatforms(<span class="string">"Windows"</span>, <span class="string">"Linux"</span>, <span class="string">"macOS"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CrossPlatformService</span> { }</span><br></pre></td></tr></table></figure>
<h3 id="泛型特性-c-11">泛型特性 ( C# 11+ )</h3>
<p>C# 11 及以上版本支持泛型特性 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReturnTypeAttribute</span>&lt;<span class="title">T</span>&gt; : <span class="title">Attribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Type ReturnType =&gt; <span class="keyword">typeof</span>(T);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">ReturnType&lt;string&gt;</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetData</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="特性与-aop-面向切面编程">特性与 AOP ( 面向切面编程 )</h3>
<p>特性常与 AOP 结合，实现日志、缓存、事务等横切关注点 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义日志特性</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> LogParameters { <span class="keyword">get</span>; <span class="keyword">set</span>; } = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> LogResult { <span class="keyword">get</span>; <span class="keyword">set</span>; } = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特性标记需要日志的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">Log(LogParameters = true, LogResult = true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateOrder</span>(<span class="params">Order order</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 订单创建逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 AOP 框架 ( 如 PostSharp、Castle DynamicProxy ) 拦截并实现日志功能</span></span><br></pre></td></tr></table></figure>
<h2 id="特性在框架中的应用">特性在框架中的应用</h2>
<h3 id="asp.net-core-中的特性">ASP.NET Core 中的特性</h3>
<p>ASP.NET Core 大量使用特性进行配置 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">"api/[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">"{id}"</span>)</span>]</span><br><span class="line">    [<span class="meta">ProducesResponseType(StatusCodes.Status200OK)</span>]</span><br><span class="line">    [<span class="meta">ProducesResponseType(StatusCodes.Status404NotFound)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;User&gt; <span class="title">GetUser</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">Authorize(Roles = <span class="string">"Admin"</span>)</span>]</span><br><span class="line">    [<span class="meta">ValidateAntiForgeryToken</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">CreateUser</span>(<span class="params">[FromBody] User user</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="序列化中的特性">序列化中的特性</h3>
<p>Newtonsoft.Json 等序列化库使用特性控制序列化行为 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">JsonProperty(<span class="string">"product_id"</span>)</span>] <span class="comment">// 序列化时的字段名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">JsonProperty</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">JsonIgnore</span>] <span class="comment">// 序列化时忽略该属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">JsonConverter(typeof(StringEnumConverter))</span>] <span class="comment">// 指定枚举的序列化方式</span></span><br><span class="line">    <span class="keyword">public</span> ProductStatus Status { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="特性的优缺点">特性的优缺点</h2>
<h3 id="优点-1">优点</h3>
<ol type="1">
<li><strong>声明式编程</strong> : 使代码更简洁，意图更明确</li>
<li><strong>元数据分离</strong> : 将元数据与业务逻辑分离</li>
<li><strong>灵活性高</strong> :
可以在不修改代码逻辑的情况下扩展功能</li>
<li><strong>框架友好</strong> : 是许多框架 ( 如 ASP.NET、ORM )
的基础</li>
</ol>
<h3 id="缺点-1">缺点</h3>
<ol type="1">
<li><strong>性能开销</strong> : 通过反射读取特性会有性能损耗</li>
<li><strong>编译时验证有限</strong> :
大部分特性逻辑在运行时才会验证</li>
<li><strong>调试困难</strong> : 特性相关逻辑不易调试</li>
<li><strong>过度使用会导致代码混乱</strong></li>
</ol>
<h2 id="最佳实践">最佳实践</h2>
<ol type="1">
<li><strong>明确适用范围</strong> : 使用 <code>AttributeUsage</code>
严格限制特性的应用目标</li>
<li><strong>命名规范</strong> : 遵循 <code>*Attribute</code>
命名约定</li>
<li><strong>提供清晰文档</strong> : 说明特性的用途和参数含义</li>
<li><strong>避免复杂逻辑</strong> :
特性应仅存储元数据，不应包含复杂业务逻辑</li>
<li><strong>考虑性能</strong> : 高频操作中避免频繁反射读取特性</li>
<li><strong>缓存反射结果</strong> :
对于需要频繁访问的特性信息，缓存反射结果</li>
</ol>
<p>特性是 C#
中实现元编程的核心机制，掌握特性的使用可以极大提高代码的灵活性和可维护性，尤其是在开发框架或通用库时.
合理使用特性可以使代码更简洁、更具表达力.</p>
<h1 id="c-委托-delegate">C# 委托 ( Delegate )</h1>
<p>委托是 C# 中的核心概念，本质是
<strong>引用方法的类型安全指针</strong>，用于实现"方法作为参数传递""事件驱动"等场景，是后续学习事件
( Event ) 、Lambda 表达式、LINQ 的基础.</p>
<h2 id="委托的基本定义">委托的基本定义</h2>
<h3 id="本质与作用">本质与作用</h3>
<ul>
<li><strong>本质</strong> : 委托是一种
<strong>自定义类型</strong>，专门用来"包装"与它签名 ( 返回值、参数列表 )
匹配的方法.</li>
<li><strong>核心作用</strong> :
<ol type="1">
<li>实现"方法作为参数传递" ( 解耦调用者与被调用者 ) ；</li>
<li>实现多播 ( 一个委托关联多个方法，调用时依次执行 ) ；</li>
<li>作为事件的底层支撑 ( 事件本质是"受限制的委托" ) .</li>
</ol></li>
</ul>
<h3 id="语法规则">语法规则</h3>
<h4 id="声明委托">声明委托</h4>
<p>委托的声明需指定 <strong>返回值类型</strong> 和
<strong>参数列表</strong> ( 即"方法签名" ) ，语法格式 :
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 : delegate 返回值类型 委托名(参数列表);</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CalculateDelegate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>; <span class="comment">// 声明一个"接收两个int、返回int"的委托</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>关键字 : <code>delegate</code>；</li>
<li>委托名 : 遵循 Pascal 命名法 ( 首字母大写 ) ；</li>
<li>签名要求 :
后续关联的方法，必须与委托的"返回值、参数数量、参数类型"完全匹配.</li>
</ul>
<h4 id="关联方法-实例化委托">关联方法 ( 实例化委托 )</h4>
<p>委托实例化时，需传入与签名匹配的方法 ( 支持 <strong>静态方法</strong>
和 <strong>实例方法</strong> ) : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MathHelper</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 静态方法 ( 无需实例化类 ) </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例方法 ( 需先创建类实例 ) </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a - b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化委托并关联方法</span></span><br><span class="line">CalculateDelegate calc1 = MathHelper.Add; <span class="comment">// 关联静态方法</span></span><br><span class="line">MathHelper helper = <span class="keyword">new</span> MathHelper();</span><br><span class="line">CalculateDelegate calc2 = helper.Subtract; <span class="comment">// 关联实例方法</span></span><br></pre></td></tr></table></figure></p>
<h4 id="调用委托">调用委托</h4>
<p>委托调用方式与普通方法一致，直接传入参数即可 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用委托 ( 本质是调用关联的方法 ) </span></span><br><span class="line"><span class="built_in">int</span> sum = calc1(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 等价于 MathHelper.Add(10,5)，结果 : 15</span></span><br><span class="line"><span class="built_in">int</span> diff = calc2(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 等价于 helper.Subtract(10,5)，结果 : 5</span></span><br></pre></td></tr></table></figure> -
若委托未关联任何方法 ( <code>null</code> ) ，直接调用会抛出
<code>NullReferenceException</code>，建议调用前判断 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (calc1 != <span class="literal">null</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> result = calc1(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 简化写法 ( C# 6.0+ 空条件运算符 ) </span></span><br><span class="line"><span class="built_in">int</span> result = calc1?.Invoke(<span class="number">10</span>, <span class="number">5</span>) ?? <span class="number">0</span>; <span class="comment">// 若calc1为null，返回0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="委托的核心特性">委托的核心特性</h2>
<h3 id="多播委托-multicast-delegate">多播委托 ( Multicast Delegate
)</h3>
<p>一个委托可以关联 <strong>多个方法</strong> ( 需与委托签名匹配 )
，调用时会按"关联顺序"依次执行所有方法.</p>
<h4 id="添加移除方法">添加/移除方法</h4>
<ul>
<li>添加方法 : <code>+=</code>；</li>
<li>移除方法 : <code>-=</code> ( 需确保方法已关联，否则无效果 ) .</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义多个匹配签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowResult</span>(<span class="params"><span class="built_in">int</span> result</span>)</span> =&gt; Console.WriteLine(<span class="string">$"结果 : <span class="subst">{result}</span>"</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多播委托 : 关联多个方法</span></span><br><span class="line">CalculateDelegate multiCalc = MathHelper.Add; <span class="comment">// 初始关联Add</span></span><br><span class="line">multiCalc += Multiply; <span class="comment">// 新增关联Multiply</span></span><br><span class="line">multiCalc += (x, y) =&gt; x / y; <span class="comment">// 新增关联Lambda表达式 ( 后续讲解 ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用多播委托 : 依次执行Add、Multiply、Lambda，返回最后一个方法的结果</span></span><br><span class="line"><span class="built_in">int</span> finalResult = multiCalc(<span class="number">10</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 执行过程 : Add(10,5)=15 → Multiply(10,5)=50 → 10/5=2 → 最终返回2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除方法</span></span><br><span class="line">multiCalc -= MathHelper.Add; <span class="comment">// 移除Add方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong> :
多播委托中若有方法抛出异常，后续方法会终止执行，需自行处理异常.</li>
</ul>
<h3 id="委托与方法的签名匹配">委托与方法的签名匹配</h3>
<p>委托严格要求"关联的方法签名与委托一致"，以下情况会编译报错 :
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误1 : 返回值不匹配 ( 委托返回int，方法返回void ) </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvalidMethod1</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; Console.WriteLine(a + b);</span><br><span class="line">CalculateDelegate calc = InvalidMethod1; <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误2 : 参数数量不匹配 ( 委托需2个参数，方法仅1个 ) </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">InvalidMethod2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span> =&gt; a * <span class="number">2</span>;</span><br><span class="line">CalculateDelegate calc = InvalidMethod2; <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误3 : 参数类型不匹配 ( 委托参数为int，方法为string ) </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">InvalidMethod3</span>(<span class="params"><span class="built_in">string</span> a, <span class="built_in">string</span> b</span>)</span> =&gt; a.Length + b.Length;</span><br><span class="line">CalculateDelegate calc = InvalidMethod3; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></p>
<h2 id="系统内置委托-无需自定义">系统内置委托 ( 无需自定义 )</h2>
<p>C# 提供了 3
个通用内置委托，覆盖绝大多数场景，<strong>无需手动声明委托</strong>，直接使用即可
:</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 32%">
<col style="width: 29%">
<col style="width: 22%">
</colgroup>
<thead>
<tr>
<th>委托类型</th>
<th>用途</th>
<th>签名 ( 返回值+参数 )</th>
<th>示例场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Action</td>
<td>无返回值的方法</td>
<td>void Action(参数列表)</td>
<td>执行一段逻辑 ( 如打印、修改值 )</td>
</tr>
<tr>
<td>Func<tresult></tresult></td>
<td>有返回值的方法</td>
<td>TResult Func(参数列表, TResult)</td>
<td>计算并返回结果 ( 如求和、排序 )</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>返回 bool 的方法 ( 用于"判断" )</td>
<td>bool Predicate<t>(T obj)</t></td>
<td>筛选数据 ( 如判断数字是否为偶数 )</td>
</tr>
</tbody>
</table>
<h3 id="action-委托">Action 委托</h3>
<ul>
<li>无返回值 ( <code>void</code> ) ，支持 0~16 个参数 ( 如
<code>Action</code>、<code>Action&lt;int&gt;</code>、<code>Action&lt;int, string&gt;</code>
) .</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1 : 无参数的Action</span></span><br><span class="line">Action printHello = () =&gt; Console.WriteLine(<span class="string">"Hello Action"</span>);</span><br><span class="line">printHello(); <span class="comment">// 输出 : Hello Action</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2 : 带2个参数的Action</span></span><br><span class="line">Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; printInfo = (name, age) =&gt; Console.WriteLine(<span class="string">$"姓名 : <span class="subst">{name}</span>，年龄 : <span class="subst">{age}</span>"</span>);</span><br><span class="line">printInfo(<span class="string">"Tom"</span>, <span class="number">20</span>); <span class="comment">// 输出 : 姓名 : Tom，年龄 : 20</span></span><br></pre></td></tr></table></figure>
<h3 id="func-委托">Func 委托</h3>
<ul>
<li>有返回值 ( <code>TResult</code> ) ，支持 0~16
个输入参数，<strong>最后一个泛型参数是返回值类型</strong> ( 如
<code>Func&lt;int&gt;</code>、<code>Func&lt;int, int&gt;</code>、<code>Func&lt;int, string, bool&gt;</code>
) .</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1 : 无输入参数，返回string</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; getTime = () =&gt; DateTime.Now.ToString(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">Console.WriteLine(getTime()); <span class="comment">// 输出当前时间 ( 如 : 14:30:25 ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2 : 2个int输入，返回int ( 求和 ) </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; sumFunc = (a, b) =&gt; a + b;</span><br><span class="line"><span class="built_in">int</span> result = sumFunc(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 结果 : 15</span></span><br></pre></td></tr></table></figure>
<h3 id="predicate-委托">Predicate 委托</h3>
<ul>
<li>专门用于"判断逻辑"，输入 1 个参数，返回 <code>bool</code>，等价于
<code>Func&lt;T, bool&gt;</code>.</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 : 判断数字是否为偶数</span></span><br><span class="line">Predicate&lt;<span class="built_in">int</span>&gt; isEven = num =&gt; num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> res1 = isEven(<span class="number">4</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> res2 = isEven(<span class="number">5</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合列表筛选 ( 筛选偶数 ) </span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; nums = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; evenNums = nums.FindAll(isEven); <span class="comment">// 结果 : [2,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="委托的典型应用场景">委托的典型应用场景</h2>
<h3 id="方法作为参数传递-解耦">方法作为参数传递 ( 解耦 )</h3>
<p>场景 : 定义一个"通用计算方法"，允许外部传入不同的计算逻辑 (
如加、减、乘 ) . <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用方法 : 接收"计算逻辑委托"作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; calcLogic</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> calcLogic(a, b); <span class="comment">// 调用外部传入的逻辑</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时传入不同逻辑 ( 无需修改Calculate方法 ) </span></span><br><span class="line"><span class="built_in">int</span> sum = Calculate(<span class="number">10</span>, <span class="number">5</span>, (x, y) =&gt; x + y); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">int</span> product = Calculate(<span class="number">10</span>, <span class="number">5</span>, (x, y) =&gt; x * y); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">int</span> diff = Calculate(<span class="number">10</span>, <span class="number">5</span>, (x, y) =&gt; x - y); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>优势 : <code>Calculate</code> 方法与具体计算逻辑解耦，后续新增逻辑 (
如取余 ) 无需修改原有代码.</li>
</ul>
<h3 id="事件驱动编程-基础">事件驱动编程 ( 基础 )</h3>
<p>委托是事件的底层支撑，例如按钮点击事件 ( <code>Click</code> )
本质是通过委托关联"点击后的处理方法". <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的按钮类 ( 模拟系统Button ) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyButton</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 声明事件 ( 本质是"受限制的Action委托" ) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action OnClick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟按钮被点击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Click</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 触发事件 ( 调用所有关联的方法 ) </span></span><br><span class="line">        OnClick?.Invoke();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用按钮 : 关联点击事件</span></span><br><span class="line">MyButton btn = <span class="keyword">new</span> MyButton();</span><br><span class="line">btn.OnClick += () =&gt; Console.WriteLine(<span class="string">"按钮被点击了！"</span>); <span class="comment">// 关联处理逻辑</span></span><br><span class="line">btn.Click(); <span class="comment">// 模拟点击，输出 : 按钮被点击了！</span></span><br></pre></td></tr></table></figure></p>
<h3 id="异步回调-简化版">异步回调 ( 简化版 )</h3>
<p>场景 : 异步操作完成后，通过委托调用"回调方法"通知结果 (
如文件读取完成后处理数据 ) . <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步读取文件 ( 完成后调用回调委托 ) </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ReadFileAsync</span>(<span class="params"><span class="built_in">string</span> path, Action&lt;<span class="built_in">string</span>&gt; callback</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 异步读取文件 ( 模拟耗时操作 ) </span></span><br><span class="line">    <span class="built_in">string</span> content = <span class="keyword">await</span> File.ReadAllTextAsync(path);</span><br><span class="line">    <span class="comment">// 调用回调方法，传递结果</span></span><br><span class="line">    callback?.Invoke(content);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 : 指定回调逻辑</span></span><br><span class="line">ReadFileAsync(<span class="string">"test.txt"</span>, content =&gt; </span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"文件内容长度 : <span class="subst">{content.Length}</span>"</span>);</span><br><span class="line">});</span><br></pre></td></tr></table></figure></p>
<h2 id="委托与-lambda-表达式的关系">委托与 Lambda 表达式的关系</h2>
<p>Lambda
表达式是"匿名方法"的简写，可直接作为参数传递给委托，避免定义单独的方法，简化代码
: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 传统方式 : 定义单独方法关联委托</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b;</span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; calc1 = Add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Lambda 方式 : 直接写匿名方法，无需单独定义</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; calc2 = (a, b) =&gt; a + b; <span class="comment">// 等价于上面的Add方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复杂逻辑的Lambda ( 多行 ) </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; calc3 = (a, b) =&gt; </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b - a;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<ul>
<li>本质 : Lambda
表达式会被编译器转换为"匿名方法"，最终与委托签名匹配.</li>
</ul>
<h2 id="常见问题与注意事项">常见问题与注意事项</h2>
<ol type="1">
<li><strong>委托为 null 时调用</strong> : 必须判断委托是否为
<code>null</code>，否则抛出 <code>NullReferenceException</code>，推荐用
<code>?.Invoke()</code> 简化.</li>
<li><strong>多播委托的返回值</strong> : 多播委托调用时，仅返回
<strong>最后一个方法</strong> 的结果，前面方法的返回值会被忽略 (
若需获取所有结果，需手动遍历委托的 <code>GetInvocationList()</code> )
.</li>
<li><strong>委托与接口的区别</strong> :
委托侧重"方法引用"，适合传递单一逻辑；接口侧重"多方法契约"，适合定义类的行为规范.</li>
<li><strong>避免过度使用委托</strong> : 简单场景 ( 如固定逻辑 )
无需用委托，否则会增加代码复杂度；优先使用系统内置委托 (
<code>Action</code>/<code>Func</code> ) ，避免重复声明自定义委托.</li>
</ol>
<h2 id="总结">总结</h2>
<ul>
<li>委托是"类型安全的方法指针"，核心是实现"方法作为参数传递"；</li>
<li>优先使用系统内置的
<code>Action</code>/<code>Func</code>/<code>Predicate</code>，减少自定义委托；</li>
<li>多播委托支持关联多个方法，但需注意异常处理和返回值问题；</li>
<li>Lambda 表达式是委托的"简化语法糖"，大幅提升代码简洁性；</li>
<li>委托是事件、异步编程的基础，掌握委托是深入 C# 高级特性的关键.</li>
</ul>
<h1 id="c-事件-event">C# 事件 ( Event )</h1>
<p>事件是 C# 中基于委托的核心机制，用于实现
<strong>发布-订阅模式</strong>，是 GUI 编程、异步通信等场景的基础.
事件本质是"受限制的委托"，提供了更安全的封装.</p>
<h2 id="事件的基本概念">事件的基本概念</h2>
<h3 id="本质与作用-1">本质与作用</h3>
<ul>
<li><strong>本质</strong> : 事件是
<strong>特殊的委托实例</strong>，但添加了访问限制 ( 仅允许在
<strong>声明它的类内部</strong> 触发，外部只能订阅/取消订阅 ).</li>
<li><strong>核心作用</strong> :
<ul>
<li>实现对象间的 <strong>松耦合通信</strong> (
发布者通知订阅者，双方无需知道彼此细节 )；</li>
<li>确保委托调用的安全性 ( 防止外部随意修改或触发 )；</li>
<li>是 GUI 控件 ( 如按钮点击 ) 、消息系统的底层实现方式.</li>
</ul></li>
</ul>
<h3 id="与委托的关系">与委托的关系</h3>
<ul>
<li>事件 <strong>依赖委托</strong> :
必须基于某个委托类型声明，事件的本质是该委托的一个实例.</li>
<li>事件是 <strong>委托的安全包装</strong> :
<ul>
<li>外部代码只能通过 <code>+=</code>/<code>-=</code>
订阅/取消订阅事件；</li>
<li>只有声明事件的类内部才能触发事件 ( 调用委托 ) ；</li>
<li>避免了直接使用委托时可能被外部恶意修改的风险.</li>
</ul></li>
</ul>
<h2 id="事件的声明与使用">事件的声明与使用</h2>
<h3 id="声明事件的标准步骤">声明事件的标准步骤</h3>
<h4 id="定义事件参数类-可选用于传递数据">定义事件参数类 (
可选，用于传递数据 )</h4>
<p>通常继承自 <code>EventArgs</code> ( .NET 约定 )
，用于在事件触发时传递额外数据 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件参数类 : 存储事件相关数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TemperatureChangedEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> OldTemperature { <span class="keyword">get</span>; }</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> NewTemperature { <span class="keyword">get</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TemperatureChangedEventArgs</span>(<span class="params"><span class="built_in">float</span> oldTemp, <span class="built_in">float</span> newTemp</span>)</span></span><br><span class="line">    {</span><br><span class="line">        OldTemperature = oldTemp;</span><br><span class="line">        NewTemperature = newTemp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="定义委托类型-或使用内置委托">定义委托类型 ( 或使用内置委托
)</h4>
<p>事件需要基于委托类型声明，推荐遵循 .NET 标准签名 :
<code>void 委托名(object sender, 事件参数类型 e)</code>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义委托 ( 遵循标准签名 ) </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TemperatureChangedEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, TemperatureChangedEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或直接使用内置的泛型委托 EventHandler&lt;T&gt; ( 推荐，无需自定义委托 ) </span></span><br><span class="line"><span class="comment">// EventHandler&lt;T&gt; 等价于 : delegate void EventHandler&lt;T&gt;(object sender, T e) where T : EventArgs</span></span><br></pre></td></tr></table></figure></p>
<h4 id="在发布者类中声明事件">在发布者类中声明事件</h4>
<p>使用 <code>event</code> 关键字，基于委托类型声明事件 :
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Thermometer</span> <span class="comment">// 温度传感器 ( 发布者 ) </span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _currentTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明事件 ( 基于自定义委托 ) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> TemperatureChangedEventHandler TemperatureChanged;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或使用内置 EventHandler&lt;T&gt; ( 更简洁，推荐 ) </span></span><br><span class="line">    <span class="comment">// public event EventHandler&lt;TemperatureChangedEventArgs&gt; TemperatureChanged;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> CurrentTemp</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span> =&gt; _currentTemp;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (_currentTemp != <span class="keyword">value</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">float</span> oldTemp = _currentTemp;</span><br><span class="line">                _currentTemp = <span class="keyword">value</span>;</span><br><span class="line">                <span class="comment">// 温度变化时触发事件</span></span><br><span class="line">                OnTemperatureChanged(oldTemp, <span class="keyword">value</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件的保护方法 ( .NET 约定命名 : On+事件名 ) </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTemperatureChanged</span>(<span class="params"><span class="built_in">float</span> oldTemp, <span class="built_in">float</span> newTemp</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 触发事件 ( 调用所有订阅的方法 ) </span></span><br><span class="line">        <span class="comment">// 使用 ?.Invoke() 避免空引用异常 ( 无订阅者时 ) </span></span><br><span class="line">        TemperatureChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> TemperatureChangedEventArgs(oldTemp, newTemp));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="订阅者订阅事件并处理">订阅者订阅事件并处理</h4>
<p>订阅者通过 <code>+=</code>
注册事件处理方法，方法签名需与事件的委托匹配 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AirConditioner</span> <span class="comment">// 空调 ( 订阅者 ) </span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTemperatureChanged</span>(<span class="params"><span class="built_in">object</span> sender, TemperatureChangedEventArgs e</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (e.NewTemperature &gt; <span class="number">26</span>)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">$"空调 : 温度过高 ( <span class="subst">{e.NewTemperature}</span>°C ) ，启动制冷！"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e.NewTemperature &lt; <span class="number">18</span>)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">$"空调 : 温度过低 ( <span class="subst">{e.NewTemperature}</span>°C ) ，启动制热！"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Logger</span> <span class="comment">// 日志记录器 ( 另一个订阅者 ) </span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogTemperatureChange</span>(<span class="params"><span class="built_in">object</span> sender, TemperatureChangedEventArgs e</span>)</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">$"日志 : 温度从 <span class="subst">{e.OldTemperature}</span>°C 变为 <span class="subst">{e.NewTemperature}</span>°C"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="使用事件机制">使用事件机制</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建发布者和订阅者</span></span><br><span class="line">        Thermometer thermometer = <span class="keyword">new</span> Thermometer();</span><br><span class="line">        AirConditioner ac = <span class="keyword">new</span> AirConditioner();</span><br><span class="line">        Logger logger = <span class="keyword">new</span> Logger();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅事件 ( 注册处理方法 ) </span></span><br><span class="line">        thermometer.TemperatureChanged += ac.OnTemperatureChanged;</span><br><span class="line">        thermometer.TemperatureChanged += logger.LogTemperatureChange;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变温度 ( 会触发事件 ) </span></span><br><span class="line">        thermometer.CurrentTemp = <span class="number">28</span>; </span><br><span class="line">        <span class="comment">// 输出 : </span></span><br><span class="line">        <span class="comment">// 空调 : 温度过高 ( 28°C ) ，启动制冷！</span></span><br><span class="line">        <span class="comment">// 日志 : 温度从 0°C 变为 28°C</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅 ( 移除处理方法 ) </span></span><br><span class="line">        thermometer.TemperatureChanged -= ac.OnTemperatureChanged;</span><br><span class="line">        thermometer.CurrentTemp = <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 输出 : </span></span><br><span class="line">        <span class="comment">// 日志 : 温度从 28°C 变为 16°C ( 空调已取消订阅，不再响应 ) </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="事件的核心语法规则">事件的核心语法规则</h3>
<ul>
<li><strong>声明方式</strong> :
<code>public event 委托类型 事件名;</code></li>
<li><strong>订阅</strong> :
<code>发布者.事件名 += 订阅者.处理方法;</code></li>
<li><strong>取消订阅</strong> :
<code>发布者.事件名 -= 订阅者.处理方法;</code></li>
<li><strong>触发事件</strong> : 仅能在声明事件的类内部通过
<code>事件名?.Invoke(参数)</code> 触发</li>
<li><strong>处理方法签名</strong> : 必须与事件的委托类型匹配 ( 返回值
<code>void</code>，参数 <code>object sender, 事件参数 e</code> )</li>
</ul>
<h2 id="net-事件约定与最佳实践">.NET 事件约定与最佳实践</h2>
<h3 id="命名规范">命名规范</h3>
<ul>
<li>事件名 : 使用 <strong>过去分词</strong> ( 如
<code>Clicked</code>、<code>TemperatureChanged</code> ) ；</li>
<li>事件参数类 : <code>事件名 + EventArgs</code> ( 如
<code>TemperatureChangedEventArgs</code> ) ；</li>
<li>触发事件的方法 : <code>protected virtual void On + 事件名</code> (
如 <code>OnTemperatureChanged</code> ) ，供子类重写.</li>
</ul>
<h3 id="推荐使用内置委托">推荐使用内置委托</h3>
<ul>
<li>无参数事件 : 使用 <code>EventHandler</code> ( 签名 :
<code>void (object sender, EventArgs e)</code> ) ；</li>
<li>带参数事件 : 使用 <code>EventHandler&lt;T&gt;</code> (
泛型，<code>T</code> 为继承 <code>EventArgs</code> 的参数类 ) ；</li>
<li>避免自定义委托，减少代码冗余.</li>
</ul>
<h3 id="线程安全考量">线程安全考量</h3>
<ul>
<li>触发事件前，建议先将事件引用赋值给临时变量，防止多线程环境下订阅者突然取消订阅导致的
<code>NullReferenceException</code> :</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTemperatureChanged</span>(<span class="params">...</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 临时变量存储事件引用</span></span><br><span class="line">    <span class="keyword">var</span> handler = TemperatureChanged;</span><br><span class="line">    <span class="comment">// 调用临时变量 ( 避免多线程问题 ) </span></span><br><span class="line">    handler?.Invoke(<span class="keyword">this</span>, ...);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="避免过度使用静态事件">避免过度使用静态事件</h3>
<ul>
<li>静态事件的生命周期与应用程序一致，容易导致<strong>内存泄漏</strong>
( 订阅者对象被静态事件引用而无法回收 )；</li>
<li>非必要场景优先使用实例事件.</li>
</ul>
<h2 id="事件与委托的关键区别">事件与委托的关键区别</h2>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr>
<th>特性</th>
<th>委托 ( Delegate )</th>
<th>事件 ( Event )</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>引用方法的类型安全指针</td>
<td>受限制的委托实例 ( 安全包装 )</td>
</tr>
<tr>
<td>外部访问权限</td>
<td>可直接调用、赋值、修改 (
<code>=</code>/<code>+=</code>/<code>-=</code> )</td>
<td>仅允许 <code>+=</code> ( 订阅 ) 和 <code>-=</code> ( 取消订阅 )</td>
</tr>
<tr>
<td>触发权限</td>
<td>任何地方都可调用 ( 只要能访问委托实例 )</td>
<td>仅声明事件的类内部可触发 ( 调用 <code>Invoke</code> )</td>
</tr>
<tr>
<td>使用场景</td>
<td>方法作为参数传递、多播方法调用</td>
<td>发布-订阅模式、事件通知 ( 如按钮点击 )</td>
</tr>
<tr>
<td>安全性</td>
<td>较低 ( 可能被外部恶意修改或调用 )</td>
<td>较高 ( 严格限制外部操作 )</td>
</tr>
</tbody>
</table>
<h2 id="典型应用场景">典型应用场景</h2>
<h3 id="gui-控件事件">GUI 控件事件</h3>
<p>如按钮点击、文本框内容变化等 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟按钮点击事件</span></span><br><span class="line">Button btn = <span class="keyword">new</span> Button();</span><br><span class="line">btn.Click += (sender, e) =&gt; Console.WriteLine(<span class="string">"按钮被点击了！"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="状态变化通知">状态变化通知</h3>
<p>如温度、库存等状态变化时通知相关组件 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库存管理系统中，库存不足时通知采购模块</span></span><br><span class="line">inventory.StockLow += purchaseModule.OrderMore;</span><br></pre></td></tr></table></figure></p>
<h3 id="异步操作完成通知">异步操作完成通知</h3>
<p>如文件下载完成后触发处理逻辑 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">downloader.DownloadCompleted += (sender, e) =&gt; </span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"文件下载完成，保存路径 : <span class="subst">{e.FilePath}</span>"</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h2 id="常见问题与注意事项-1">常见问题与注意事项</h2>
<ol type="1">
<li><strong>事件未订阅时触发</strong> : 必须使用 <code>?.Invoke()</code>
或 null 判断，否则会抛出 <code>NullReferenceException</code>.</li>
<li><strong>处理方法未正确移除</strong> :
若订阅者对象已销毁但未取消订阅，会导致内存泄漏 ( 事件仍持有对象引用
).</li>
<li><strong>事件参数类未继承 EventArgs</strong> : 虽然允许，但不符合
.NET 约定，可能降低代码可读性.</li>
<li><strong>滥用事件导致性能问题</strong> :
过多订阅者会增加事件触发的耗时，需合理设计订阅关系.</li>
</ol>
<h2 id="总结-1">总结</h2>
<ul>
<li>事件是"受保护的委托"，核心用于实现发布-订阅模式；</li>
<li>遵循 .NET 事件约定 ( 命名规范、<code>EventArgs</code>
继承、<code>OnEventName</code> 触发方法 )；</li>
<li>优先使用内置 <code>EventHandler</code> 和
<code>EventHandler&lt;T&gt;</code> 委托，减少自定义委托；</li>
<li>事件确保了委托调用的安全性，是松耦合系统设计的关键机制；</li>
<li>掌握事件是理解 C# GUI 编程、异步编程的基础.</li>
</ul>
<h1 id="c-lambda-表达式">C# Lambda 表达式</h1>
<p>Lambda 表达式是 C# 3.0
引入的重要特性，本质是一种简洁的匿名函数表示方式，允许将代码块作为参数传递，极大简化了委托和事件的使用，是
LINQ、异步编程等现代 C# 开发的基础.</p>
<h2 id="核心概念与语法结构">核心概念与语法结构</h2>
<p>Lambda 表达式的核心是将方法作为数据传递，其基本语法结构为 :
<code>(参数列表) =&gt; 表达式或语句块</code></p>
<p>其中 <code>=&gt;</code> 称为 Lambda 运算符，读作"goes
to"，左侧是输入参数，右侧是要执行的代码.
根据参数数量和代码复杂度，Lambda 表达式有多种形式 :</p>
<h3 id="无参数-lambda">无参数 Lambda</h3>
<p>当不需要输入参数时，使用空括号表示 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数，返回字符串</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; getWelcomeMessage = () =&gt; <span class="string">"Welcome to Lambda expressions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数，多行语句块 ( 需用{}包裹，显式return ) </span></span><br><span class="line">Action printCurrentDate = () =&gt; </span><br><span class="line">{</span><br><span class="line">    DateTime now = DateTime.Now;</span><br><span class="line">    Console.WriteLine(<span class="string">$"Current date: <span class="subst">{now:yyyy-MM-dd}</span>"</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="单参数-lambda">单参数 Lambda</h3>
<p>单个参数时可省略括号，编译器会自动推断参数类型 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单参数，省略括号</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; calculateSquare = x =&gt; x * x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式指定参数类型 ( 可选 ) </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; isPositive = (<span class="built_in">int</span> num) =&gt; num &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单参数，多行语句块</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; getWordCount = text =&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(text))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> text.Split(<span class="keyword">new</span>[] { <span class="string">' '</span> }, StringSplitOptions.RemoveEmptyEntries).Length;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h3 id="多参数-lambda">多参数 Lambda</h3>
<p>多个参数需用逗号分隔，放在括号中 : <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数，自动类型推断</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; addNumbers = (a, b) =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数，显式类型</span></span><br><span class="line">Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">int</span>, <span class="built_in">double</span>&gt; calculateTotal = (<span class="built_in">double</span> price, <span class="built_in">double</span> tax, <span class="built_in">int</span> quantity) =&gt;</span><br><span class="line">    (price * (<span class="number">1</span> + tax)) * quantity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数，复杂逻辑</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">string</span>&gt; compareNumbers = (x, y) =&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">{x}</span> is greater than <span class="subst">{y}</span>"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">{x}</span> is less than <span class="subst">{y}</span>"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">{x}</span> equals <span class="subst">{y}</span>"</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<h2 id="类型推断机制">类型推断机制</h2>
<p>Lambda
表达式的强大之处在于编译器的类型推断能力，它能根据上下文自动确定参数类型和返回类型
:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文 : List&lt;int&gt;的Where方法需要Func&lt;int, bool&gt;参数</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译器推断n是int类型，表达式返回bool类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文 : 委托类型显式指定</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; stringLength = s =&gt; s.Length;</span><br><span class="line"><span class="comment">// 编译器知道需要string参数和int返回值，因此s被推断为string</span></span><br></pre></td></tr></table></figure>
<p>类型推断的限制 :</p>
<ul>
<li>当 Lambda 表达式单独存在 ( 未赋值给委托或作为方法参数 )
时，无法推断类型</li>
<li>复杂场景下可能需要显式指定参数类型以避免歧义</li>
</ul>
<h2 id="与委托的关系-1">与委托的关系</h2>
<p>Lambda
表达式最常见的用途是作为委托的实现，任何委托类型都可以接受匹配签名的
Lambda 表达式 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">bool</span> <span class="title">NumberFilter</span>(<span class="params"><span class="built_in">int</span> num</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式实例化委托</span></span><br><span class="line">NumberFilter evenFilter = n =&gt; n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为方法参数传递</span></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="built_in">int</span> number, NumberFilter filter</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> filter(number);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时使用Lambda</span></span><br><span class="line"><span class="built_in">bool</span> result = IsValid(<span class="number">7</span>, n =&gt; n &gt; <span class="number">5</span>); <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure>
<p>C# 提供的内置委托类型特别适合与 Lambda 配合使用 : -
<code>Action</code> : 无返回值的委托 - <code>Func&lt;TResult&gt;</code>
: 有返回值的委托 - <code>Predicate&lt;T&gt;</code> :
返回bool的判断委托</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Action委托</span></span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; printMessage = msg =&gt; Console.WriteLine(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Func委托</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; multiply = (x, y) =&gt; x * y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Predicate委托</span></span><br><span class="line">Predicate&lt;<span class="built_in">string</span>&gt; isLongText = s =&gt; s.Length &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="与匿名方法的对比">与匿名方法的对比</h2>
<p>Lambda 表达式是匿名方法的进化形式，两者都可以创建未命名的方法，但
Lambda 更加简洁 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名方法</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; squareAnon = <span class="built_in">delegate</span>(<span class="built_in">int</span> x) { <span class="keyword">return</span> x * x; };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效的Lambda表达式</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; squareLambda = x =&gt; x * x;</span><br></pre></td></tr></table></figure>
<p>主要区别 :</p>
<ul>
<li>Lambda 支持类型推断，匿名方法需要显式声明参数类型</li>
<li>Lambda 单表达式可省略return和大括号，匿名方法必须显式return</li>
<li>Lambda 可转换为表达式树，匿名方法不能</li>
<li>Lambda 语法更简洁，适合编写简短的函数逻辑</li>
</ul>
<h2 id="表达式树">表达式树</h2>
<p>Lambda 表达式可以被编译为两种形式 :</p>
<ol type="1">
<li>委托 : 可执行的代码</li>
<li>表达式树 : 代码的抽象语法树表示 ( Expression<tdelegate> )</tdelegate></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译为委托 ( 可直接执行 ) </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; squareDelegate = x =&gt; x * x;</span><br><span class="line"><span class="built_in">int</span> result = squareDelegate(<span class="number">5</span>); <span class="comment">// 执行得到25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为表达式树 ( 表示代码结构 ) </span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; squareExpression = x =&gt; x * x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析表达式树</span></span><br><span class="line">Console.WriteLine(squareExpression.Body); <span class="comment">// 输出 : (x * x)</span></span><br><span class="line"><span class="keyword">var</span> parameter = squareExpression.Parameters[<span class="number">0</span>];</span><br><span class="line">Console.WriteLine(<span class="string">$"Parameter name: <span class="subst">{parameter.Name}</span>, Type: <span class="subst">{parameter.Type}</span>"</span>);</span><br></pre></td></tr></table></figure>
<p>表达式树的应用场景 :</p>
<ul>
<li>LINQ to Entities : 将 Lambda 表达式转换为 SQL 语句</li>
<li>动态查询构建 : 在运行时创建查询逻辑</li>
<li>代码分析和生成 : 检查或动态生成代码</li>
</ul>
<h2 id="闭包特性">闭包特性</h2>
<p>Lambda 表达式可以捕获并访问其定义范围内的变量，这种特性称为闭包 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> multiplier = <span class="number">3</span>;</span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; multiplyBy = x =&gt; x * multiplier;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(multiplyBy(<span class="number">5</span>)); <span class="comment">// 输出15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部变量修改会影响Lambda的行为</span></span><br><span class="line">multiplier = <span class="number">4</span>;</span><br><span class="line">Console.WriteLine(multiplyBy(<span class="number">5</span>)); <span class="comment">// 输出20</span></span><br></pre></td></tr></table></figure>
<p>闭包注意事项 :</p>
<ul>
<li>捕获的是变量引用，而非变量的值</li>
<li>变量的生命周期会被延长至 Lambda 表达式的生命周期</li>
<li>多线程环境下使用闭包需注意线程安全</li>
<li>过度使用闭包可能导致意外行为和内存泄漏</li>
</ul>
<h2 id="在-linq-中的应用">在 LINQ 中的应用</h2>
<p>Lambda 表达式是 LINQ 方法语法的核心，几乎所有 LINQ 操作都依赖 Lambda
来定义查询逻辑 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employees = <span class="keyword">new</span> List&lt;Employee&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">new</span> Employee { Name = <span class="string">"Alice"</span>, Age = <span class="number">30</span>, Department = <span class="string">"IT"</span>, Salary = <span class="number">75000</span> },</span><br><span class="line">    <span class="keyword">new</span> Employee { Name = <span class="string">"Bob"</span>, Age = <span class="number">25</span>, Department = <span class="string">"HR"</span>, Salary = <span class="number">60000</span> },</span><br><span class="line">    <span class="keyword">new</span> Employee { Name = <span class="string">"Charlie"</span>, Age = <span class="number">35</span>, Department = <span class="string">"IT"</span>, Salary = <span class="number">90000</span> }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选IT部门且薪资高于80000的员工</span></span><br><span class="line"><span class="keyword">var</span> highEarnersInIT = employees</span><br><span class="line">    .Where(e =&gt; e.Department == <span class="string">"IT"</span> &amp;&amp; e.Salary &gt; <span class="number">80000</span>)</span><br><span class="line">    .OrderByDescending(e =&gt; e.Salary)</span><br><span class="line">    .Select(e =&gt; <span class="keyword">new</span> { e.Name, e.Salary });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按部门分组并计算平均薪资</span></span><br><span class="line"><span class="keyword">var</span> avgSalaryByDept = employees</span><br><span class="line">    .GroupBy(e =&gt; e.Department)</span><br><span class="line">    .Select(g =&gt; <span class="keyword">new</span> </span><br><span class="line">    { </span><br><span class="line">        Department = g.Key, </span><br><span class="line">        AverageSalary = g.Average(e =&gt; e.Salary) </span><br><span class="line">    });</span><br></pre></td></tr></table></figure>
<h2 id="在事件处理中的应用">在事件处理中的应用</h2>
<p>Lambda 表达式简化了事件处理程序的编写，无需单独定义方法 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessageService</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; MessageReceived;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        MessageReceived?.Invoke(message);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式订阅事件</span></span><br><span class="line"><span class="keyword">var</span> service = <span class="keyword">new</span> MessageService();</span><br><span class="line">service.MessageReceived += msg =&gt; </span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"New message: <span class="subst">{msg}</span>"</span>);</span><br><span class="line">    <span class="comment">// 可以包含复杂的处理逻辑</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息会触发事件处理</span></span><br><span class="line">service.SendMessage(<span class="string">"Hello via Lambda event handler!"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="异步-lambda">异步 Lambda</h2>
<p>结合 <code>async/await</code> 关键字，Lambda 表达式可以处理异步操作
:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步Lambda表达式</span></span><br><span class="line">Func&lt;Task&lt;<span class="built_in">string</span>&gt;&gt; fetchDataAsync = <span class="keyword">async</span> () =&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> client.GetStringAsync(<span class="string">"https://api.example.com/data"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为参数的异步Lambda</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">ProcessDataAsync</span>(<span class="params">Func&lt;Task&lt;<span class="built_in">string</span>&gt;&gt; dataProvider</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">string</span> data = <span class="keyword">await</span> dataProvider();</span><br><span class="line">        Console.WriteLine(<span class="string">$"Processed: <span class="subst">{data.Substring(<span class="number">0</span>, <span class="number">50</span>)}</span>..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">$"Error: <span class="subst">{ex.Message}</span>"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">await</span> ProcessDataAsync(<span class="keyword">async</span> () =&gt; </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">100</span>); <span class="comment">// 模拟延迟</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Sample data from async lambda"</span>;</span><br><span class="line">});</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践与注意事项">最佳实践与注意事项</h2>
<ol type="1">
<li><p><strong>保持简洁</strong> : Lambda
适合实现简短逻辑，复杂逻辑应使用命名方法以提高可读性</p></li>
<li><p><strong>参数命名</strong> : 使用有意义的参数名，避免单字母命名 (
除非上下文明确含义 )</p></li>
<li><p><strong>避免副作用</strong> : 尽量让 Lambda 表达式无副作用 (
不修改外部状态 ) ，使代码更可预测</p></li>
<li><p><strong>注意闭包生命周期</strong> : 避免在长时间运行的 Lambda
中捕获短期变量，防止内存泄漏</p></li>
<li><p><strong>类型推断平衡</strong> :
适当利用类型推断简化代码，但在复杂场景中可显式指定类型以提高可读性</p></li>
<li><p><strong>多播委托注意</strong> : 当 Lambda
用于多播委托时，返回值仅最后一个方法的返回值会被保留</p></li>
<li><p><strong>调试考量</strong> : 复杂的 Lambda
表达式难以调试，必要时可临时转换为命名方法</p></li>
</ol>
<h2 id="总结-2">总结</h2>
<p>Lambda 表达式是 C#
中编写简洁、灵活代码的强大工具，它使开发者能够将函数逻辑作为数据传递，极大简化了委托、事件和
LINQ 的使用. 通过理解 Lambda
的语法结构、类型推断、闭包特性以及与表达式树的关系，开发者可以更有效地利用这一特性编写现代、高效的
C# 代码.</p>
<p>无论是处理集合数据、响应事件、实现回调还是构建复杂查询，Lambda
表达式都提供了简洁而强大的语法支持，是每个 C#
开发者必须掌握的核心技能.</p>
<h1 id="c-linq">C# LINQ</h1>
<h2 id="什么是-linq">什么是 LINQ</h2>
<p>LINQ ( Language Integrated Query，语言集成查询 ) 是 C# 3.0
引入的重要特性，它将查询功能直接集成到 C#
语言中，提供了一种统一的方式来查询和操作各种数据源 ( 如集合、数据库、XML
等 ) 。</p>
<p>LINQ 的核心优势在于 :</p>
<ul>
<li>提供一致的查询语法，无论数据源类型如何</li>
<li>支持编译时类型检查，减少运行时错误</li>
<li>允许使用 C# 语言本身编写查询，无需学习不同的查询语言</li>
<li>支持 IntelliSense 智能提示，提高开发效率</li>
<li>可将查询逻辑与业务逻辑无缝集成</li>
</ul>
<h2 id="linq-的两种语法形式">LINQ 的两种语法形式</h2>
<h3 id="查询语法-query-syntax">查询语法 ( Query Syntax )</h3>
<p>基于类 SQL 语法，更接近自然语言，可读性强 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询语法示例</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> p <span class="keyword">in</span> products</span><br><span class="line">             <span class="keyword">where</span> p.Category == <span class="string">"Electronics"</span> &amp;&amp; p.Price &gt; <span class="number">100</span></span><br><span class="line">             <span class="keyword">orderby</span> p.Price <span class="keyword">ascending</span></span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> { p.Name, p.Price, p.Category };</span><br></pre></td></tr></table></figure>
<h3 id="方法语法-method-syntax">方法语法 ( Method Syntax )</h3>
<p>基于方法调用，使用 Lambda 表达式定义查询条件，更灵活 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法语法示例 ( 与上面查询语法等效 ) </span></span><br><span class="line"><span class="keyword">var</span> result = products</span><br><span class="line">    .Where(p =&gt; p.Category == <span class="string">"Electronics"</span> &amp;&amp; p.Price &gt; <span class="number">100</span>)</span><br><span class="line">    .OrderBy(p =&gt; p.Price)</span><br><span class="line">    .Select(p =&gt; <span class="keyword">new</span> { p.Name, p.Price, p.Category });</span><br></pre></td></tr></table></figure>
<p>两种语法可以混合使用，编译器会将查询语法转换为对应的方法语法 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混合语法示例</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> p <span class="keyword">in</span> products</span><br><span class="line">             <span class="keyword">where</span> p.Stock &gt; <span class="number">0</span></span><br><span class="line">             <span class="keyword">select</span> p <span class="keyword">into</span> inStockProducts</span><br><span class="line">             <span class="keyword">where</span> inStockProducts.Price &lt; <span class="number">50</span></span><br><span class="line">             <span class="keyword">orderby</span> inStockProducts.Name</span><br><span class="line">             <span class="keyword">select</span> inStockProducts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于混合使用方法语法</span></span><br><span class="line"><span class="keyword">var</span> result = products</span><br><span class="line">    .Where(p =&gt; p.Stock &gt; <span class="number">0</span>)</span><br><span class="line">    .Where(p =&gt; p.Price &lt; <span class="number">50</span>)</span><br><span class="line">    .OrderBy(p =&gt; p.Name);</span><br></pre></td></tr></table></figure>
<h2 id="linq-核心命名空间">LINQ 核心命名空间</h2>
<p>使用 LINQ 需引入以下命名空间 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;                <span class="comment">// 核心 LINQ 方法</span></span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;    <span class="comment">// 表达式树 ( 用于 IQueryable ) </span></span><br></pre></td></tr></table></figure>
<h2 id="linq-的类型">LINQ 的类型</h2>
<p>根据数据源类型，LINQ 主要分为以下几类 :</p>
<h3 id="linq-to-objects">LINQ to Objects</h3>
<p>用于查询内存中的集合 ( 实现 IEnumerable<t> 的类型 ) :</t></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = GetStudents();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有成绩大于 90 的学生</span></span><br><span class="line"><span class="keyword">var</span> topStudents = students.Where(s =&gt; s.Score &gt; <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按班级分组并计算平均成绩</span></span><br><span class="line"><span class="keyword">var</span> avgScoresByClass = students</span><br><span class="line">    .GroupBy(s =&gt; s.Class)</span><br><span class="line">    .Select(g =&gt; <span class="keyword">new</span> {</span><br><span class="line">        Class = g.Key,</span><br><span class="line">        AverageScore = g.Average(s =&gt; s.Score),</span><br><span class="line">        StudentCount = g.Count()</span><br><span class="line">    });</span><br></pre></td></tr></table></figure>
<h3 id="linq-to-entities">LINQ to Entities</h3>
<p>用于查询 Entity Framework 中的数据库 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> SchoolContext())</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 查询计算机系的所有学生</span></span><br><span class="line">    <span class="keyword">var</span> csStudents = context.Students</span><br><span class="line">        .Where(s =&gt; s.Department == <span class="string">"Computer Science"</span>)</span><br><span class="line">        .OrderBy(s =&gt; s.LastName)</span><br><span class="line">        .ThenBy(s =&gt; s.FirstName);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 统计每个系的学生数量</span></span><br><span class="line">    <span class="keyword">var</span> deptCounts = context.Students</span><br><span class="line">        .GroupBy(s =&gt; s.Department)</span><br><span class="line">        .Select(g =&gt; <span class="keyword">new</span> {</span><br><span class="line">            Department = g.Key,</span><br><span class="line">            Count = g.Count()</span><br><span class="line">        });</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="linq-to-sql">LINQ to SQL</h3>
<p>用于直接查询 SQL Server 数据库 ( 较旧技术，逐渐被 Entity Framework
取代 ) :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> db = <span class="keyword">new</span> NorthwindDataContext())</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> cheapProducts = <span class="keyword">from</span> p <span class="keyword">in</span> db.Products</span><br><span class="line">                        <span class="keyword">where</span> p.UnitPrice &lt; <span class="number">10</span></span><br><span class="line">                        <span class="keyword">select</span> p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="linq-to-xml">LINQ to XML</h3>
<p>用于查询和操作 XML 数据 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XElement root = XElement.Load(<span class="string">"books.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有价格低于 50 的书籍</span></span><br><span class="line"><span class="keyword">var</span> cheapBooks = <span class="keyword">from</span> book <span class="keyword">in</span> root.Elements(<span class="string">"book"</span>)</span><br><span class="line">                 <span class="keyword">where</span> (<span class="built_in">decimal</span>)book.Element(<span class="string">"price"</span>) &lt; <span class="number">50</span></span><br><span class="line">                 <span class="keyword">select</span> <span class="keyword">new</span> {</span><br><span class="line">                     Title = (<span class="built_in">string</span>)book.Element(<span class="string">"title"</span>),</span><br><span class="line">                     Price = (<span class="built_in">decimal</span>)book.Element(<span class="string">"price"</span>)</span><br><span class="line">                 };</span><br></pre></td></tr></table></figure>
<h2 id="常用-linq-操作符">常用 LINQ 操作符</h2>
<h3 id="筛选操作符">筛选操作符</h3>
<ul>
<li><strong>Where</strong> : 筛选满足条件的元素</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选价格大于 100 且库存大于 0 的产品</span></span><br><span class="line"><span class="keyword">var</span> expensiveInStock = products.Where(p =&gt; p.Price &gt; <span class="number">100</span> &amp;&amp; p.Stock &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="投影操作符">投影操作符</h3>
<ul>
<li><strong>Select</strong> : 将元素转换为新的形式</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只选择产品名称和价格，创建匿名类型</span></span><br><span class="line"><span class="keyword">var</span> productInfo = products.Select(p =&gt; <span class="keyword">new</span> { p.Name, p.Price });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套 Select ( 投影到复杂类型 ) </span></span><br><span class="line"><span class="keyword">var</span> orderDetails = orders.Select(o =&gt; <span class="keyword">new</span> {</span><br><span class="line">    OrderId = o.Id,</span><br><span class="line">    CustomerName = o.Customer.Name,</span><br><span class="line">    ProductNames = o.Items.Select(i =&gt; i.Product.Name)</span><br><span class="line">});</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SelectMany</strong> : 将序列的每个元素投影为 IEnumerable<t>
并平展结果</t></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有订单中的所有产品 ( 平展结果 ) </span></span><br><span class="line"><span class="keyword">var</span> allProductsInOrders = orders.SelectMany(o =&gt; o.Items.Select(i =&gt; i.Product));</span><br></pre></td></tr></table></figure>
<h3 id="排序操作符">排序操作符</h3>
<ul>
<li><strong>OrderBy</strong> : 按指定键升序排序</li>
<li><strong>OrderByDescending</strong> : 按指定键降序排序</li>
<li><strong>ThenBy</strong> : 二次排序 ( 升序 )</li>
<li><strong>ThenByDescending</strong> : 二次排序 ( 降序 )</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先按类别升序，再按价格降序排序</span></span><br><span class="line"><span class="keyword">var</span> sortedProducts = products</span><br><span class="line">    .OrderBy(p =&gt; p.Category)</span><br><span class="line">    .ThenByDescending(p =&gt; p.Price);</span><br></pre></td></tr></table></figure>
<h3 id="分组操作符">分组操作符</h3>
<ul>
<li><strong>GroupBy</strong> : 按指定键对元素分组</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按类别分组产品</span></span><br><span class="line"><span class="keyword">var</span> productsByCategory = products.GroupBy(p =&gt; p.Category);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分组并计算每组的统计信息</span></span><br><span class="line"><span class="keyword">var</span> categoryStats = products</span><br><span class="line">    .GroupBy(p =&gt; p.Category)</span><br><span class="line">    .Select(g =&gt; <span class="keyword">new</span> {</span><br><span class="line">        Category = g.Key,</span><br><span class="line">        Count = g.Count(),</span><br><span class="line">        AvgPrice = g.Average(p =&gt; p.Price),</span><br><span class="line">        MinPrice = g.Min(p =&gt; p.Price),</span><br><span class="line">        MaxPrice = g.Max(p =&gt; p.Price)</span><br><span class="line">    });</span><br></pre></td></tr></table></figure>
<h3 id="连接操作符">连接操作符</h3>
<ul>
<li><strong>Join</strong> : 基于键相等连接两个序列 ( 类似 SQL 的 INNER
JOIN )</li>
<li><strong>GroupJoin</strong> : 基于键相等连接两个序列，并对结果分组 (
类似 SQL 的 LEFT JOIN )</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内连接 : 连接客户和他们的订单</span></span><br><span class="line"><span class="keyword">var</span> customerOrders = customers</span><br><span class="line">    .Join(orders,</span><br><span class="line">          c =&gt; c.Id,</span><br><span class="line">          o =&gt; o.CustomerId,</span><br><span class="line">          (c, o) =&gt; <span class="keyword">new</span> {</span><br><span class="line">              CustomerName = c.Name,</span><br><span class="line">              OrderId = o.Id,</span><br><span class="line">              OrderDate = o.Date</span><br><span class="line">          });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左连接 : 获取所有客户及其订单 ( 包括没有订单的客户 ) </span></span><br><span class="line"><span class="keyword">var</span> customerOrdersLeftJoin = customers</span><br><span class="line">    .GroupJoin(orders,</span><br><span class="line">               c =&gt; c.Id,</span><br><span class="line">               o =&gt; o.CustomerId,</span><br><span class="line">               (c, os) =&gt; <span class="keyword">new</span> {</span><br><span class="line">                   CustomerName = c.Name,</span><br><span class="line">                   Orders = os.Select(o =&gt; <span class="keyword">new</span> { o.Id, o.Date })</span><br><span class="line">               });</span><br></pre></td></tr></table></figure>
<h3 id="聚合操作符">聚合操作符</h3>
<ul>
<li><strong>Count</strong> : 计算序列中的元素数量</li>
<li><strong>Sum</strong> : 计算序列中数值的总和</li>
<li><strong>Average</strong> : 计算序列中数值的平均值</li>
<li><strong>Min</strong> : 获取序列中的最小值</li>
<li><strong>Max</strong> : 获取序列中的最大值</li>
<li><strong>Aggregate</strong> : 对序列应用自定义聚合操作</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本聚合</span></span><br><span class="line"><span class="built_in">int</span> productCount = products.Count();</span><br><span class="line"><span class="built_in">double</span> totalValue = products.Sum(p =&gt; p.Price * p.Stock);</span><br><span class="line"><span class="built_in">double</span> avgPrice = products.Average(p =&gt; p.Price);</span><br><span class="line"><span class="built_in">decimal</span> minPrice = products.Min(p =&gt; p.Price);</span><br><span class="line"><span class="built_in">decimal</span> maxPrice = products.Max(p =&gt; p.Price);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义聚合 - 计算所有数字的乘积</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line"><span class="built_in">int</span> product = numbers.Aggregate(<span class="number">1</span>, (acc, n) =&gt; acc * n); <span class="comment">// 结果: 1*1*2*3*4*5 = 120</span></span><br></pre></td></tr></table></figure>
<h3 id="元素操作符">元素操作符</h3>
<ul>
<li><strong>First/FirstOrDefault</strong> :
返回序列中的第一个元素，FirstOrDefault 在序列为空时返回默认值</li>
<li><strong>Last/LastOrDefault</strong> : 返回序列中的最后一个元素</li>
<li><strong>Single/SingleOrDefault</strong> :
返回序列中唯一的元素，若存在多个元素则抛出异常</li>
<li><strong>ElementAt/ElementAtOrDefault</strong> :
返回指定索引处的元素</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一个价格大于 1000 的产品</span></span><br><span class="line">Product expensiveProduct = products.First(p =&gt; p.Price &gt; <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一个订单，若没有订单则返回 null</span></span><br><span class="line">Order lastOrder = orders.LastOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 ID 为 5 的唯一客户</span></span><br><span class="line">Customer customer = customers.Single(c =&gt; c.Id == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引为 3 的产品</span></span><br><span class="line">Product fourthProduct = products.ElementAt(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="集合操作符">集合操作符</h3>
<ul>
<li><strong>Distinct</strong> : 移除序列中的重复元素</li>
<li><strong>Union</strong> : 返回两个序列的并集 ( 不包含重复元素 )</li>
<li><strong>Intersect</strong> : 返回两个序列的交集</li>
<li><strong>Except</strong> : 返回两个序列的差集</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有不重复的产品类别</span></span><br><span class="line"><span class="keyword">var</span> uniqueCategories = products.Select(p =&gt; p.Category).Distinct();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取两个列表中所有不重复的产品</span></span><br><span class="line"><span class="keyword">var</span> allProducts = products1.Union(products2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取两个列表中都存在的产品</span></span><br><span class="line"><span class="keyword">var</span> commonProducts = products1.Intersect(products2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取在第一个列表中但不在第二个列表中的产品</span></span><br><span class="line"><span class="keyword">var</span> onlyInFirst = products1.Except(products2);</span><br></pre></td></tr></table></figure>
<h2 id="延迟执行与立即执行">延迟执行与立即执行</h2>
<p>LINQ 查询有两种执行方式，理解这一点对正确使用 LINQ 至关重要 :</p>
<h3 id="延迟执行-deferred-execution">延迟执行 ( Deferred Execution
)</h3>
<p>大多数 LINQ 操作符 ( 如 Where、Select、OrderBy )
是延迟执行的，即查询定义时不会立即执行，直到实际需要结果时才执行 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义查询 ( 此时不执行 ) </span></span><br><span class="line"><span class="keyword">var</span> expensiveProducts = products.Where(p =&gt; p.Price &gt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据源</span></span><br><span class="line">products.Add(<span class="keyword">new</span> Product { Name = <span class="string">"Laptop"</span>, Price = <span class="number">1500</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询 ( 此时会包含刚添加的产品 ) </span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> expensiveProducts)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(product.Name);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>延迟执行的好处 :</p>
<ul>
<li>提高性能，避免不必要的计算</li>
<li>可以构建复杂的查询链</li>
<li>数据源的后续更改会反映在查询结果中</li>
</ul>
<h3 id="立即执行-immediate-execution">立即执行 ( Immediate Execution
)</h3>
<p>以下操作会立即执行查询并返回结果 :</p>
<ul>
<li>聚合操作符 ( Count、Sum、Average 等 )</li>
<li>转换为集合的方法 ( ToList、ToArray、ToDictionary 等 )</li>
<li>元素操作符 ( First、Last、Single 等 )</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即执行 - 转换为列表</span></span><br><span class="line">List&lt;Product&gt; expensiveProductsList = products</span><br><span class="line">    .Where(p =&gt; p.Price &gt; <span class="number">100</span>)</span><br><span class="line">    .ToList(); <span class="comment">// 此时执行查询并创建列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据源不会影响已创建的列表</span></span><br><span class="line">products.Add(<span class="keyword">new</span> Product { Name = <span class="string">"Laptop"</span>, Price = <span class="number">1500</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表中不包含刚添加的产品</span></span><br><span class="line">Console.WriteLine(expensiveProductsList.Count);</span><br></pre></td></tr></table></figure>
<h2 id="iqueryable-与-ienumerable">IQueryable 与 IEnumerable</h2>
<p>LINQ 有两种主要的接口 :</p>
<h3 id="ienumerable">IEnumerable<t></t></h3>
<ul>
<li>用于内存中的集合 ( LINQ to Objects )</li>
<li>使用委托 ( Func&lt;T, bool&gt; 等 ) 表示查询逻辑</li>
<li>查询在客户端执行</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Product&gt; query = products.Where(p =&gt; p.Price &gt; <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 执行时会在客户端内存中筛选所有产品</span></span><br></pre></td></tr></table></figure>
<h3 id="iqueryable">IQueryable<t></t></h3>
<ul>
<li>用于远程数据源 ( 如数据库，LINQ to Entities )</li>
<li>使用表达式树 ( Expression&lt;Func&lt;T, bool&gt;&gt; )
表示查询逻辑</li>
<li>查询可以转换为数据源的原生查询语言 ( 如 SQL ) ，在服务器端执行</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IQueryable&lt;Product&gt; query = dbContext.Products.Where(p =&gt; p.Price &gt; <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 执行时会转换为 SQL: SELECT * FROM Products WHERE Price &gt; 100</span></span><br><span class="line"><span class="comment">// 在数据库服务器上执行查询，只返回符合条件的结果</span></span><br></pre></td></tr></table></figure>
<p>关键区别 : IEnumerable 在客户端内存中处理所有数据，而 IQueryable
尽可能在数据源端处理查询，只返回需要的数据，通常性能更好。</p>
<h2 id="linq-中的匿名类型">LINQ 中的匿名类型</h2>
<p>LINQ 经常使用匿名类型来存储查询结果的子集 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建匿名类型</span></span><br><span class="line"><span class="keyword">var</span> productInfo = products</span><br><span class="line">    .Where(p =&gt; p.Price &gt; <span class="number">100</span>)</span><br><span class="line">    .Select(p =&gt; <span class="keyword">new</span> {</span><br><span class="line">        ProductName = p.Name,</span><br><span class="line">        Price = p.Price,</span><br><span class="line">        Category = p.Category</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匿名类型</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> productInfo)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">{item.ProductName}</span>: <span class="subst">{item.Price:C}</span>"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>匿名类型的特点 :</p>
<ul>
<li>编译器自动生成的只读类型</li>
<li>只能在声明的方法内部使用</li>
<li>属性名称和类型由初始化表达式推断</li>
<li>适合临时存储查询结果</li>
</ul>
<h2 id="linq-性能考量">LINQ 性能考量</h2>
<ol type="1">
<li><strong>尽量使用 IQueryable 而非 IEnumerable
处理数据库查询</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效 : 将所有产品加载到内存后再筛选</span></span><br><span class="line"><span class="keyword">var</span> expensiveProducts = dbContext.Products.ToList().Where(p =&gt; p.Price &gt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效 : 在数据库中筛选，只加载符合条件的产品</span></span><br><span class="line"><span class="keyword">var</span> expensiveProducts = dbContext.Products.Where(p =&gt; p.Price &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>避免 N+1 查询问题</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效 : 会产生 1 个查询获取所有订单，然后为每个订单产生 1 个查询获取订单项</span></span><br><span class="line"><span class="keyword">var</span> orders = dbContext.Orders.ToList();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> order <span class="keyword">in</span> orders)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> items = order.Items.ToList(); <span class="comment">// 每个订单产生一个新查询</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效 : 使用 Include 一次性加载相关数据</span></span><br><span class="line"><span class="keyword">var</span> orders = dbContext.Orders.Include(o =&gt; o.Items).ToList();</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>适当使用延迟执行</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高效 : 只获取需要的字段</span></span><br><span class="line"><span class="keyword">var</span> orderSummaries = dbContext.Orders</span><br><span class="line">    .Where(o =&gt; o.Date &gt; DateTime.Now.AddMonths(<span class="number">-1</span>))</span><br><span class="line">    .Select(o =&gt; <span class="keyword">new</span> {</span><br><span class="line">        o.Id,</span><br><span class="line">        o.Date,</span><br><span class="line">        o.Customer.Name,</span><br><span class="line">        Total = o.Items.Sum(i =&gt; i.Quantity * i.Price)</span><br><span class="line">    });</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>对大型集合使用分页</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页查询，只获取第 2 页的 10 条记录</span></span><br><span class="line"><span class="keyword">var</span> page = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> pageSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> pagedProducts = dbContext.Products</span><br><span class="line">    .OrderBy(p =&gt; p.Name)</span><br><span class="line">    .Skip((page - <span class="number">1</span>) * pageSize)</span><br><span class="line">    .Take(pageSize);</span><br></pre></td></tr></table></figure>
<h2 id="总结-3">总结</h2>
<p>LINQ 是 C#
中强大的查询技术，它提供了统一的方式来查询和操作各种数据源。通过
LINQ，开发者可以使用熟悉的 C#
语法编写查询，而不必学习不同数据源的查询语言。</p>
<p>LINQ 有两种语法形式 : 类 SQL
的查询语法和基于方法的方法语法，两者可以互换使用。理解延迟执行和立即执行的区别，以及
IQueryable 和 IEnumerable 的不同，对于编写高效的 LINQ 查询至关重要。</p>
<p>掌握 LINQ
可以显著提高代码的可读性和开发效率，尤其是在处理集合数据和数据库操作时。通过合理使用各种
LINQ 操作符，可以简洁地实现复杂的数据筛选、转换和聚合功能。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">sparkle520</div><div class="post-copyright__author_desc">我一直都在寻找着什么</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/')">c# 笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=c# 笔记&amp;url=http://example.com/2025/09/23/csharp%E7%AC%94%E8%AE%B0/&amp;pic=https://pic1.imgdb.cn/item/68d363acc5157e1a882c5be1.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SPARKLE</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/c/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>c#<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/68d363acc5157e1a882c5be1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/09/01/%E7%BA%BF%E4%BB%A36/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68b53c8858cb8da5c86a137e.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">线性代数 第六章 二次型</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/671cfe2fd29ded1a8c5ffb0b.png" alt="status"/></div></div><div class="author-info__description">不管你在<strong style="color:white">这个世界</strong>的哪个地方，我一定<strong style="color:white">会</strong>，再次去<strong style="color:white">见</strong>你的!</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">sparkle520</h1><div class="author-info__desc">我一直都在寻找着什么</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/sarkle520" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/34882250" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">《天气之子》小说已上线 ~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://pic.imgdb.cn/item/66c487f1d9c307b7e9ba5c7a.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://pic.imgdb.cn/item/66c487ebd9c307b7e9ba5725.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98-covariance"><span class="toc-number">1.</span> <span class="toc-text">协变 ( Covariance )</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%8F%98-contravariance"><span class="toc-number">2.</span> <span class="toc-text">逆变 ( Contravariance )</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98"><span class="toc-number">3.</span> <span class="toc-text">委托中的协变和逆变</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%A7%84%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">关键规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3-%E5%90%AB%E6%B3%9B%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">C# 反射机制详解 ( 含泛型操作 )</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">反射的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="toc-number">5.1.0.0.1.</span> <span class="toc-text">反射的核心价值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-%E9%9D%9E%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">反射的基础操作 ( 非泛型 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-type-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.1.</span> <span class="toc-text">获取 Type 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E4%BF%A1%E6%81%AF"><span class="toc-number">5.2.2.</span> <span class="toc-text">查看类型成员信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">核心成员获取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bindingflags-%E6%9E%9A%E4%B8%BE-%E5%85%B3%E9%94%AE"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">BindingFlags 枚举 ( 关键 )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">5.2.3.</span> <span class="toc-text">动态操作类型成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">动态创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%AE%BF%E9%97%AE%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">动态访问&#x2F;修改字段&#x2F;属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">动态调用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C-%E9%87%8D%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">泛型的反射操作 ( 重点 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text">泛型的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">泛型类型的反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">获取泛型类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">动态创建泛型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E9%9D%9E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">调用泛型类的非泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-number">5.3.3.</span> <span class="toc-text">泛型方法的反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E4%BB%A5%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-converttovvt-input-%E4%B8%BA%E4%BE%8B"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">示例 ( 以泛型方法
ConvertToV&lt;V&gt;(T input) 为例 )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-number">5.3.4.</span> <span class="toc-text">静态泛型方法的反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.4.</span> <span class="toc-text">反射的优缺点与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">5.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">5.4.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.5.</span> <span class="toc-text">常见应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E7%89%B9%E6%80%A7-attribute-%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">C# 特性 ( Attribute ) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">特性的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%B9%E6%80%A7"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">6.1.2.</span> <span class="toc-text">特性的命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8%E7%9B%AE%E6%A0%87"><span class="toc-number">6.1.3.</span> <span class="toc-text">特性的应用目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attributeusage-%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">AttributeUsage 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">常用内置特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#obsolete-%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.1.</span> <span class="toc-text">Obsolete 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#conditional-%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.2.</span> <span class="toc-text">Conditional 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serializable-%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.3.</span> <span class="toc-text">Serializable 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deprecated-%E7%89%B9%E6%80%A7-.net-5"><span class="toc-number">6.3.4.</span> <span class="toc-text">Deprecated 特性 ( .NET 5+ )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.5.</span> <span class="toc-text">程序集特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.6.</span> <span class="toc-text">数据验证特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">自定义特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7%E7%B1%BB"><span class="toc-number">6.4.1.</span> <span class="toc-text">创建自定义特性类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.2.</span> <span class="toc-text">应用自定义特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.3.</span> <span class="toc-text">通过反射读取特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="toc-number">6.5.</span> <span class="toc-text">特性的高级应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.5.1.</span> <span class="toc-text">带参数的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7-c-11"><span class="toc-number">6.5.2.</span> <span class="toc-text">泛型特性 ( C# 11+ )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%8E-aop-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="toc-number">6.5.3.</span> <span class="toc-text">特性与 AOP ( 面向切面编程 )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.6.</span> <span class="toc-text">特性在框架中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#asp.net-core-%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.6.1.</span> <span class="toc-text">ASP.NET Core 中的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.6.2.</span> <span class="toc-text">序列化中的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.7.</span> <span class="toc-text">特性的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">6.7.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">6.7.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.8.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E5%A7%94%E6%89%98-delegate"><span class="toc-number">7.</span> <span class="toc-text">C# 委托 ( Delegate )</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">委托的基本定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">本质与作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">7.1.2.</span> <span class="toc-text">语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">声明委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%96%B9%E6%B3%95-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A7%94%E6%89%98"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">关联方法 ( 实例化委托 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%A7%94%E6%89%98"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">调用委托</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text">委托的核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98-multicast-delegate"><span class="toc-number">7.2.1.</span> <span class="toc-text">多播委托 ( Multicast Delegate
)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">添加&#x2F;移除方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E7%AD%BE%E5%90%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">7.2.2.</span> <span class="toc-text">委托与方法的签名匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E5%A7%94%E6%89%98-%E6%97%A0%E9%9C%80%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">7.3.</span> <span class="toc-text">系统内置委托 ( 无需自定义 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#action-%E5%A7%94%E6%89%98"><span class="toc-number">7.3.1.</span> <span class="toc-text">Action 委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-%E5%A7%94%E6%89%98"><span class="toc-number">7.3.2.</span> <span class="toc-text">Func 委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#predicate-%E5%A7%94%E6%89%98"><span class="toc-number">7.3.3.</span> <span class="toc-text">Predicate 委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.4.</span> <span class="toc-text">委托的典型应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-%E8%A7%A3%E8%80%A6"><span class="toc-number">7.4.1.</span> <span class="toc-text">方法作为参数传递 ( 解耦 )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80"><span class="toc-number">7.4.2.</span> <span class="toc-text">事件驱动编程 ( 基础 )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83-%E7%AE%80%E5%8C%96%E7%89%88"><span class="toc-number">7.4.3.</span> <span class="toc-text">异步回调 ( 简化版 )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E4%B8%8E-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.5.</span> <span class="toc-text">委托与 Lambda 表达式的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.6.</span> <span class="toc-text">常见问题与注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E4%BA%8B%E4%BB%B6-event"><span class="toc-number">8.</span> <span class="toc-text">C# 事件 ( Event )</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">事件的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BD%9C%E7%94%A8-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">本质与作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%A7%94%E6%89%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.2.</span> <span class="toc-text">与委托的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">事件的声明与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A0%87%E5%87%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.2.1.</span> <span class="toc-text">声明事件的标准步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0%E7%B1%BB-%E5%8F%AF%E9%80%89%E7%94%A8%E4%BA%8E%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">定义事件参数类 (
可选，用于传递数据 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B-%E6%88%96%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%A7%94%E6%89%98"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">定义委托类型 ( 或使用内置委托
)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%8F%91%E5%B8%83%E8%80%85%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.2.1.3.</span> <span class="toc-text">在发布者类中声明事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E8%80%85%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%A4%84%E7%90%86"><span class="toc-number">8.2.1.4.</span> <span class="toc-text">订阅者订阅事件并处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.1.5.</span> <span class="toc-text">使用事件机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">8.2.2.</span> <span class="toc-text">事件的核心语法规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#net-%E4%BA%8B%E4%BB%B6%E7%BA%A6%E5%AE%9A%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">8.3.</span> <span class="toc-text">.NET 事件约定与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">8.3.1.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%A7%94%E6%89%98"><span class="toc-number">8.3.2.</span> <span class="toc-text">推荐使用内置委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%80%83%E9%87%8F"><span class="toc-number">8.3.3.</span> <span class="toc-text">线程安全考量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.3.4.</span> <span class="toc-text">避免过度使用静态事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%A7%94%E6%89%98%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">事件与委托的关键区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.5.</span> <span class="toc-text">典型应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gui-%E6%8E%A7%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.5.1.</span> <span class="toc-text">GUI 控件事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E9%80%9A%E7%9F%A5"><span class="toc-number">8.5.2.</span> <span class="toc-text">状态变化通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%AE%8C%E6%88%90%E9%80%9A%E7%9F%A5"><span class="toc-number">8.5.3.</span> <span class="toc-text">异步操作完成通知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">8.6.</span> <span class="toc-text">常见问题与注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">C# Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">核心概念与语法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0-lambda"><span class="toc-number">9.1.1.</span> <span class="toc-text">无参数 Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%8F%82%E6%95%B0-lambda"><span class="toc-number">9.1.2.</span> <span class="toc-text">单参数 Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0-lambda"><span class="toc-number">9.1.3.</span> <span class="toc-text">多参数 Lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">9.2.</span> <span class="toc-text">类型推断机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%A7%94%E6%89%98%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="toc-number">9.3.</span> <span class="toc-text">与委托的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">9.4.</span> <span class="toc-text">与匿名方法的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">9.5.</span> <span class="toc-text">表达式树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%89%B9%E6%80%A7"><span class="toc-number">9.6.</span> <span class="toc-text">闭包特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-linq-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.7.</span> <span class="toc-text">在 LINQ 中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.8.</span> <span class="toc-text">在事件处理中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-lambda"><span class="toc-number">9.9.</span> <span class="toc-text">异步 Lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.10.</span> <span class="toc-text">最佳实践与注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">9.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-linq"><span class="toc-number">10.</span> <span class="toc-text">C# LINQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-linq"><span class="toc-number">10.1.</span> <span class="toc-text">什么是 LINQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linq-%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">LINQ 的两种语法形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95-query-syntax"><span class="toc-number">10.2.1.</span> <span class="toc-text">查询语法 ( Query Syntax )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95-method-syntax"><span class="toc-number">10.2.2.</span> <span class="toc-text">方法语法 ( Method Syntax )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linq-%E6%A0%B8%E5%BF%83%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">10.3.</span> <span class="toc-text">LINQ 核心命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linq-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">LINQ 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linq-to-objects"><span class="toc-number">10.4.1.</span> <span class="toc-text">LINQ to Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linq-to-entities"><span class="toc-number">10.4.2.</span> <span class="toc-text">LINQ to Entities</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linq-to-sql"><span class="toc-number">10.4.3.</span> <span class="toc-text">LINQ to SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linq-to-xml"><span class="toc-number">10.4.4.</span> <span class="toc-text">LINQ to XML</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-linq-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.</span> <span class="toc-text">常用 LINQ 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.1.</span> <span class="toc-text">筛选操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.2.</span> <span class="toc-text">投影操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.3.</span> <span class="toc-text">排序操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.4.</span> <span class="toc-text">分组操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.5.</span> <span class="toc-text">连接操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.6.</span> <span class="toc-text">聚合操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.7.</span> <span class="toc-text">元素操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.5.8.</span> <span class="toc-text">集合操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C"><span class="toc-number">10.6.</span> <span class="toc-text">延迟执行与立即执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C-deferred-execution"><span class="toc-number">10.6.1.</span> <span class="toc-text">延迟执行 ( Deferred Execution
)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C-immediate-execution"><span class="toc-number">10.6.2.</span> <span class="toc-text">立即执行 ( Immediate Execution
)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iqueryable-%E4%B8%8E-ienumerable"><span class="toc-number">10.7.</span> <span class="toc-text">IQueryable 与 IEnumerable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ienumerable"><span class="toc-number">10.7.1.</span> <span class="toc-text">IEnumerable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iqueryable"><span class="toc-number">10.7.2.</span> <span class="toc-text">IQueryable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linq-%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.8.</span> <span class="toc-text">LINQ 中的匿名类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linq-%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F"><span class="toc-number">10.9.</span> <span class="toc-text">LINQ 性能考量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">10.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/23/csharp%E7%AC%94%E8%AE%B0/" title="c# 笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68d363acc5157e1a882c5be1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c# 笔记"/></a><div class="content"><a class="title" href="/2025/09/23/csharp%E7%AC%94%E8%AE%B0/" title="c# 笔记">c# 笔记</a><time datetime="2025-09-23T15:00:27.000Z" title="发表于 2025-09-23 23:00:27">2025-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/01/%E7%BA%BF%E4%BB%A36/" title="线性代数 第六章 二次型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68b53c8858cb8da5c86a137e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性代数 第六章 二次型"/></a><div class="content"><a class="title" href="/2025/09/01/%E7%BA%BF%E4%BB%A36/" title="线性代数 第六章 二次型">线性代数 第六章 二次型</a><time datetime="2025-09-01T15:00:27.000Z" title="发表于 2025-09-01 23:00:27">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/%E7%BA%BF%E4%BB%A35/" title="线性代数 第五章 相似矩阵"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68b2cd4c58cb8da5c8646ba5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性代数 第五章 相似矩阵"/></a><div class="content"><a class="title" href="/2025/08/30/%E7%BA%BF%E4%BB%A35/" title="线性代数 第五章 相似矩阵">线性代数 第五章 相似矩阵</a><time datetime="2025-08-30T15:00:27.000Z" title="发表于 2025-08-30 23:00:27">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/04/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="计算机网络 第四章 网络层"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6867d38058cb8da5c890817d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 第四章 网络层"/></a><div class="content"><a class="title" href="/2025/07/04/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="计算机网络 第四章 网络层">计算机网络 第四章 网络层</a><time datetime="2025-07-04T15:00:27.000Z" title="发表于 2025-07-04 23:00:27">2025-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" title="高等数学 第八章 向量代数与空间解析几何"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/685af9d658cb8da5c86c6180.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高等数学 第八章 向量代数与空间解析几何"/></a><div class="content"><a class="title" href="/2025/06/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" title="高等数学 第八章 向量代数与空间解析几何">高等数学 第八章 向量代数与空间解析几何</a><time datetime="2025-06-28T15:00:27.000Z" title="发表于 2025-06-28 23:00:27">2025-06-28</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#footer-type-tips", {
      strings: ["只要记住你的名字&#44; 不管你在世界的哪个地方&#44; 我一定&#44; 会去见你 !"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("footer-type-tips").innerHTML = '只要记住你的名字&#44; 不管你在世界的哪个地方&#44; 我一定&#44; 会去见你 !'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/sparkle520" title="sparkle">sparkle</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/sparkle520?tab=repositories" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Deep-Learning/" style="font-size: 0.88rem;">Deep Learning<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/JSR303/" style="font-size: 0.88rem;">JSR303<sup>1</sup></a><a href="/tags/Matplotlib/" style="font-size: 0.88rem;">Matplotlib<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>4</sup></a><a href="/tags/npc%E5%88%86%E6%9E%90%E6%B3%95/" style="font-size: 0.88rem;">npc分析法<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>5</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>1</sup></a><a href="/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/" style="font-size: 0.88rem;">二次型<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%82/" style="font-size: 0.88rem;">你的名字。<sup>3</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">你的名字同名小说<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%A4%96%E4%BC%A0%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">你的名字外传小说<sup>1</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">包管理<sup>1</sup></a><a href="/tags/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/" style="font-size: 0.88rem;">卷积公式<sup>1</sup></a><a href="/tags/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" style="font-size: 0.88rem;">向量代数与空间解析几何<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/" style="font-size: 0.88rem;">天气之子<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">天气之子同名小说<sup>1</sup></a><a href="/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/" style="font-size: 0.88rem;">定积分<sup>2</sup></a><a href="/tags/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/" style="font-size: 0.88rem;">导数与微分<sup>1</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">小说<sup>10</sup></a><a href="/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" style="font-size: 0.88rem;">微分方程<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" style="font-size: 0.88rem;">数据校验<sup>1</sup></a><a href="/tags/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/" style="font-size: 0.88rem;">无穷级数<sup>1</sup></a><a href="/tags/%E6%9E%81%E9%99%90/" style="font-size: 0.88rem;">极限<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 0.88rem;">概率论<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" style="font-size: 0.88rem;">概率论与数理统计<sup>7</sup></a><a href="/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" style="font-size: 0.88rem;">泰勒展开<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%80%BC/" style="font-size: 0.88rem;">特征值<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" style="font-size: 0.88rem;">特征向量<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/" style="font-size: 0.88rem;">网络层<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/" style="font-size: 0.88rem;">英语听力<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 0.88rem;">英语语法<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/" style="font-size: 0.88rem;">词根词缀<sup>1</sup></a><a href="/tags/%E8%B4%A5%E5%8C%97%E5%A5%B3%E8%A7%92%E5%A4%AA%E5%A4%9A%E4%BA%86/" style="font-size: 0.88rem;">败北女角太多了!<sup>7</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" style="font-size: 0.88rem;">高等代数<sup>2</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">高等数学<sup>9</sup></a><a href="/tags/%E9%AB%98%E9%A2%91%E8%AF%8D%E7%BB%84/" style="font-size: 0.88rem;">高频词组<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://sparkle521.xyz',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://sparkle521.xyz',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://sparkle521.xyz',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>