<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>408-操作系统-2-进程与线程 | SPARKLE</title><meta name="keywords" content="操作系统,408"><meta name="author" content="sparkle520"><meta name="copyright" content="sparkle520"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="408-操作系统-2-进程与线程"><meta name="application-name" content="408-操作系统-2-进程与线程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="408-操作系统-2-进程与线程"><meta property="og:url" content="http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/index.html"><meta property="og:site_name" content="SPARKLE"><meta property="og:description" content="第2章 进程与线程 2.1 进程与线程 2.1.1 进程的概念和特征  定义 : 进程 ( Process ) 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行 资源分配 和 调度 的基本单位. 特征 :  动态性 : 进程是程序的一次执行过程，有生命周期 ( 最基本特"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pic1.imgdb.cn/item/69492ebfc154427986d9c262.png"><meta property="article:author" content="sparkle520"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic1.imgdb.cn/item/69492ebfc154427986d9c262.png"><meta name="description" content="第2章 进程与线程 2.1 进程与线程 2.1.1 进程的概念和特征  定义 : 进程 ( Process ) 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行 资源分配 和 调度 的基本单位. 特征 :  动态性 : 进程是程序的一次执行过程，有生命周期 ( 最基本特"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://sparkle521.xyz',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["(❤ ω ❤)"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: sparkle520","link":"链接: ","source":"来源: SPARKLE","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#883ced","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'SPARKLE',
  title: '408-操作系统-2-进程与线程',
  postAI: '',
  pageFillDescription: '第2章 进程与线程, 2.1 进程与线程, 2.1.1 进程的概念和特征, 2.1.2 进程的组成, PCB 详解, 2.1.3 进程的状态与转换, 状态定义, 扩展状态, 典型触发与转换, 2.1.4 进程控制, 核心概念, 基本原语与典型步骤, 约束与策略, 常见接口速记 ( 类 Unix ), 2.1.5 进程的通信, 共享存储 ( Shared Memory ), 消息传递 ( Message Passing ), 管道通信 ( Pipe / FIFO ), 套接字 ( Socket ), 信号 ( Signal ), 对比与选型, 常见接口速记 ( 类 Unix ), 2.1.6 线程和多线程模型, 线程的基本概念, 引入线程的目的与优势, 线程的基本特性, 线程的状态与转换, 线程控制块 (TCB) 典型字段, 线程的属性, 进程与线程对比速查, 线程的实现方式, 多线程模型, 线程调度与同步, 常见接口速记 ( 类 Unix ), 2.2 CPU 调度, 2.2.1 调度的概念, 三级调度的联系, 2.2.2 调度的实现, 1. 逻辑组成, 2. 调度的时机, 3. 调度的方式, 4. 分派延迟 ( Dispatch Latency ), 5. 闲逛进程 ( Idle Process ), 6. 两种线程的调度, 2.2.3 调度的目标 ( 评价指标 ), 1. 评价指标详解, (3) 周转时间 ( Turnaround Time ), (5) 等待时间 ( Waiting Time ), (6) 响应时间 ( Response Time ), 2. 指标图解, 3. 不同系统的侧重点, 1. 模式切换 vs 上下文切换, 2. 进程切换的详细步骤, 3. 切换开销分析, 2.2.5 CPU 调度算法, 1. 适用于批处理系统的算法, 2. 适用于交互式系统的算法, 2.2.6 算法特性对比速查, 1. 基本模型, 2. 就绪队列结构, 3. 处理器亲和性 ( Affinity ), 4. 负载均衡与迁移, 5. NUMA 考量, 6. 并行作业与协同调度, 7. 超线程/核心/插槽, 8. 实践示例 ( Linux CFS ), 9. 架构对比, 2.3 同步与互斥, 2.3.1 同步与互斥的基本概念, 临界资源访问过程, 2.3.2 实现临界区互斥的基本方法, 软件实现, 单标志法, 双标志先检查, 双标志后检查, Peterson 算法, 硬件实现, Test-and-Set ( TS ) 指令, Swap 指令 ( Exchange ), 2.3.3 互斥锁 ( Mutex ), 2.3.4 信号量 ( Semaphore ), 3. 信号量的应用, 2.3.5 经典同步问题, 2.3.6 管程 ( Monitor ), 2.4 死锁 ( Deadlock ), 2.4.1 死锁的概念, 2.4.2 死锁处理策略, 2.4.3 死锁预防 ( Prevention ), 1. 死锁检测 ( Detection ), 2. 死锁解除 ( Recovery )第章进程与线程进程与线程进程的概念和特征定义进程是计算机中的程序关于某数据集合上的一次运行活动是系统进行资源分配和调度的基本单位特征动态性进程是程序的一次执行过程有生命周期最基本特征并发性多个进程可以同时间隔执行独立性进程是能独立运行独立获得资源独立调度的基本单位异步性进程按各自独立的不可预知的速度向前推进结构性每个进程都有一个进程控制块进程的组成进程实体进程映像由以下三部分组成进程控制块存放进程管理和控制信息如状态优先级寄存器值是进程存在的唯一标志程序段存放要执行的代码数据段存放程序运行期间处理的原始数据和中间结果程序段的共享与复用多进程调用可重入纯代码段共享程序的代码段是只读且可重入的多个进程可以通过页表映射到同一组物理代码页从而节省内存并提高指令缓存命中率写时复制在之后父子进程最初共享相同的代码页和数据页当某一方尝试写入数据页时触发内核复制一份私有副本并将其页表改为可写保证相互隔离动态链接库共享动态库的代码页在多个进程之间共享加载每个进程拥有该库的私有数据和重定位信息内存映射机制通过节段装入将同一二进制的代码文件映射至不同进程的地址空间实现按需调页与共享隔离边界进程之间只共享只读代码页数据段堆栈打开文件表等均为进程私有彼此隔离与保护进程地址空间代码段共享进程地址空间数据段堆栈私有数据段堆栈私有物理页帧只读详解概念进程控制块是操作系统用于管理进程的数据结构记录进程的一切关键信息是进程存在的唯一标志操作系统通过查找修改来完成创建撤销调度阻塞唤醒等控制操作典型内容标识与描述信息进程标识符所属用户组父进程会话作业号等处理机现场上下文信息通用寄存器值程序计数器程序状态字栈指针等用于进程切换时的现场保存与恢复进程控制与调度信息当前状态就绪运行阻塞挂起等优先级时间片调度所需统计量就绪阻塞队列的链接指针资源分配信息地址空间描述页表段表基址打开文件表文件描述符所占用的设备通信端口信号信号量等记账与统计信息累计时间创建开始时间页面错误计数系统调用计数等组织方式操作系统通常将以链表队列方式组织例如就绪队列阻塞队列每个通过指针域连接在对应队列上调度器据此选择下一个要运行的进程进程切换与当发生调度或中断时系统将当前进程的现场写入其再从被选中的进程中恢复现场继续其执行生命周期与位置在创建进程时分配并初始化在进程终止后回收出于安全考虑通常位于内核空间用户态不可直接访问与线程的关系线程是调度单位拥有线程控制块多个线程共享同一进程的地址空间打开文件等资源就绪队列状态就绪状态就绪阻塞队列原因等待原因信号量运行中调度分派运行阻塞事件完成就绪进程的状态与转换状态定义运行态获得正在执行指令就绪态具备运行条件等待分配阻塞态因资源事件未就绪而暂停执行创建态进程被创建加载必要信息尚未进入就绪队列终止态进程执行结束或被撤销等待系统回收资源扩展状态挂起就绪进程暂时换出到外存如内存紧张当前不在就绪队列激活后回到就绪挂起阻塞进程既在等待事件又被换出到外存事件完成且被激活后回到就绪典型触发与转换就绪运行被调度分派获得运行就绪时间片用完或被高优先级抢占运行阻塞主动请求等待锁信号量资源阻塞就绪完成资源到达被唤醒就绪阻塞挂起就绪挂起阻塞中级调度对换到外存内存回收挂起就绪挂起阻塞就绪被激活换入内存阻塞条件消失后可就绪运行终止正常结束或异常被系统撤销创建就绪调度分派运行时间片用完抢占等待资源阻塞事件完成挂起挂起就绪挂起挂起阻塞激活事件完成激活结束终止进程控制核心概念进程控制由原语完成包含创建终止阻塞唤醒挂起激活切换等操作均具有原子性执行期间不可被中断相关实体调度器决定哪个进程运行分派程序执行上下文切换记录进程状态与现场就绪阻塞队列组织进程基本原语与典型步骤创建申请并初始化分配唯一建立或继承地址空间装入程序段初始化数据段栈初始化现场寄存器置状态就绪插入就绪队列典型接口复制父进程常用写时复制用新程序映像替换当前进程终止从队列中移出释放资源内存文件句柄撤销与父子关系子进程终止后进入僵尸态父进程通过回收退出码与内核表项孤儿进程由系统进程领养并回收阻塞触发条件请求锁信号量事件等资源未就绪步骤保存现场置状态阻塞按阻塞原因挂入阻塞队列触发调度唤醒触发条件完成资源到达信号唤醒等步骤从阻塞队列取出置状态就绪插入就绪队列挂起激活中级调度为了回收内存将进程对换到外存形成挂起就绪挂起阻塞被激活后换入内存并回到就绪进程切换保存当前进程现场到通用寄存器页表寄存器等更新当前进程指针恢复新进程现场切换地址空间与内核栈返回新进程处继续执行约束与策略原子性与临界区原语执行期间关中断或使用硬件指令确保不可分割优先级与时间片支持动态优先级老化策略时间片耗尽导致运行就绪资源与引用计数打开文件表内存页框信号量等使用引用计数以支持共享与安全回收信号异常处理异步事件可能导致阻塞唤醒终止等状态变化创建就绪分派运行时间片用完抢占阻塞阻塞唤醒挂起挂起就绪挂起挂起阻塞激活事件完成激活退出终止常见接口速记类创建与替换终止与回收阻塞与同步唤醒与信号优先级进程的通信进程通信指进程间的信息交换常见机制如下共享存储思想将一块物理内存映射到多个进程的地址空间实现零拷贝数据交换最快特点需要配合同步原语互斥锁信号量条件变量保证一致性适合大数据量高吞吐场景实现文件映射写时复制与共享后页面共享写入触发复制共享内存段通常标记为可读写并由各进程显式同步进程共享内存段进程加锁写入解锁读取消息传递直接通信发送者指定接收者内核将消息拷贝到接收方的消息队列支持阻塞非阻塞同步异步间接通信信箱收件箱消息发送至信箱接收者从信箱提取实现解耦与一对多实现消息队列语义有界队列可能导致阻塞支持优先级与按类型筛选发送进程发送消息信箱消息队列按类型优先级取出接收进程管道通信匿名管道父子进程通过内核环形缓冲区单向通信读空阻塞写满阻塞只能在有亲缘关系的进程间使用命名管道通过文件系统命名支持非亲缘关系进程通信语义字节流有序半双工需配合阻塞非阻塞模式与缓冲大小考虑写端进程管道缓冲区读端进程套接字本地套接字同一主机内进程通信零拷贝相对较少支持流式与数据报网络套接字跨主机通信基于适合分布式系统与微服务接口信号思想异步事件通知机制用于控制而非大数据传输如终止重载配置处理默认动作忽略自定义处理与阻塞唤醒异常处理关联内存映射文件通过将文件映射到内存实现多个进程对同一文件的共享视图适合日志共享数据区域对比与选型机制拷贝次数吞吐延迟适用场景共享内存极高极低大数据低延迟本机消息队列中中解耦按类型分发管道中中父子同机简单通信套接字低高跨主机复杂拓扑信号控制通知常见接口速记类共享内存消息队列管道套接字信号线程和多线程模型线程的基本概念定义线程是程序执行流的最小单位是调度的基本单位与进程的区别进程是资源分配单位线程是调度单位共享与私有线程共享进程的地址空间打开文件信号量等资源拥有独立栈寄存器现场线程本地存储控制块线程使用记录线程状态优先级栈指针等多个归属于一个进程的引入线程的目的与优势降低开销线程的创建切换不需要切换进程地址空间与页表代价远低于进程提升并发与吞吐引入线程后进程内的多个线程可并发执行在多核系统上可并行提高系统资源利用率与系统吞吐量更高的响应性线程可拆分任务与计算并行避免单线程阻塞导致应用无响应更易的共享与协作线程天然共享进程资源线程间通信成本低直接共享内存配合同步原语线程的基本特性轻量实体不拥有独立系统资源具有唯一标识与独立栈寄存器现场独立调度单位线程是被调度的基本单位线程切换通常不会引起进程切换同一地址空间下并发并行性不仅进程之间可并发同一进程的多个线程也可并发并行在多系统上多线程可同时占用多个共享性同一进程的多线程共享进程拥有的全部资源地址空间文件等开销更小创建撤销与切换的代价明显小于进程平均每次切换的开销更低线程的状态与转换基本状态就绪具备运行条件等待运行占用阻塞等待事件资源转换就绪运行分派运行就绪时间片用完被抢占运行阻塞等待锁阻塞就绪事件完成就绪分派运行时间片用完抢占等待锁条件变量阻塞事件完成唤醒线程控制块典型字段标识信息线程所属进程名称处理机现场通用寄存器集程序计数器程序状态字栈指针调度信息状态优先级时间片亲和性就绪阻塞队列链接指针存储信息线程栈起始与大小指针信号屏蔽集统计信息累计时间调度次数阻塞原因线程的属性分离态可连接分离态线程结束后资源由系统自动回收可连接线程需由其他线程获取返回值并回收资源调度策略与优先级常见策略优先级影响抢占次序与时间片分配亲和性绑定到特定节点提升缓存命中与局部性栈属性栈大小栈起始地址保护页防止栈溢出越界取消与取消点支持取消状态可取消不可取消取消类型延迟取消异步取消在取消点如阻塞生效信号屏蔽集每个线程可设置自己的信号屏蔽与处理函数进程范围内的某些信号按线程语义分发属性接口初始化设置查询使用如分离态栈大小亲和性进程地址空间打开文件信号量代码段共享数据段共享部分线程栈寄存器线程栈寄存器线程栈寄存器进程与线程对比速查维度进程线程定义单位资源分配单位调度单位地址空间独立地址空间切换需页表内核栈切换共享进程地址空间切换仅栈寄存器资源持有拥有文件设备内存等资源共享进程资源私有栈寄存器通信成本需管道消息队列共享内存直接读写共享内存需同步原语创建销毁开销大创建地址空间页表等小创建栈切换开销大地址空间切换刷新小同地址空间阻塞影响阻塞不影响其他进程阻塞不影响其他线程可能阻塞全进程隔离与稳定性崩溃不影响其他进程隔离强一个线程崩溃可能导致整个进程崩溃并行能力多进程可多核并行可多核并行不可适用场景高可靠隔离的服务或组件同一应用内的并发执行密集计算并行线程的实现方式用户级线程管理者线程库在用户态实现创建调度切换内核对线程不可见优点切换快无需陷入内核可定制调度策略创建销毁开销小缺点阻塞系统调用会阻塞整个进程无法利用多核实现真实并行通常映射到单个内核定时器等无法直接抢占线程内核级线程管理者由操作系统内核管理与调度每个线程作为内核可见实体优点可在多核上并行一个线程阻塞不影响同进程其他线程与内核机制信号定时器调度协同良好缺点切换需用户态内核态转换开销相对较大创建销毁成本高多线程模型多对一多个映射到一个特点不支持真正并行一个线程阻塞会拖累全进程优点开销最小实现简单缺点并发度受限适用性差一对一每个映射到一个现代主流如特点可并行阻塞互不影响优点语义清晰生态成熟缺点线程数多时内核管理开销增大多对多多个映射到多个需要协调机制如特点试图兼顾的低开销与的并行能力优点可控制并行度减少内核压力缺点实现复杂语义边界与调度协同难度大修改连线样式颜色灰色宽度箭头颜色会自动跟随多对一进程一对一进程多对多进程线程调度与同步调度一对一模型下由内核调度多对一多对多需用户态调度器与内核调度协同同步原语互斥锁读写锁条件变量信号量屏障避免竞态死锁活锁优先级反转可用优先级继承上限协议缓解阻塞语义需避免阻塞系统调用或使用异步阻塞不影响其他线程亲和性与并行线程可设置亲和性提升缓存局部性注意影响常见接口速记类创建结束同步属性栈大小亲和性分离态特性创建轻量进程共享资源提供语义与高性能调度调度的概念作业调度高级调度从外存挑选作业调入内存分配资源并创建进程发生频率低分钟级内存调度中级调度将暂时不能运行的进程挂起到外存以腾出内存空间条件满足时再调入频率中等进程调度低级调度从就绪队列挑选进程分配发生频率最高毫秒级三级调度的联系层级关系高级调度决定了谁能进门允许多少作业进入内存控制多道程序度低级调度决定了谁能干活哪个就绪进程获得中级调度决定了谁先歇会内存紧张时将进程换出平衡系统负载协同工作高级调度为低级调度提供原材料就绪进程中级调度为低级调度提供平滑剂避免内存不足导致颠簸频率对比低级调度毫秒级中级调度秒级高级调度分钟级存储层次外存作业池对换区内存就绪队列运行高级调度作业进程低级调度就绪运行时间片中断中级调度挂起中级调度激活调度的实现逻辑组成现代操作系统的调度模块通常包含三个核心组件它们分工明确共同完成的分配与切换排队器职责将就绪进程插入到相应的就绪队列中策略依据调度算法如优先级多级队列维护队列结构分派器职责依据调度程序的决策从就绪队列中取出进程动作它是调度逻辑与底层切换机制的衔接点上下文切换器职责执行实际的硬件级切换动作保存当前进程的硬件上下文寄存器栈指针到其加载选定进程的硬件上下文刷新视架构而定导致隐式开销操作系统调度子系统排队器调度程序分派器上下文切换器进程入队就绪队列决策出队触发保存恢复调度的时机调度请求通常由中断或系统调用触发分为以下三类情况必须调度必须让出进程终止进程执行完毕进程阻塞进程主动请求等待锁或信号量异常终止发生不可恢复的错误如除零段错误可以调度抢占式系统时间片耗尽时钟中断触发防止进程独占更高优先级进程就绪完成中断唤醒了高优先级进程新进程创建且优先级更高进程优先级动态改变变高系统调用返回用户态时内核处理完系统调用准备切回用户态前检查调度标志不能调度临界情况处理中断服务程序期间中断处理应尽快完成不宜切换处于原子操作自旋锁期间切换可能导致死锁或数据不一致内核临界区视内核设计而定抢占式内核允许部分抢占调度器必须调度主动终止进程终止阻塞等待异常终止可以调度被动抢占时间片用完唤醒高优进程系统调用返回不能调度保护中断处理中持有自旋锁内核临界区触发触发触发触发触发触发禁止禁止禁止进程切换决定切换调度的方式方式描述触发条件优点缺点适用场景非抢占式一旦分配直至进程完成或阻塞才释放主动放弃终止实现简单开销小适合批处理响应差可能导致饥饿早期批处理系统抢占式允许中断当前执行的进程强行分配给更重要的进程时间片耗尽高优先级到达中断返回响应快公平防死锁切换频繁开销大需处理竞态条件现代通用抢占的原则依据优先权原则只要出现更高优先级的进程立即抢占如实时系统短作业优先原则新到达作业比当前剩余时间短则抢占时间片原则运行完一个时间片必须释放抢占式非抢占式高优低优非抢占式低优运行高优到达但等待高优运行抢占式低优运行高优抢占运行低优恢复运行分派延迟定义停止一个进程到启动另一个进程的时间纯系统开销组成保存旧进程调度算法选择恢复新进程用户态进程进程内核态调度分派正在运行就绪等待中断系统调用异常陷入内核保存上下文状态更新运行就绪阻塞调度程序选择分派程序恢复隐式开销刷新切换回用户态开始运行步骤总耗时即为分派延迟闲逛进程定义当系统中没有就绪进程时调度程序选择运行的特殊进程或特殊标识特性优先级最低只有在就绪队列为空时才运行能耗优化现代在执行循环时会进入低功耗模式指令不可阻塞闲逛进程不应执行任何可能导致阻塞的操作地址空间通常不需要独立的用户地址空间仅在内核态运行两种线程的调度用户级线程调度调度者应用程序内部的线程库如内核视角内核只看到一个进程不知道内部有多个线程特点即使有多个该进程的多个也只能分时复用一个内核分配的时间片除非模型内核级线程调度调度者操作系统内核内核视角内核维护每个线程的将其视为独立的调度实体特点可以将同一进程的多个分配到不同上并行执行用户态调度应用程序运行时库调度库调度内核态调度调度器对应进程硬件复用复用系统调度执行调度的目标评价指标调度算法的选择取决于系统的设计目标不同的系统批处理分时实时有不同的侧重点但通常围绕以下核心指标进行评价评价指标详解利用率定义处于忙碌状态的时间占总时间的比例公式利用率有效工作时间有效工作时间空闲等待时间目标尽可能高注意密集型作业会导致利用率下降需多道程序提高系统吞吐量定义单位时间内完成作业的数量公式吞吐量完成作业总数总花费时间目标尽可能高适合批处理系统周转时间定义从作业提交给系统开始到作业完成为止的时间间隔组成作业在外存后备队列等待调度的时间高级调度进程在就绪队列等待进程调度的时间低级调度等待时间进程在上执行的时间运行时间进程等待操作完成的时间公式周转完成提交平均周转时间周转目标越短越好带权周转时间定义作业的周转时间与系统为其提供服务的时间之比公式周转运行等待运行运行等待运行意义越小说明作业在系统中等待的时间比例越小用户体验越好目标越小越好接近等待时间定义进程在就绪队列中等待调度的总时间注意调度算法只影响等待时间不影响进程的运行时间和时间目标越短越好响应时间定义从用户提交请求到系统首次产生响应输出第一个字符的时间场景交互式系统分时系统的核心指标公式响应首次响应提交指标图解进程生命周期与时间指标进程提交时刻等待调度首次被调度首次响应等待再次等待再次运行完成时刻指标度量响应时间周转时间等待时间运行时间响应时间提交首次运行响应等待时间灰色段总和仅计算就绪队列中的等待运行时间红色段总和周转时间提交完成带权周转不同系统的侧重点系统类型核心目标关注指标批处理系统吞吐量大周转时间短利用率高系统吞吐量周转时间利用率分时系统响应快均衡性响应时间关键均衡性响应时间与复杂性成比例实时系统截止时间保证可预测性满足截止时间快速处理中断进程切换模式切换上下文切换模式切换定义执行状态在用户态与内核态之间的切换触发系统调用中断异常内容仅需保存恢复少量寄存器到内核栈不改变地址空间页表基址寄存器不变开销较小注意模式切换是进程切换的前置条件但模式切换不一定导致进程切换如简单的系统调用返回进程切换定义从运行一个进程转为运行另一个进程触发调度程序决定抢占或主动放弃内容需保存完整上下文通用寄存器浮点寄存器页表基址地址空间开销较大显式开销隐式开销进程切换的详细步骤挂起当前进程保存上下文通用寄存器到当前进程的更新状态运行就绪阻塞并移入相应队列执行调度程序决定下一个要运行的进程恢复新进程更新新进程状态运行切换地址空间更新页表基址寄存器最昂贵的操作导致失效恢复上下文从新进程载入寄存器切换开销分析直接开销显式执行切换代码本身的指令保存恢复寄存器内核调度算法的执行时间间接开销隐式刷新切换地址空间导致快表全部失效后续访存变慢污染新进程的数据不在中导致冷启动模式切换用户态中断系统调用内核态进程切换进程保存上下文调度器恢复上下文切换页表进程可能触发调度算法调度算法可根据适用场景分为两类批处理系统追求吞吐量和交互式分时系统追求响应时间适用于批处理系统的算法先来先服务规则严格按照作业进程到达就绪队列的顺序进行服务抢占性非抢占优点算法简单公平对谁都一样缺点护航效应如果一个长作业密集型先到达后续的短作业密集型必须长时间等待导致平均等待时间剧增设备利用率低适用作业调度或作为优先级相同时的辅助规则短作业优先规则选择估计运行时间最短的进程变种非抢占式进程一旦运行直到完成或阻塞才释放抢占式最短剩余时间优先如果新到达进程的剩余时间当前运行进程的剩余时间则立即抢占优点理论上拥有最小的平均等待时间策略缺点饥饿现象如果短作业源源不断长作业可能永远得不到服务预估困难很难准确预知作业的运行时间依赖用户估计或历史统计高响应比优先规则每次调度计算响应比选择最高的进程综合了和的优点公式等待时间要求服务时间要求服务时间等待时间要求服务时间分析等待时间相同服务时间越短越高类服务时间相同等待时间越长越高类长作业随着等待时间增加逐渐增加最终会获得避免饥饿抢占性非抢占缺点每次调度都要重新计算所有进程的系统开销大适用于交互式系统的算法时间片轮转规则将时间划分为固定长度的时间片就绪队列按排序进程轮流执行一个时间片当进程执行完一个时间片后无论是否完成都必须释放并回到就绪队列的尾部抢占性抢占式时间片耗尽即抢占优点响应快公平没人能独占适用于交互式系统缺点进程切换开销大吞吐量受时间片大小影响较大关键点时间片的选择太大退化为响应变慢无法满足交互式系统的需求太小进程切换过于频繁上下文切换开销占比过高吞吐量下降经验值通常取切换开销应的影响因素时间片大小应根据系统的硬件性能进程数量进程类型等因素进行调整对于交互式系统应选择较小的时间片以提高响应速度对于批处理系统应选择较大的时间片以减少进程切换开销适用场景分时系统交互式通用操作系统优先级调度定义每个进程具有一个优先级选择优先级最高者运行抢占性可抢占非抢占抢占式在更高优先级进程到达唤醒时立即剥夺优先级来源静态优先级创建时确定系统进程用户进程交互型型计算型动态优先级随等待时间交互性密集度等变化饥饿与缓解问题低优先级进程可能长期得不到运行饥饿老化随等待时间提高优先级例如优先级反转与解决反转低优线程持有锁高优线程阻塞而中优线程持续运行高优实际被更低优压制优先级继承持锁者临时提升到被阻塞者的优先级直至释放锁优先级上限协议进入受控区前提升至该资源的上限优先级防止反转发生细节与约束同优先级进程采用或作为次级规则型与交互型进程常给予更高优先级以提升响应实时场景常结合固定优先级策略如与的动态优先级不同优先级反转高优线程请求共享资源锁低优线程持锁阻塞等待调度器中优线程抢占运行现象被阻塞持续运行反转优先级继承调度器提升优先级至临时升优运行并释放锁释放高优线程获得后运行多级反馈队列地位集大成者现代操作系统如调度算法的核心思想规则多级队列设置多个就绪队列优先级逐级降低最高时间片差异优先级越高的队列时间片越短最小优先级低的队列时间片长进程流动新进程进入若在时间片内未完成降级到队尾若在仍未完成降级到依次类推最低级队列通常采用或调度时机仅当高级队列为空时才调度的进程抢占若低级队列运行中有新进程进入高级队列则立即抢占策略细化惩罚进程用满时间片且未发生阻塞等待降级到下一队列尾部偏向计算密集型奖励进程时间片未用尽就因交互而阻塞或主动让权保持提升优先级偏向交互密集型周期性提升每隔固定周期将所有进程提升至较高队列常至以避免饥饿次级规则同队列内通常采用最低级队列为以降低调度开销优点短作业在快速完成极佳的响应时间长作业逐渐沉底到低级队列利用长时间片运行保证吞吐量自适应无需预知作业运行时间参数建议队列数常取层兼顾响应与开销时间片序列可按倍增设计如提升周期依据负载与交互性典型取亦可按时钟滴答数到达策略新到达进程置入突发交互任务能快速响应注意型进程倾向在高优队列循环奖励策略获得更好响应型进程随用满时间片逐级下降获得更长的连续运行时间多级反馈队列高优短时间片中优中时间片低优长时间片用满时间片用满时间片未用完未用完未用完周期性提升所有进程新进程到达进入算法可视化对比假设有三个进程到达服务到达服务到达服务调度算法对比标记到达到达到达非抢占非抢占抢占式运行抢占运行抢占运行续续续完成完成续完成非抢占完成完成抢占式运行运行完成续完成续完成等待最久护航效应插队到了前面到达时都发生了抢占最先完成被切分获得较快响应短任务在高优队列迅速完成长任务逐级下沉用更长时间片完成兼顾响应与吞吐初始仅随后按响应比选择顺序抢占式更高优先级到达立即抢占顺序完成完成完成算法特性对比速查算法抢占性优点缺点是否会导致饥饿适用场景否简单公平护航效应短作业等待长否批处理辅助调度否平均等待时间最短需预知时间是长作业理论研究是抢占式版本开销大需预知时间是理论研究否兼顾长短作业计算响应比开销大否批处理系统是响应快公平切换开销大否分时系统交互式否是灵活低优先级饥饿是实时系统多级反馈是集大成者算法复杂否现代通用多处理机调度基本模型非对称多处理将调度等集中在单个主处理器其他处理器仅执行用户进程实现简单但可扩展性差对称多处理每个处理器都运行相同的内核调度逻辑主流通用采用就绪队列结构全局就绪队列优点简单全局可见缺点大锁竞争迁移频繁导致缓存失效每就绪队列优点锁争用低提升缓存局部性缺点需要负载均衡迁移策略保持各队列均衡处理器亲和性软亲和优先让线程在上次运行的继续运行硬绑定将线程绑定到集仅在该集合内调度收益提升命中率降低迁移开销负载均衡与迁移工作窃取空闲从最繁忙队列尾部窃取任务推拉过载主动推送任务到空闲空闲主动拉取任务触发周期性时钟队列不平衡阈值线程唤醒时机考量原则尽量在本地节点运行跨节点迁移会引入远程内存访问开销策略首触发分配内存绑定跨节点均衡时优先同节点并行作业与协同调度调度将同一并行作业的线程在同一时间片内同时分配到多个降低同步等待与负载不均超线程核心插槽优先顺序先分散到不同物理核心再填充同核心的超线程最后跨插槽节点提升真实并行度与缓存局部性实践示例每运行队列按选择最小者运行分层均衡描述拓扑核心节点系统按层级周期均衡迁移决策综合亲和队列负载拓扑层级任务类型就绪队列就绪队列就绪队列新线程唤醒软亲和过载空闲优先本节点架构对比设计优点缺点适用场景全局就绪队列简单全局公平大锁争用迁移频繁缓存失效小规模系统教学演示每就绪队列争用低局部性好可扩展需周期均衡与迁移策略主流通用分层调度域贴合核心拓扑均衡精细复杂度高参数调优难现代多核多节点系统关键实现要点以为例负载度量平滑负载跟踪用于比较队列与任务负载容量感知随频率功耗状态变化调度按做公平与放置唤醒放置在唤醒创建时选择优先同节点同核心避免冷缓存与远程内存均衡类型空闲均衡空闲主动拉取任务低干扰主动均衡周期或阈值触发繁忙推送任务干扰较大迁移成本热度远程访问常以热度窗口约束频繁迁移时钟抑制在空闲核减少计时器中断均衡需兼顾唤醒路径与域层触发节点插槽核心线程线程核心线程唤醒软亲和同节点过载域均衡到空闲拉取任务使用虚线连接注释避免孤立节点容量感知频率影响公平同步与互斥同步与互斥的基本概念并发与竞态并发是同时推进竞态是结果依赖执行时序消除竞态需同步互斥临界资源一次仅允许一个执行实体使用的资源如打印机共享变量文件句柄临界区访问临界资源的代码片段进入与退出需遵循协议同步直接制约为满足因果时序关系而协作例如先生产后消费先初始化后使用互斥间接制约为避免同时进入临界区而竞争资源确保同一时刻仅一个执行实体访问注同步与互斥必须遵守的准则空闲让进互斥的铁律临界区空闲时应允许一个请求进入临界区的进程立即进入忙则等待互斥的铁律当已有进程在临界区时其他试图进入临界区的进程必须等待有限等待同步的铁律对请求访问的进程应保证能在有限时间内进入临界区防止死等饥饿让权等待加分项当进程不能进入临界区时应立即释放处理机防止进程处于忙等状态阻塞而非忙等非必须但推荐临界资源访问过程进入区发起进入临界区的协议阶段用于申请与等待共享资源的访问权常见做法是加锁或操作成功则进入临界区失败则自旋或入队阻塞等待该阶段应满足互斥公平与有限等待等准则避免优先级反转临界区真正访问共享数据或临界资源的代码片段该区域应尽量短小避免执行可能阻塞或耗时的操作降低持锁时间在此阶段维持数据不变式与一致性禁止并发访问导致竞态退出区释放访问权并进行必要的状态更新与唤醒通知典型操作为解锁或操作并根据策略唤醒等待队列中的下一线程如优先级唤醒公平唤醒以防饥饿并提升系统吞吐剩余区非临界工作阶段不需要访问共享数据或临界资源适合执行计算准备下一次进入区的输入等将耗时工作放在剩余区有助于缩短持锁时长提升并发效率进入区申请互斥锁原语失败则等待临界区访问共享数据资源尽量缩短持锁时间退出区释放互斥并唤醒等待者若有剩余区非共享工作准备下一次进入区进入区申请互斥信号量失败则阻塞入队临界区访问临界资源退出区释放互斥并唤醒一个等待者剩余区不涉及共享资源的工作非临界区尝试获取互斥锁成功进入临界区释放互斥锁失败等待阻塞队列生产者消费者同步原语同步确保先生产后消费提供数据消费数据实现临界区互斥的基本方法软件实现单标志法通过单一标志变量指示允许进入者简单但无法同时保证互斥进度与有限等待易饥饿在多核与编译器优化下不可靠允许进入的轮次无法保证互斥与有限等待仅示意切换轮次给允许进入的轮次仍可能饥饿破坏互斥切换轮次给双标志先检查先检查对方是否想进入再决定是否进入存在竞态窗口导致双方同时进入破坏互斥冲突时缺少公平与退避策略易活锁饥饿先检查对方是否想进入再声明意愿有竞态窗口可能双方同时进入破坏互斥退出后清除意愿先检查对方后声明意愿存在竞态不保证互斥公平退出清意愿双标志后检查先声明意愿再检查对方较稳健但仍需协商避免活锁与饥饿难以严格保证有限等待先声明意愿后检查对方意愿忙等仍可能饥饿活锁缺公平退出清意愿声明意愿忙等对方清除意愿不保证有限等待退出清意愿算法两线程互斥的经典方案借助协商让权可证明互斥进度有限等待与让权等待成立弱内存模型需配合屏障扩展到多线程复杂度高声明想进入让权给冲突时优先若也想进且轮到则等待进入临界区保证互斥有限等待退出清意愿声明想进入让权给冲突时等待进入临界区退出清意愿硬件实现中断屏蔽通过关中断指令禁止响应中断从而防止进程切换保证临界区代码的原子性执行原理只有在发生中断时才可能进行进程调度进入临界区前执行关中断退出后执行开中断优点简单高效缺点不适用于多处理器关中断仅对当前有效无法防止其他上的进程进入临界区安全性若允许用户进程使用可能导致系统挂起忘记开中断通常仅限于内核态使用指令硬件提供的原子指令用于读取并设置内存值也称为指令逻辑原子操作伪代码描述硬件逻辑读出旧值写入返回旧值实现互斥共享锁变量自旋若原为则循环若为则设为并退出循环退出区释放锁特点优点适用于多处理器环境代码简单支持多个临界区缺点忙等待消耗时间可能导致饥饿可能导致死锁若低优先级进程持有锁而被高优先级抢占指令硬件提供的原子交换两个变量值的指令指令逻辑原子操作伪代码描述硬件逻辑交换和的内容实现互斥全局锁局部变量初始化为原子交换若为则变为退出循环退出区释放锁特点与指令类似属于忙等待机制需要硬件支持互斥锁互斥锁是一种用于多线程多进程编程中防止多条线程同时对同一公共资源进行读写的机制基本操作或获得锁若锁不可用则阻塞或忙等待或释放锁两种实现形态自旋锁机制忙等待进程不断循环检测锁的状态直到获取锁适用预计等待时间很短且运行在多核上避免上下文切换开销缺点若持有锁的线程被抢占或阻塞等待线程会白白浪费阻塞锁机制睡眠等待若无法获取锁进程调用让出并进入阻塞队列等待被适用临界区较长或单核环境缺点涉及进程上下文切换开销较大伪代码示例自旋锁实现需配合硬件原子指令如使用循环检测直到原值为释放锁信号量由提出的有效进程同步机制信号量是一个整数变量除了初始化外只能通过两个标准原子操作操作和操作来访问操作来自荷兰语意为测试功能申请资源逻辑上若则分配资源减若则进程需要等待忙等或阻塞直到有可用资源操作来自荷兰语意为增加功能释放资源逻辑上加并可能需要唤醒一个正在等待该资源的进程整型信号量用一个整数型变量作为信号量表示系统中某种资源的数量机制只要就不断测试自旋忙等若则代码示例假设操作是原子的忙等待若资源不足一直循环测试资源充足消耗一个资源释放资源缺点未遵循让权等待原则存在忙等待现象记录型信号量为了解决忙等待问题在信号量中增加一个进程链表用于链接所有等待该资源的阻塞进程数据结构资源剩余数量等待队列阻塞队列操作申请资源加入等待队列自我阻塞放弃含义减表示申请一个资源若减后表示无资源进程需阻塞等待此时表示等待队列中的进程数操作释放资源从队列移出进程唤醒进程含义加表示释放一个资源若加后表示队列中仍有等待进程需唤醒一个信号量的应用实现进程互斥用于多个进程互斥地访问临界资源原则设互斥信号量初始值为表示有一个可用资源将临界区代码置于和之间必须成对使用且不能颠倒顺序代码示例申请进入临界区加锁退出临界区解锁若已进入阻塞等待实现进程同步用于协调进程间的执行顺序实现一前一后的约束原则设同步信号量初始值为表示前操作尚未完成前操作先执行之后执行释放信号后操作后执行之前执行等待信号口诀前后代码示例前操作发送信号已完成等待信号等待完成后操作实现前趋关系用于描述复杂的进程执行顺序有向无环图原理为每一对前趋关系每一条有向边设置一个同步信号量初值为示例设任务顺序为需要个信号量前趋图代码结构完成后通知可开始等完成后通知等完成后通知等都完成开始经典同步问题生产者消费者问题问题描述一组生产者进程和一组消费者进程共享一个初始为空大小为的缓冲区生产者生产数据放入缓冲区若缓冲区满则阻塞消费者从缓冲区取数据消费若缓冲区空则阻塞互斥缓冲区是临界资源需互斥访问信号量设置实现对缓冲区的互斥访问同步信号量表示空闲缓冲区的数量同步信号量表示非空缓冲区的数量产品数量代码示例申请空闲位若无空位则阻塞申请互斥锁放入缓冲区释放互斥锁增加产品数唤醒消费者申请产品若无产品则阻塞申请互斥锁取出产品释放互斥锁增加空闲位唤醒生产者注意和顺序不能颠倒否则可能导致死锁持有锁等待资源读者写者问题问题描述多个进程共享一个数据区读读允许同时访问读写互斥写写互斥信号量设置用于实现对文件的互斥访问写锁用于保护变量的互斥访问记录当前读者数量代码示例读者优先申请写锁若有读者或写者则阻塞释放写锁保护第一个读者负责申请写锁阻断写者最后一个读者负责释放写锁哲学家进餐问题问题描述由提出是解决进程同步问题的经典案例名哲学家围坐在一张圆桌旁桌上有支筷子每两个哲学家中间有一支哲学家的生活思考饥饿进餐思考规则哲学家进餐时必须同时拿到自己左手边和右手边的两支筷子进餐完毕后放下筷子继续思考关键问题死锁如果名哲学家同时饥饿并且都同时拿起了左手边的筷子那么他们都会等待右手边的筷子导致所有人都被阻塞形成环路等待发生死锁饥饿在某些策略下某个哲学家可能长期无法凑齐两支筷子而无法进餐解决方案限制最多允许人同时进餐原理破坏死锁产生的必要条件循环等待个位置只允许个人同时抢筷子根据抽屉原理至少有人能拿到支筷子从而进餐并释放资源代码示例限制最多人同时请求进餐思考申请进餐名额若已满人则阻塞拿左筷子拿右筷子进餐放右筷子放左筷子释放进餐名额解决方案奇偶分层破坏循环等待原理规定奇数号哲学家先拿左筷子再拿右筷子偶数号哲学家先拿右筷子再拿左筷子这样相邻的哲学家会竞争同一支筷子例如号和号会先竞争筷子从而打破环状等待链代码示例奇数号先左后右左右偶数号先右后左右左解决方案信号量原子取锁原理将拿起左右两支筷子作为一个原子操作只有当左右两支筷子都可用时才一次性全部拿起否则一支都不拿这直接破坏了请求和保持条件伪代码假设系统提供原语可同时申请两个信号量同时申请左右筷子同时释放吸烟者问题问题描述系统包含个供应者和个吸烟者种材料烟草纸胶水吸烟者需求有烟草缺纸胶水有纸缺烟草胶水有胶水缺烟草纸供应者行为无限供应每次随机将两种材料放在桌上然后等待吸烟者拿走并吸完再放下一轮问题分析这是一个典型的同步问题供应者和吸烟者之间存在直接的生产消费关系关键点供应者提供的虽然是两种材料但实际上可以看作是提供给某一个特定吸烟者的信号提供纸胶水唤醒他有烟草提供烟草胶水唤醒他有纸提供烟草纸唤醒他有胶水死锁风险如果用个信号量分别代表种材料可能会导致死锁例如桌上有烟草和纸拿了烟草拿了纸结果谁都凑不齐因此应该将材料组合抽象为事件信号信号量设置代表桌上有组合纸胶水唤醒代表桌上有组合烟草胶水唤醒代表桌上有组合烟草纸唤醒表示吸烟者已完成吸烟桌子变空通知供应者放下一轮代码示例对应的需求对应的需求对应的需求只有或也可以看作互斥变量供应者进程放纸胶水唤醒放烟草胶水唤醒放烟草纸唤醒等待吸烟者吸完吸烟者有烟草缺纸胶水等待纸胶水组合拿走材料卷烟抽掉通知供应者继续吸烟者有纸缺烟草胶水吸烟者有胶水缺烟草纸管程背景信号量机制虽然功能强大但编程困难且容易出错例如操作顺序错误可能导致死锁为了简化同步控制和提出了管程机制定义一种高级同步机制它封装了共享数据结构对该数据结构的一组操作过程以及初始化代码本质抽象数据类型的一种特例专门用于并发编程基本特征模块化将共享资源及其操作封装在一个模块中信息隐藏管程外的进程无法直接访问管程内的共享数据只能通过调用管程提供的公共过程来访问自动互斥管程由编译器语言层面负责实现互斥任一时刻最多只能有一个进程在管程中执行其他试图进入管程的进程将被阻塞在入口等待队列条件变量管程虽然自动实现了互斥但为了解决同步问题如缓冲区满时需要等待引入了条件变量定义条件变量当条件不满足时进程调用此操作该进程会释放管程锁并阻塞在的等待队列中唤醒一个阻塞在等待队列中的进程若没有进程在等待则该操作无任何效果注意这与信号量的操作不同信号量会累加计数代码示例管程解决生产者消费者问题共享数据计数器条件变量缓冲区不满条件变量缓冲区不空生产者放入数据缓冲区满等待不满信号释放锁并阻塞放入数据放入数据后缓冲区肯定不空唤醒等待不空的消费者消费者取出数据缓冲区空等待不空信号释放锁并阻塞取出数据取出数据后缓冲区肯定不满唤醒等待不满的生产者优势程序员无需手动编写互斥锁代码操作只需关注业务逻辑和同步条件大大降低了死锁风险和编程难度现实应用的关键字机制就是管程概念的经典实现死锁死锁的概念定义多个进程因竞争不可剥夺资源或协同推进顺序非法而造成的一种僵局若无外力作用这些进程都无法向前推进死锁饥饿活锁死锁涉及的进程都阻塞等待永远不会发生的事件互相持有对方需要的资源饥饿进程长时间得不到资源如优先级调度中的低优先级进程进程可能处于就绪态长期得不到时间阻塞态等待资源如操作活锁进程未被阻塞但由于互相礼让或状态不断改变导致无法推进如两个人在窄巷相遇互相避让死锁产生的原因系统资源的竞争系统中不可剥夺的资源数量不足以满足多个进程的需求导致进程争夺资源而陷入僵局进程推进顺序非法进程在运行过程中请求和释放资源的顺序不当如占有请求占有请求死锁产生的四个必要条件缺一不可互斥条件资源是独占的同一时刻只能由一个进程使用不剥夺条件进程获得的资源在未使用完之前不能被其他进程强行夺走只能主动释放请求和保持条件进程已经保持了至少一个资源但又提出了新的资源请求而该资源已被其他进程占有循环等待条件存在一个进程资源的循环等待链链中每一个进程已获得的资源同时被下一个进程所请求死锁处理策略策略原理优点缺点死锁预防破坏四个必要条件之一实现简单资源利用率低甚至不可行死锁避免在分配资源前判断安全性资源利用率较高实现复杂需预知最大需求死锁检测与解除允许死锁发生定期检测并恢复资源利用率高检测有开销恢复代价大死锁忽略鸵鸟策略简单适合死锁概率极低的系统发生死锁需人工干预重启死锁预防通过限制资源请求破坏四个必要条件之一互斥条件一般无法破坏破坏不剥夺条件策略当进程请求新资源得不到满足时必须释放已保持的所有资源待以后重新申请缺点实现复杂反复申请释放增加系统开销可能导致饥饿破坏请求和保持条件策略一静态分配进程在运行前一次性申请完所有需要的资源若满足则运行否则等待策略二允许进程只获得运行初期需要的资源但在请求新资源前必须释放当前拥有的所有资源缺点资源严重浪费有些资源可能很久才用进程可能饥饿个别资源长期被占用导致无法凑齐所有资源破坏循环等待条件策略顺序资源分配法给系统所有资源编号规定进程只能按编号递增的顺序请求资源缺点限制了新设备增加限制了用户编程自主性死锁避免银行家算法在资源动态分配过程中用某种方法防止系统进入不安全状态安全状态系统能按某种进程顺序为每个进程分配资源直至满足每个进程的最大需求使每个进程都能顺利完成这个序列称为安全序列不安全状态找不到安全序列不安全状态死锁但死锁一定处于不安全状态银行家算法提出核心思想是在分配资源前先预演若分配后系统处于安全状态则分配否则暂不分配注银行家算法属于死锁避免它并不破坏四个必要条件中的任何一个而是通过在每次资源分配前进行安全性检查避免系统进入不安全状态从而规避死锁与之对比死锁预防是通过事先设计策略去破坏请求和保持不剥夺循环等待等条件来保证系统永不形成死锁对于单类资源系统有个同类资源个进程设进程的最大需求为系统不发生死锁的充要条件若每进程最大需求相同为则等价为结论最大需求量之和必须严格小于即数据结构假设系统有个进程类资源可利用资源向量表示第类资源现有个最大需求矩阵表示进程需要第类资源的最大数量为分配矩阵表示进程当前已获得第类资源个需求矩阵表示进程还需要第类资源个关系算法流程资源请求算法设是进程的请求向量检查请求合法性若转向步骤否则出错请求超过宣布的最大需求检查资源可用性若转向步骤否则等待尚无足够资源试探性分配系统试探着把资源分配给进程并修改数据结构安全性检查执行安全性算法若系统安全则正式分配资源给若系统不安全则撤销试探分配恢复原数据结构阻塞等待进程数量资源种类数量全局变量系统状态可用资源最大需求已分配尚需辅助函数向量比较辅助函数向量加法辅助函数向量减法安全性算法核心初始化寻找一个尚未完成且需求当前可用资源的进程模拟进程执行完成并释放资源找不到下一个可执行进程不安全所有进程都能执行完成系统安全资源请求算法步骤检查请求是否合法步骤检查是否有足够资源步骤试探性分配步骤安全性检查分配成功恢复原状回滚死锁检测和解除允许死锁发生但系统会定时运行检测算法一旦发现死锁就采取措施解除死锁检测资源分配图节点进程节点圆圈资源节点方框边请求边进程请求资源分配边资源已分配给已分配请求已分配请求死锁定理如果资源分配图是不可完全简化的即图中存在无法消除的环则系统发生了死锁状态找出既不阻塞又非独立的进程能获得所有请求资源使其运行并释放所有资源消去边重复此过程若能消去所有边则图是可完全简化的无死锁检测算法类似于银行家算法的安全性检查但使用当前请求而非若找不到一个安全序列所有进程都能则剩余未的进程处于死锁状态死锁解除一旦检测到死锁需打破循环等待资源剥夺法挂起某些死锁进程抢占其资源分配给其他死锁进程需防止被挂起的进程长时间饥饿撤销终止进程法终止所有死锁进程代价大前功尽弃逐个终止进程直至死锁循环被打破选择策略优先级最低已运行时间最短剩余时间最长占用资源最多交互式进程优先等进程回退法让一个或多个进程回退到足以避免死锁的地步如回退到检查点系统需建立检查点机制记录进程状态',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-06 19:37:56',
  postMainColor: '#ff7096',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/sparkle520?tab=repositories" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">SPARKLE</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size: 1.05rem;">408<sup>10</sup></a><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Deep-Learning/" style="font-size: 1.05rem;">Deep Learning<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/JSR303/" style="font-size: 1.05rem;">JSR303<sup>1</sup></a><a href="/tags/Matplotlib/" style="font-size: 1.05rem;">Matplotlib<sup>3</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c#<sup>2</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>4</sup></a><a href="/tags/npc%E5%88%86%E6%9E%90%E6%B3%95/" style="font-size: 1.05rem;">npc分析法<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>5</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>1</sup></a><a href="/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/" style="font-size: 1.05rem;">二次型<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%82/" style="font-size: 1.05rem;">你的名字。<sup>3</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">你的名字同名小说<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%A4%96%E4%BC%A0%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">你的名字外传小说<sup>1</sup></a><a href="/tags/%E5%80%92%E8%A3%85%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">倒装结构<sup>1</sup></a><a href="/tags/%E5%86%99%E4%BD%9C/" style="font-size: 1.05rem;">写作<sup>4</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">包管理<sup>1</sup></a><a href="/tags/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/" style="font-size: 1.05rem;">卷积公式<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/" style="font-size: 1.05rem;">天气之子<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">天气之子同名小说<sup>1</sup></a><a href="/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/" style="font-size: 1.05rem;">定积分<sup>1</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">小说<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" style="font-size: 1.05rem;">数据校验<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 1.05rem;">概率论<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" style="font-size: 1.05rem;">概率论与数理统计<sup>7</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.05rem;">汇编<sup>9</sup></a><a href="/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" style="font-size: 1.05rem;">泰勒展开<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%80%BC/" style="font-size: 1.05rem;">特征值<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" style="font-size: 1.05rem;">特征向量<sup>1</sup></a><a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 1.05rem;">线性代数<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/" style="font-size: 1.05rem;">英语听力<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 1.05rem;">英语语法<sup>16</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">计算机组成原理<sup>6</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/" style="font-size: 1.05rem;">词根词缀<sup>1</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" style="font-size: 1.05rem;">高等代数<sup>2</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">高等数学<sup>9</sup></a><a href="/tags/%E9%AB%98%E9%A2%91%E8%AF%8D%E7%BB%84/" style="font-size: 1.05rem;">高频词组<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/02/"><span class="card-archive-list-date">二月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/01/"><span class="card-archive-list-date">一月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">十二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url">计算机</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>操作系统</span></a><a class="article-meta__tags" href="/tags/408/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>408</span></a></span></div></div><h1 class="post-title" itemprop="name headline">408-操作系统-2-进程与线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-12-23T15:00:27.000Z" title="发表于 2025-12-23 23:00:27">2025-12-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2026-01-06T11:37:56.627Z" title="更新于 2026-01-06 19:37:56">2026-01-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">24.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="408-操作系统-2-进程与线程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为系守镇"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>系守镇</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic1.imgdb.cn/item/69492ebfc154427986d9c262.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"><header><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url">计算机</a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">操作系统</a><a href="/tags/408/" tabindex="-1" itemprop="url">408</a><h1 id="CrawlerTitle" itemprop="name headline">408-操作系统-2-进程与线程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">sparkle520</span><time itemprop="dateCreated datePublished" datetime="2025-12-23T15:00:27.000Z" title="发表于 2025-12-23 23:00:27">2025-12-23</time><time itemprop="dateCreated datePublished" datetime="2026-01-06T11:37:56.627Z" title="更新于 2026-01-06 19:37:56">2026-01-06</time></header><h1 id="第2章-进程与线程">第2章 进程与线程</h1>
<h2 id="进程与线程">2.1 进程与线程</h2>
<h3 id="进程的概念和特征">2.1.1 进程的概念和特征</h3>
<ol type="1">
<li><strong>定义</strong> : 进程 ( Process )
是计算机中的程序关于某数据集合上的一次运行活动，是系统进行
<strong>资源分配</strong> 和 <strong>调度</strong> 的基本单位.</li>
<li><strong>特征</strong> :
<ul>
<li><strong>动态性</strong> : 进程是程序的一次执行过程，有生命周期 (
最基本特征 ).</li>
<li><strong>并发性</strong> : 多个进程可以同时间隔执行.</li>
<li><strong>独立性</strong> :
进程是能独立运行、独立获得资源、独立调度的基本单位.</li>
<li><strong>异步性</strong> :
进程按各自独立的、不可预知的速度向前推进.</li>
<li><strong>结构性</strong> : 每个进程都有一个进程控制块 ( PCB ).</li>
</ul></li>
</ol>
<h3 id="进程的组成">2.1.2 进程的组成</h3>
<p>进程实体 ( 进程映像 ) 由以下三部分组成 :</p>
<ol type="1">
<li><strong>进程控制块 ( PCB )</strong> : 存放进程管理和控制信息 (
如PID, 状态, 优先级, 寄存器值 ).<strong>PCB
是进程存在的唯一标志</strong>.</li>
<li><strong>程序段</strong> : 存放要执行的代码.</li>
<li><strong>数据段</strong> :
存放程序运行期间处理的原始数据和中间结果.</li>
</ol>
<h4 id="程序段的共享与复用-多进程调用">程序段的共享与复用 ( 多进程调用
)</h4>
<ul>
<li><strong>可重入/纯代码段共享</strong> : 程序的 <strong>代码段 ( Text
Segment )</strong> 是只读且可重入的，多个进程可以通过页表
<strong>映射到同一组物理代码页</strong>，从而节省内存并提高指令缓存命中率.</li>
<li><strong>写时复制 ( Copy-On-Write, COW )</strong> : 在
<code>fork</code> 之后，父子进程最初 <strong>共享</strong>
相同的代码页和数据页; 当某一方尝试写入数据页时，触发
<strong>COW</strong>，内核复制一份私有副本并将其页表改为可写，保证相互隔离.</li>
<li><strong>动态链接库共享</strong> : 动态库 (
<code>.so</code>/<code>.dll</code> ) 的 <strong>代码页</strong>
在多个进程之间共享加载; 每个进程拥有该库的 <strong>私有数据</strong>
和重定位信息.</li>
<li><strong>内存映射机制</strong> : 通过
<code>mmap</code>/节段装入，将同一二进制的代码文件 <strong>映射</strong>
至不同进程的地址空间，实现 <strong>按需调页</strong> 与共享.</li>
<li><strong>隔离边界</strong> : 进程之间只共享
<strong>只读代码页</strong>;
<strong>数据段/堆/栈/打开文件表/PCB</strong>
等均为进程私有，彼此隔离与保护.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef proc fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef code fill:#22D3EE,stroke:#0E7490,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef data fill:#F59E0B,stroke:#B45309,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef phys fill:#94A3B8,stroke:#475569,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    P1[&quot;进程1&lt;br&#x2F;&gt;地址空间&quot;]:::proc --&gt; C[&quot;代码段&lt;br&#x2F;&gt;( 共享 )&quot;]:::code
    P2[&quot;进程2&lt;br&#x2F;&gt;地址空间&quot;]:::proc --&gt; C
    P1 --&gt; D1[&quot;数据段&#x2F;堆&#x2F;栈&lt;br&#x2F;&gt;( 私有 )&quot;]:::data
    P2 --&gt; D2[&quot;数据段&#x2F;堆&#x2F;栈&lt;br&#x2F;&gt;( 私有 )&quot;]:::data
    C --&gt; PF[&quot;物理页帧&lt;br&#x2F;&gt;( 只读 )&quot;]:::phys
  </pre></div>
<h4 id="pcb-详解">PCB 详解</h4>
<ul>
<li><strong>概念</strong> : 进程控制块 ( Process Control Block, PCB )
是操作系统用于管理进程的
<strong>数据结构</strong>，记录进程的一切关键信息，是进程存在的
<strong>唯一标志</strong>. 操作系统通过 <strong>查找/修改 PCB</strong>
来完成创建、撤销、调度、阻塞/唤醒等控制操作.</li>
<li><strong>典型内容</strong> :
<ol type="1">
<li><strong>标识与描述信息</strong> : 进程标识符
<strong>PID</strong>、所属用户/组、父进程
<strong>PPID</strong>、会话/作业号等.</li>
<li><strong>处理机现场/上下文信息</strong> : 通用寄存器值、程序计数器
<strong>PC</strong>、程序状态字 <strong>PSW</strong>、栈指针
<strong>SP</strong> 等，用于
<strong>进程切换时的现场保存与恢复</strong>.</li>
<li><strong>进程控制与调度信息</strong> : 当前 <strong>状态</strong> (
就绪/运行/阻塞/挂起等
)、<strong>优先级</strong>、时间片、调度所需统计量、就绪/阻塞队列的
<strong>链接指针</strong>.</li>
<li><strong>资源分配信息</strong> : 地址空间描述 ( 页表/段表基址
)、打开文件表/文件描述符、所占用的 <strong>I/O
设备</strong>、通信端口、信号/信号量等.</li>
<li><strong>记账与统计信息</strong> : 累计 CPU
时间、创建/开始时间、页面错误计数、系统调用计数等.</li>
</ol></li>
<li><strong>组织方式</strong> : 操作系统通常将 PCB 以
<strong>链表/队列</strong> 方式组织，例如就绪队列、阻塞队列; 每个 PCB
通过指针域连接在对应队列上，调度器据此选择下一个要运行的进程.</li>
<li><strong>进程切换与 PCB</strong> : 当发生 <strong>调度或中断</strong>
时，系统将当前进程的现场写入其 PCB; 再从被选中的进程
<strong>PCB</strong> 中恢复现场，继续其执行.</li>
<li><strong>生命周期与位置</strong> : PCB 在 <strong>创建进程</strong>
时分配并初始化，在进程 <strong>终止</strong> 后回收;
出于安全考虑，PCB通常位于
<strong>内核空间</strong>，用户态不可直接访问.</li>
<li><strong>与线程的关系</strong> : 线程是调度单位，拥有
<strong>线程控制块 ( TCB )</strong>; 多个线程共享同一进程的
<strong>PCB/地址空间/打开文件</strong> 等资源.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef pcb fill:#22D3EE,stroke:#0E7490,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef queue fill:#F8FAFC,stroke:#94A3B8,stroke-width:2px,color:#475569,rx:5,ry:5;
    classDef run fill:#22C55E,stroke:#15803D,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    subgraph ReadyQ[&quot;就绪队列&quot;]
      direction TB
      R1[&quot;PCB: PID&#x3D;101&lt;br&#x2F;&gt;状态&#x3D;就绪&quot;]:::pcb
      R2[&quot;PCB: PID&#x3D;102&lt;br&#x2F;&gt;状态&#x3D;就绪&quot;]:::pcb
    end
    subgraph BlockQ[&quot;阻塞队列&quot;]
      direction TB
      B1[&quot;PCB: PID&#x3D;201&lt;br&#x2F;&gt;原因&#x3D;I&#x2F;O等待&quot;]:::pcb
      B2[&quot;PCB: PID&#x3D;202&lt;br&#x2F;&gt;原因&#x3D;信号量&quot;]:::pcb
    end
    CPU[&quot;CPU ( 运行中 )&quot;]:::run

    ReadyQ --&gt;|&quot;调度&#x2F;分派&quot;| CPU
    CPU --&gt;|&quot;运行-&gt;阻塞&quot;| BlockQ
    BlockQ --&gt;|&quot;事件完成-&gt;就绪&quot;| ReadyQ
  </pre></div>
<h3 id="进程的状态与转换">2.1.3 进程的状态与转换</h3>
<h4 id="状态定义">状态定义</h4>
<ol type="1">
<li><strong>运行态 ( Running )</strong> : 获得 CPU，正在执行指令.</li>
<li><strong>就绪态 ( Ready )</strong> : 具备运行条件，等待 <strong>CPU
分配</strong>.</li>
<li><strong>阻塞态 ( Blocked/Waiting )</strong> : 因
<strong>I/O/资源/事件</strong> 未就绪而暂停执行.</li>
<li><strong>创建态 ( New )</strong> :
进程被创建、加载必要信息，尚未进入就绪队列.</li>
<li><strong>终止态 ( Terminated )</strong> :
进程执行结束或被撤销，等待系统回收资源.</li>
</ol>
<h4 id="扩展状态">扩展状态</h4>
<ol type="1">
<li><strong>挂起就绪 ( Suspended Ready )</strong> : 进程暂时换出到外存 (
如内存紧张 )，当前不在就绪队列，激活后回到就绪.</li>
<li><strong>挂起阻塞 ( Suspended Blocked )</strong> :
进程既在等待事件，又被换出到外存，事件完成且被激活后回到就绪.</li>
</ol>
<h4 id="典型触发与转换">典型触发与转换</h4>
<ul>
<li><strong>就绪 -&gt; 运行</strong> : 被调度/分派获得 CPU.</li>
<li><strong>运行 -&gt; 就绪</strong> : 时间片用完或被高优先级抢占.</li>
<li><strong>运行 -&gt; 阻塞</strong> : 主动请求
I/O、等待锁/信号量/资源.</li>
<li><strong>阻塞 -&gt; 就绪</strong> : I/O 完成、资源到达、被唤醒.</li>
<li><strong>就绪/阻塞 -&gt; 挂起就绪/挂起阻塞</strong> :
中级调度对换到外存 ( 内存回收 ).</li>
<li><strong>挂起就绪/挂起阻塞 -&gt; 就绪</strong> : 被激活 ( 换入内存
)，阻塞条件消失后可就绪.</li>
<li><strong>运行 -&gt; 终止</strong> : 正常结束或异常被系统撤销.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef new fill:#A7F3D0,stroke:#065F46,stroke-width:2px,color:#065F46,rx:5,ry:5;
    classDef ready fill:#93C5FD,stroke:#1D4ED8,stroke-width:2px,color:#1E3A8A,rx:5,ry:5;
    classDef run fill:#22C55E,stroke:#15803D,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef block fill:#F59E0B,stroke:#B45309,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef susp fill:#FDE68A,stroke:#CA8A04,stroke-width:2px,color:#7C2D12,rx:5,ry:5;
    classDef term fill:#EF4444,stroke:#B91C1C,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    New[&quot;创建 ( New )&quot;]:::new --&gt; Ready[&quot;就绪 ( Ready )&quot;]:::ready
    Ready --&gt;|&quot;调度&#x2F;分派&quot;| Running[&quot;运行 ( Running )&quot;]:::run
    Running --&gt;|&quot;时间片用完&lt;br&#x2F;&gt;&#x2F;抢占&quot;| Ready
    Running --&gt;|&quot;I&#x2F;O&lt;br&#x2F;&gt;&#x2F;等待资源&quot;| Blocked[&quot;阻塞 ( Blocked )&quot;]:::block
    Blocked --&gt;|&quot;事件完成&quot;| Ready
    Ready --&gt;|&quot;挂起&quot;| SuspReady[&quot;挂起就绪&lt;br&#x2F;&gt;( Suspended Ready )&quot;]:::susp
    Blocked --&gt;|&quot;挂起&quot;| SuspBlocked[&quot;挂起阻塞&lt;br&#x2F;&gt;( Suspended Blocked )&quot;]:::susp
    SuspReady --&gt;|&quot;激活&quot;| Ready
    SuspBlocked --&gt;|&quot;事件完成-&gt;激活&quot;| Ready
    Running --&gt;|&quot;结束&quot;| Terminated[&quot;终止 ( Terminated )&quot;]:::term
  </pre></div>
<h3 id="进程控制">2.1.4 进程控制</h3>
<h4 id="核心概念">核心概念</h4>
<ul>
<li>进程控制由 <strong>原语 ( Primitive )</strong> 完成，包含
<strong>创建、终止、阻塞、唤醒、挂起/激活、切换</strong> 等操作，均具有
<strong>原子性</strong> ( 执行期间不可被中断 ).</li>
<li>相关实体 : <strong>调度器</strong> ( 决定哪个进程运行 )
、<strong>分派程序</strong> ( 执行上下文切换 ) 、<strong>PCB</strong> (
记录进程状态与现场 ) 、<strong>就绪/阻塞队列</strong> ( 组织进程 ).</li>
</ul>
<h4 id="基本原语与典型步骤">基本原语与典型步骤</h4>
<ol type="1">
<li><strong>创建 ( Create )</strong> :
<ul>
<li>申请并初始化 <strong>PCB</strong>，分配唯一
<strong>PID</strong>.</li>
<li>建立或继承地址空间，装入 <strong>程序段</strong>，初始化
<strong>数据段/栈</strong>.</li>
<li>初始化现场 ( 寄存器、PC、PSW )，置
<strong>状态=就绪</strong>，插入就绪队列.</li>
<li>典型接口 : <code>fork</code> ( 复制父进程，常用写时复制 COW )
、<code>exec</code> ( 用新程序映像替换当前进程 ).</li>
</ul></li>
<li><strong>终止 ( Exit )</strong> :
<ul>
<li>从队列中移出，释放资源 ( 内存、I/O、文件句柄 )，撤销 PCB.</li>
<li>与父子关系 : 子进程终止后进入 <strong>僵尸态</strong>，父进程通过
<code>wait</code>/<code>waitpid</code> 回收退出码与内核表项;
孤儿进程由系统进程领养并回收.</li>
</ul></li>
<li><strong>阻塞 ( Block )</strong> :
<ul>
<li>触发条件 : 请求 <strong>I/O/锁/信号量/事件</strong>
等资源未就绪.</li>
<li>步骤 : 保存现场 → 置 <strong>状态=阻塞</strong> →
按阻塞原因挂入阻塞队列 → 触发调度.</li>
</ul></li>
<li><strong>唤醒 ( Wakeup )</strong> :
<ul>
<li>触发条件 : I/O 完成、资源到达、信号唤醒等.</li>
<li>步骤 : 从阻塞队列取出 → 置 <strong>状态=就绪</strong> →
插入就绪队列.</li>
</ul></li>
<li><strong>挂起/激活 ( Suspend/Resume )</strong> :
<ul>
<li>中级调度为了回收内存将进程 <strong>对换到外存</strong>，形成
<strong>挂起就绪/挂起阻塞</strong>; 被激活后换入内存并回到就绪.</li>
</ul></li>
<li><strong>进程切换 ( Context Switch )</strong> :
<ul>
<li>保存当前进程现场到 PCB :
通用寄存器、<code>PC</code>、<code>PSW</code>、<code>SP</code>、页表寄存器等.</li>
<li>更新当前进程指针，恢复新进程现场，切换地址空间与内核栈，返回新进程
<code>PC</code> 处继续执行.</li>
</ul></li>
</ol>
<h4 id="约束与策略">约束与策略</h4>
<ul>
<li><strong>原子性与临界区</strong> : 原语执行期间
<strong>关中断</strong> 或使用硬件指令确保不可分割.</li>
<li><strong>优先级与时间片</strong> :
支持动态优先级、老化策略，时间片耗尽导致
<strong>运行-&gt;就绪</strong>.</li>
<li><strong>资源与引用计数</strong> :
打开文件表、内存页框、信号量等使用引用计数以支持共享与安全回收.</li>
<li><strong>信号/异常处理</strong> :
异步事件可能导致阻塞/唤醒/终止等状态变化.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef state fill:#93C5FD,stroke:#1D4ED8,stroke-width:2px,color:#1E3A8A,rx:5,ry:5;
    classDef run fill:#22C55E,stroke:#15803D,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef block fill:#F59E0B,stroke:#B45309,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef susp fill:#FDE68A,stroke:#CA8A04,stroke-width:2px,color:#7C2D12,rx:5,ry:5;
    classDef term fill:#EF4444,stroke:#B91C1C,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    Create[&quot;创建 ( Create )&quot;]:::state --&gt; ReadyC[&quot;就绪 ( Ready )&quot;]:::state
    ReadyC --&gt;|&quot;分派 ( Dispatch )&quot;| RunC[&quot;运行 ( Running )&quot;]:::run
    RunC --&gt;|&quot;时间片用完&lt;br&#x2F;&gt;&#x2F;抢占&quot;| ReadyC
    RunC --&gt;|&quot;阻塞 ( Block )&quot;| BlockC[&quot;阻塞 ( Blocked )&quot;]:::block
    BlockC --&gt;|&quot;唤醒 ( Wakeup )&quot;| ReadyC
    ReadyC --&gt;|&quot;挂起 ( Suspend )&quot;| SR[&quot;挂起就绪&quot;]:::susp
    BlockC --&gt;|&quot;挂起 ( Suspend )&quot;| SB[&quot;挂起阻塞&quot;]:::susp
    SR --&gt;|&quot;激活 ( Resume )&quot;| ReadyC
    SB --&gt;|&quot;事件完成-&gt;激活&quot;| ReadyC
    RunC --&gt;|&quot;退出 ( Exit )&quot;| TermC[&quot;终止 ( Terminated )&quot;]:::term
  </pre></div>
<h4 id="常见接口速记-类-unix">常见接口速记 ( 类 Unix )</h4>
<ul>
<li><strong>创建与替换</strong> :
<code>fork</code>、<code>vfork</code>、<code>execve</code>/<code>exec*</code>、<code>clone</code>
( Linux ).</li>
<li><strong>终止与回收</strong> :
<code>exit</code>、<code>_exit</code>、<code>wait</code>、<code>waitpid</code>.</li>
<li><strong>阻塞与同步</strong> :
<code>sleep</code>、<code>sem_wait</code>/<code>sem_post</code>、<code>pthread_mutex_lock</code>/<code>unlock</code>.</li>
<li><strong>唤醒与信号</strong> :
<code>kill</code>、<code>sigaction</code>、<code>pthread_cond_wait</code>/<code>signal</code>.</li>
<li><strong>优先级</strong> :
<code>nice</code>、<code>setpriority</code>、<code>sched_setscheduler</code>.</li>
</ul>
<h3 id="进程的通信">2.1.5 进程的通信</h3>
<p>进程通信 ( IPC, Inter-Process Communication )
指进程间的信息交换，常见机制如下.</p>
<h4 id="共享存储-shared-memory">共享存储 ( Shared Memory )</h4>
<ul>
<li><strong>思想</strong> : 将一块物理内存映射到多个进程的地址空间，实现
<strong>零拷贝</strong> 数据交换 ( 最快 ).</li>
<li><strong>特点</strong> : 需要配合 <strong>同步原语</strong> (
互斥锁/信号量/条件变量 ) 保证一致性; 适合大数据量高吞吐场景.</li>
<li><strong>实现</strong> :
<code>shmget/shmat/shmdt/shmctl</code>、<code>mmap</code>
文件映射、<code>POSIX shm_open</code>.</li>
<li><strong>写时复制 ( COW ) 与共享</strong> : <code>fork</code>
后页面共享，写入触发复制;
共享内存段通常标记为可读写并由各进程显式同步.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef proc fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef shm fill:#22D3EE,stroke:#0E7490,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    P1[&quot;进程 A&quot;]:::proc --&gt; SM[&quot;共享内存段&quot;]:::shm
    P2[&quot;进程 B&quot;]:::proc --&gt; SM
    P1 --&gt;|&quot;加锁&#x2F;写入&quot;| SM
    P2 --&gt;|&quot;解锁&#x2F;读取&quot;| SM
  </pre></div>
<h4 id="消息传递-message-passing">消息传递 ( Message Passing )</h4>
<ul>
<li><strong>直接通信</strong> : 发送者指定接收者，内核将消息
<strong>拷贝</strong> 到接收方的消息队列，支持
<strong>阻塞/非阻塞</strong>、同步/异步.</li>
<li><strong>间接通信 ( 信箱/收件箱 )</strong> : 消息发送至
<strong>信箱</strong>，接收者从信箱提取，实现 <strong>解耦</strong> 与
<strong>一对多</strong>.</li>
<li><strong>实现</strong> : System V 消息队列
<code>msgget/msgrcv/msgsnd</code>、POSIX message queue
<code>mq_*</code>.</li>
<li><strong>语义</strong> : 有界队列可能导致 <strong>阻塞</strong>; 支持
<strong>优先级</strong> 与 <strong>按类型筛选</strong>.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef proc fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef mbox fill:#F472B6,stroke:#BE185D,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    S[&quot;发送进程&quot;]:::proc --&gt;|&quot;发送消息&quot;| MB[&quot;信箱&lt;br&#x2F;&gt;消息队列&quot;]:::mbox
    MB --&gt;|&quot;按类型优先级取出&quot;| R[&quot;接收进程&quot;]:::proc
  </pre></div>
<h4 id="管道通信-pipe-fifo">管道通信 ( Pipe / FIFO )</h4>
<ul>
<li><strong>匿名管道 ( pipe )</strong> : 父子进程通过内核
<strong>环形缓冲区</strong> 单向通信;
<strong>读空阻塞/写满阻塞</strong>; 只能在有亲缘关系的进程间使用.</li>
<li><strong>命名管道 ( FIFO )</strong> : 通过文件系统命名，支持
<strong>非亲缘关系</strong> 进程通信.</li>
<li><strong>语义</strong> : 字节流、有序、半双工; 需配合
<strong>阻塞/非阻塞</strong> 模式与缓冲大小考虑.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef proc fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef pipe fill:#94A3B8,stroke:#475569,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    W[&quot;写端进程&quot;]:::proc --&gt;|&quot;write()&quot;| BUF[&quot;管道缓冲区&quot;]:::pipe
    BUF --&gt;|&quot;read()&quot;| R[&quot;读端进程&quot;]:::proc
  </pre></div>
<h4 id="套接字-socket">套接字 ( Socket )</h4>
<ul>
<li><strong>本地套接字 ( Unix Domain Socket )</strong> :
同一主机内进程通信，<strong>零拷贝</strong> 相对较少，支持流式 (
<code>SOCK_STREAM</code> ) 与数据报 ( <code>SOCK_DGRAM</code> ).</li>
<li><strong>网络套接字</strong> : 跨主机通信，基于 TCP/UDP;
适合分布式系统与微服务.</li>
<li><strong>接口</strong> :
<code>socket/bind/connect/listen/accept/send/recv</code>.</li>
</ul>
<h4 id="信号-signal">信号 ( Signal )</h4>
<ul>
<li><strong>思想</strong> : 异步事件通知机制，用于 <strong>控制</strong>
而非大数据传输 ( 如终止、重载配置 ).</li>
<li><strong>处理</strong> : 默认动作/忽略/自定义处理
(<code>sigaction</code>); 与
<strong>阻塞/唤醒</strong>、异常处理关联.</li>
</ul>
<h4 id="内存映射文件-memory-mapped-files">内存映射文件 ( Memory-Mapped
Files )</h4>
<ul>
<li><strong>通过 <code>mmap</code></strong>
将文件映射到内存，实现多个进程对同一文件的 <strong>共享视图</strong>;
适合日志/共享数据区域.</li>
</ul>
<h4 id="对比与选型">对比与选型</h4>
<table>
<thead>
<tr>
<th style="text-align: left;">机制</th>
<th style="text-align: left;">拷贝次数</th>
<th style="text-align: left;">吞吐/延迟</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>共享内存</strong></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;"><strong>极高/极低</strong></td>
<td style="text-align: left;">大数据、低延迟、本机</td>
</tr>
<tr>
<td style="text-align: left;"><strong>消息队列</strong></td>
<td style="text-align: left;">1~2</td>
<td style="text-align: left;">中/中</td>
<td style="text-align: left;">解耦、按类型分发</td>
</tr>
<tr>
<td style="text-align: left;"><strong>管道/FIFO</strong></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">中/中</td>
<td style="text-align: left;">父子/同机简单通信</td>
</tr>
<tr>
<td style="text-align: left;"><strong>套接字</strong></td>
<td style="text-align: left;">2+</td>
<td style="text-align: left;">低/高</td>
<td style="text-align: left;">跨主机/复杂拓扑</td>
</tr>
<tr>
<td style="text-align: left;"><strong>信号</strong></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">控制/通知</td>
</tr>
</tbody>
</table>
<h4 id="常见接口速记-类-unix-1">常见接口速记 ( 类 Unix )</h4>
<ul>
<li><strong>共享内存</strong> :
<code>shmget/shmat/shmdt/shmctl</code>、<code>mmap</code>、<code>shm_open</code>.</li>
<li><strong>消息队列</strong> :
<code>msgget/msgsnd/msgrcv</code>、<code>mq_open/mq_send/mq_receive</code>.</li>
<li><strong>管道</strong> : <code>pipe</code>, <code>mkfifo</code>.</li>
<li><strong>套接字</strong> :
<code>socket/send/recv</code>、<code>bind/listen/accept</code>.</li>
<li><strong>信号</strong> : <code>kill</code>, <code>sigaction</code>,
<code>sigprocmask</code>.</li>
</ul>
<h3 id="线程和多线程模型">2.1.6 线程和多线程模型</h3>
<h4 id="线程的基本概念">线程的基本概念</h4>
<ol type="1">
<li><strong>定义</strong> : 线程 ( Thread ) 是程序执行流的最小单位，是
<strong>CPU 调度</strong> 的基本单位.</li>
<li><strong>与进程的区别</strong> : 进程是
<strong>资源分配单位</strong>，线程是 <strong>调度单位</strong>.</li>
<li><strong>共享与私有</strong> : 线程共享进程的
<strong>地址空间/打开文件/信号量</strong> 等资源，拥有
<strong>独立栈/寄存器现场/线程本地存储 (TLS)</strong>.</li>
<li><strong>控制块</strong> : 线程使用 <strong>TCB</strong> 记录线程 ID
(TID)、状态、优先级、栈指针等; 多个 TCB 归属于一个进程的
<strong>PCB</strong>.</li>
</ol>
<h4 id="引入线程的目的与优势">引入线程的目的与优势</h4>
<ul>
<li><strong>降低开销</strong> :
线程的创建/切换不需要切换进程地址空间与页表，<strong>代价远低于进程</strong>.</li>
<li><strong>提升并发与吞吐</strong> :
引入线程后，<strong>进程内的多个线程</strong> 可并发执行;
在多核系统上可并行，提高系统资源利用率与系统吞吐量.</li>
<li><strong>更高的响应性</strong> : 线程可拆分任务 (I/O
与计算并行)，避免单线程阻塞导致应用无响应.</li>
<li><strong>更易的共享与协作</strong> :
线程天然共享进程资源，<strong>线程间通信成本低</strong>
(直接共享内存，配合同步原语).</li>
</ul>
<h4 id="线程的基本特性">线程的基本特性</h4>
<ol type="1">
<li><strong>轻量实体</strong> :
不拥有独立系统资源，具有唯一标识与独立栈/寄存器现场.</li>
<li><strong>独立调度单位</strong> : 线程是被调度的基本单位;
<strong>线程切换通常不会引起进程切换</strong> (同一地址空间下).</li>
<li><strong>并发/并行性</strong> :
不仅进程之间可并发，<strong>同一进程的多个线程也可并发/并行</strong>;
在多 CPU 系统上，多线程可同时占用多个 CPU.</li>
<li><strong>共享性</strong> : 同一进程的多线程共享进程拥有的全部资源
(地址空间、文件等).</li>
<li><strong>开销更小</strong> :
创建/撤销与切换的代价明显小于进程，平均每次切换的开销更低.</li>
</ol>
<h4 id="线程的状态与转换">线程的状态与转换</h4>
<ul>
<li><strong>基本状态</strong> : <strong>就绪</strong>
(具备运行条件，等待 CPU)、<strong>运行</strong> (占用
CPU)、<strong>阻塞</strong> (等待事件/资源).</li>
<li><strong>转换</strong> : 就绪 -&gt; 运行 (分派); 运行 -&gt; 就绪
(时间片用完/被抢占); 运行 -&gt; 阻塞 (等待 I/O/锁); 阻塞 -&gt; 就绪
(事件完成).</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef ready fill:#93C5FD,stroke:#1D4ED8,stroke-width:2px,color:#1E3A8A,rx:5,ry:5;
    classDef run fill:#22C55E,stroke:#15803D,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef block fill:#F59E0B,stroke:#B45309,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    ReadyT[&quot;就绪 ( Ready )&quot;]:::ready --&gt;|&quot;分派 ( Dispatch )&quot;| RunT[&quot;运行 ( Running )&quot;]:::run
    RunT --&gt;|&quot;时间片用完&#x2F;抢占&quot;| ReadyT
    RunT --&gt;|&quot;I&#x2F;O&#x2F;等待锁&lt;br&#x2F;&gt;条件变量&quot;| BlockT[&quot;阻塞 ( Blocked )&quot;]:::block
    BlockT --&gt;|&quot;事件完成&lt;br&#x2F;&gt;唤醒&quot;| ReadyT
  </pre></div>
<h4 id="线程控制块-tcb-典型字段">线程控制块 (TCB) 典型字段</h4>
<ul>
<li><strong>标识信息</strong> : 线程 ID (TID)、所属进程 ID
(PID)、名称.</li>
<li><strong>处理机现场</strong> : 通用寄存器集、程序计数器
<strong>PC</strong>、程序状态字 <strong>PSW</strong>、栈指针
<strong>SP</strong>.</li>
<li><strong>调度信息</strong> :
状态、优先级、时间片、亲和性、就绪/阻塞队列链接指针.</li>
<li><strong>存储信息</strong> : 线程栈起始与大小、<strong>TLS</strong>
指针、信号屏蔽集.</li>
<li><strong>统计信息</strong> : 累计 CPU 时间、调度次数、阻塞原因.</li>
</ul>
<h4 id="线程的属性">线程的属性</h4>
<ul>
<li><strong>分离态 ( Detached ) / 可连接 ( Joinable )</strong> :
分离态线程结束后资源由系统自动回收; 可连接线程需由其他线程
<code>join</code> 获取返回值并回收资源.</li>
<li><strong>调度策略与优先级</strong> : 常见策略
<code>SCHED_OTHER/RR/FIFO</code>; 优先级影响抢占次序与时间片分配.</li>
<li><strong>CPU 亲和性 ( Affinity )</strong> : 绑定到特定 CPU/NUMA
节点，提升缓存命中与局部性.</li>
<li><strong>栈属性</strong> :
栈大小、栈起始地址、<strong>保护页</strong> ( 防止栈溢出越界 ).</li>
<li><strong>取消与取消点</strong> : 支持 <code>pthread_cancel</code>;
取消状态 <strong>可取消/不可取消</strong>，取消类型
<strong>延迟取消/异步取消</strong>，在取消点 ( 如阻塞
I/O、<code>pthread_cond_wait</code> ) 生效.</li>
<li><strong>信号屏蔽集</strong> :
每个线程可设置自己的信号屏蔽与处理函数;
进程范围内的某些信号按线程语义分发.</li>
<li><strong>属性接口</strong> : 初始化/设置/查询使用
<code>pthread_attr_*</code> ( 如分离态、栈大小、亲和性 ).</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef proc fill:#93C5FD,stroke:#1D4ED8,stroke-width:2px,color:#1E3A8A,rx:5,ry:5;
    classDef shared fill:#22D3EE,stroke:#0E7490,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef thread fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef priv fill:#F59E0B,stroke:#B45309,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    P[&quot;进程 ( PCB &#x2F; 地址空间&lt;br&#x2F;&gt;打开文件 &#x2F; 信号量 )&quot;]:::proc
    Code[&quot;代码段 ( 共享 )&quot;]:::shared
    Data[&quot;数据段 ( 共享部分 )&quot;]:::shared
    T1[&quot;线程 T1&quot;]:::thread --&gt; S1[&quot;栈 &#x2F; TLS&lt;br&#x2F;&gt;寄存器 &#x2F; TCB&quot;]:::priv
    T2[&quot;线程 T2&quot;]:::thread --&gt; S2[&quot;栈 &#x2F; TLS&lt;br&#x2F;&gt;寄存器 &#x2F; TCB&quot;]:::priv
    T3[&quot;线程 T3&quot;]:::thread --&gt; S3[&quot;栈 &#x2F; TLS&lt;br&#x2F;&gt;寄存器 &#x2F; TCB&quot;]:::priv

    P --&gt; Code
    P --&gt; Data
    P --- T1
    P --- T2
    P --- T3
  </pre></div>
<h4 id="进程与线程对比速查">进程与线程对比速查</h4>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">维度</th>
<th style="text-align: left;">进程</th>
<th style="text-align: left;">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>定义单位</strong></td>
<td style="text-align: left;"><strong>资源分配单位</strong></td>
<td style="text-align: left;"><strong>调度单位</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>地址空间</strong></td>
<td style="text-align: left;">独立地址空间，切换需页表/内核栈切换</td>
<td style="text-align: left;">共享进程地址空间，切换仅栈/寄存器</td>
</tr>
<tr>
<td style="text-align: left;"><strong>资源持有</strong></td>
<td style="text-align: left;">拥有文件、设备、内存等资源</td>
<td style="text-align: left;">共享进程资源，私有栈/寄存器/TLS</td>
</tr>
<tr>
<td style="text-align: left;"><strong>通信成本</strong></td>
<td style="text-align: left;">需 IPC ( 管道、消息队列、共享内存、Socket
)</td>
<td style="text-align: left;">直接读写共享内存，需同步原语</td>
</tr>
<tr>
<td style="text-align: left;"><strong>创建/销毁开销</strong></td>
<td style="text-align: left;">大 ( 创建 PCB、地址空间、页表等 )</td>
<td style="text-align: left;">小 ( 创建 TCB、栈 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>切换开销</strong></td>
<td style="text-align: left;">大 ( 地址空间切换、TLB 刷新 )</td>
<td style="text-align: left;">小 ( 同地址空间 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>阻塞影响</strong></td>
<td style="text-align: left;">阻塞不影响其他进程</td>
<td style="text-align: left;">KLT 阻塞不影响其他线程; ULT
可能阻塞全进程</td>
</tr>
<tr>
<td style="text-align: left;"><strong>隔离与稳定性</strong></td>
<td style="text-align: left;">崩溃不影响其他进程，隔离强</td>
<td style="text-align: left;">一个线程崩溃可能导致整个进程崩溃</td>
</tr>
<tr>
<td style="text-align: left;"><strong>并行能力</strong></td>
<td style="text-align: left;">多进程可多核并行</td>
<td style="text-align: left;">KLT 可多核并行; N:1 ULT 不可</td>
</tr>
<tr>
<td style="text-align: left;"><strong>适用场景</strong></td>
<td style="text-align: left;">高可靠隔离的服务或组件</td>
<td style="text-align: left;">同一应用内的并发执行 ( I/O 密集、计算并行
)</td>
</tr>
</tbody>
</table>
<h4 id="线程的实现方式">线程的实现方式</h4>
<ol type="1">
<li><strong>用户级线程 ( ULT )</strong> :
<ul>
<li><strong>管理者</strong> :
线程库在用户态实现创建/调度/切换，内核对线程不可见.</li>
<li><strong>优点</strong> : 切换快、无需陷入内核; 可定制调度策略;
创建销毁开销小.</li>
<li><strong>缺点</strong> : <strong>阻塞系统调用</strong>
会阻塞整个进程; 无法利用多核实现真实并行 (通常映射到单个 KLT);
内核定时器等无法直接抢占线程.</li>
</ul></li>
<li><strong>内核级线程 ( KLT )</strong> :
<ul>
<li><strong>管理者</strong> :
由操作系统内核管理与调度，每个线程作为内核可见实体.</li>
<li><strong>优点</strong> : 可在 <strong>多核上并行</strong>;
一个线程阻塞不影响同进程其他线程; 与内核机制 (信号/定时器/调度)
协同良好.</li>
<li><strong>缺点</strong> : 切换需 <strong>用户态/内核态</strong>
转换，开销相对较大; 创建销毁成本高.</li>
</ul></li>
</ol>
<h4 id="多线程模型">多线程模型</h4>
<ol type="1">
<li><strong>多对一 ( N:1 )</strong> : 多个 ULT 映射到
<strong>一个</strong> KLT.
<ul>
<li><strong>特点</strong> : 不支持真正并行; 一个线程阻塞会
<strong>拖累全进程</strong>.</li>
<li><strong>优点</strong> : 开销最小，实现简单.</li>
<li><strong>缺点</strong> : 并发度受限，适用性差.</li>
</ul></li>
<li><strong>一对一 ( 1:1 )</strong> : 每个 ULT 映射到
<strong>一个</strong> KLT ( 现代 OS 主流，如 Linux NPTL、Windows ).
<ul>
<li><strong>特点</strong> : 可并行、阻塞互不影响.</li>
<li><strong>优点</strong> : 语义清晰，生态成熟.</li>
<li><strong>缺点</strong> : 线程数多时内核管理开销增大.</li>
</ul></li>
<li><strong>多对多 ( M:N )</strong> : 多个 ULT 映射到
<strong>多个</strong> KLT ( 需要协调机制，如 Scheduler Activations ).
<ul>
<li><strong>特点</strong> : 试图兼顾 ULT 的低开销与 KLT 的并行能力.</li>
<li><strong>优点</strong> : 可控制并行度、减少内核压力.</li>
<li><strong>缺点</strong> : 实现复杂，语义边界与调度协同难度大.</li>
</ul></li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:transparent,stroke:transparent,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef ult fill:#e3f2fd,stroke:#2196f3,stroke-width:2px,color:#1565c0,rx:5,ry:5;
    classDef klt fill:#e0f2f1,stroke:#009688,stroke-width:2px,color:#00695c,rx:5,ry:5;
    classDef proc fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px,color:#7b1fa2,rx:5,ry:5;

    %% 修改连线样式 ( 颜色: 灰色, 宽度: 2px, 箭头颜色会自动跟随 stroke )
    linkStyle default stroke:#64748b,stroke-width:2px,fill:none;

    subgraph N1[&quot;N:1 ( 多对一 )&quot;]
      direction TB
      P1[&quot;进程&quot;]:::proc --- U1[&quot;ULT #1&quot;]:::ult
      P1 --- U2[&quot;ULT #2&quot;]:::ult
      P1 --- U3[&quot;ULT #3&quot;]:::ult
      U1 --&gt; K1[&quot;KLT #1&quot;]:::klt
      U2 --&gt; K1
      U3 --&gt; K1
    end

    subgraph OneOne[&quot;1:1 ( 一对一 )&quot;]
      direction TB
      P2[&quot;进程&quot;]:::proc --- U4[&quot;ULT #1&quot;]:::ult
      P2 --- U5[&quot;ULT #2&quot;]:::ult
      U4 --&gt; K2[&quot;KLT #1&quot;]:::klt
      U5 --&gt; K3[&quot;KLT #2&quot;]:::klt
    end

    subgraph MN[&quot;M:N ( 多对多 )&quot;]
      direction TB
      P3[&quot;进程&quot;]:::proc --- U6[&quot;ULT #1&quot;]:::ult
      P3 --- U7[&quot;ULT #2&quot;]:::ult
      P3 --- U8[&quot;ULT #3&quot;]:::ult
      U6 --&gt; KM1[&quot;KLT #1&quot;]:::klt
      U7 --&gt; KM2[&quot;KLT #2&quot;]:::klt
      U8 --&gt; KM1
    end
  </pre></div>
<h4 id="线程调度与同步">线程调度与同步</h4>
<ul>
<li><strong>调度</strong> : 一对一模型下由 <strong>内核调度</strong>;
多对一/多对多需 <strong>用户态调度器</strong> 与内核调度协同.</li>
<li><strong>同步原语</strong> : 互斥锁、读写锁、条件变量、信号量、屏障;
避免 <strong>竞态/死锁/活锁/优先级反转</strong>，可用
<strong>优先级继承/上限协议</strong> 缓解.</li>
<li><strong>阻塞语义</strong> : ULT 需避免阻塞系统调用 (或使用异步 I/O);
KLT 阻塞不影响其他线程.</li>
<li><strong>亲和性与并行</strong> : 线程可设置 <strong>CPU
亲和性</strong> 提升缓存局部性; 注意 <strong>NUMA</strong> 影响.</li>
</ul>
<h4 id="常见接口速记-类-unix-2">常见接口速记 ( 类 Unix )</h4>
<ul>
<li><strong>创建/结束</strong> :
<code>pthread_create</code>、<code>pthread_exit</code>、<code>pthread_join</code>.</li>
<li><strong>同步</strong> :
<code>pthread_mutex_*</code>、<code>pthread_rwlock_*</code>、<code>pthread_cond_*</code>、<code>sem_*</code>.</li>
<li><strong>属性</strong> : <code>pthread_attr_*</code> (
栈大小/亲和性/分离态 ).</li>
<li><strong>Linux 特性</strong> : <code>clone</code> 创建轻量进程 (
共享资源 ); NPTL 提供 1:1 语义与高性能.</li>
</ul>
<h2 id="cpu-调度">2.2 CPU 调度</h2>
<h3 id="调度的概念">2.2.1 调度的概念</h3>
<ul>
<li><strong>作业调度 ( 高级调度 )</strong> :
从外存挑选作业调入内存，分配资源并创建进程 ( 发生频率低，分钟级 ).</li>
<li><strong>内存调度 ( 中级调度 )</strong> : 将暂时不能运行的进程挂起 (
Suspend ) 到外存，以腾出内存空间; 条件满足时再调入 ( 频率中等 ).</li>
<li><strong>进程调度 ( 低级调度 )</strong> : 从就绪队列挑选进程分配 CPU
( 发生频率最高，毫秒级 ).</li>
</ul>
<h4 id="三级调度的联系">三级调度的联系</h4>
<ol type="1">
<li><strong>层级关系</strong> :
<ul>
<li><strong>高级调度</strong> 决定了 “谁能进门” (
允许多少作业进入内存，控制 <strong>多道程序度</strong> ).</li>
<li><strong>低级调度</strong> 决定了 “谁能干活” ( 哪个就绪进程获得 CPU
).</li>
<li><strong>中级调度</strong> 决定了 “谁先歇会” (
内存紧张时将进程换出，平衡系统负载 ).</li>
</ul></li>
<li><strong>协同工作</strong> :
<ul>
<li>高级调度为低级调度提供 <strong>“原材料”</strong> ( 就绪进程 ).</li>
<li>中级调度为低级调度提供 <strong>“平滑剂”</strong> (
避免内存不足导致颠簸 ).</li>
</ul></li>
<li><strong>频率对比</strong> : <strong>低级调度</strong> ( 毫秒级 )
<span class="math inline">\(\gg\)</span> <strong>中级调度</strong> (
秒级 ) <span class="math inline">\(\gg\)</span>
<strong>高级调度</strong> ( 分钟级 ).</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:transparent,stroke:transparent,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef high fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef mid fill:#FDE68A,stroke:#CA8A04,stroke-width:2px,color:#7C2D12,rx:5,ry:5;
    classDef low fill:#22D3EE,stroke:#0E7490,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef storage fill:#818CF8,stroke:#6366F1,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    subgraph Storage[&quot;存储层次 ( Storage Hierarchy )&quot;]
      direction TB
      Disk[&quot;外存&lt;br&#x2F;&gt;( 作业池 &#x2F; 对换区 )&quot;]:::storage
      Mem[&quot;内存&lt;br&#x2F;&gt;( 就绪队列 )&quot;]:::storage
      CPU[&quot;CPU ( 运行 )&quot;]:::low
    end

    Disk --&gt;|&quot;高级调度&lt;br&#x2F;&gt;( 作业-&gt;进程 )&quot;| Mem:::high
    Mem --&gt;|&quot;低级调度&lt;br&#x2F;&gt;( 就绪-&gt;运行 )&quot;| CPU
    CPU --&gt;|&quot;时间片&#x2F;中断&lt;br&#x2F;&gt;( Timeout&#x2F;Interrupt )&quot;| Mem
    Mem --&gt;|&quot;中级调度&lt;br&#x2F;&gt;( 挂起 )&quot;| Disk:::mid
    Disk --&gt;|&quot;中级调度&lt;br&#x2F;&gt;( 激活 )&quot;| Mem
  </pre></div>
<h3 id="调度的实现">2.2.2 调度的实现</h3>
<h4 id="逻辑组成">1. 逻辑组成</h4>
<p>现代操作系统的调度模块通常包含三个核心组件，它们分工明确，共同完成
CPU 的分配与切换 :</p>
<ul>
<li><strong>排队器 ( Queuer )</strong> :
<ul>
<li><strong>职责</strong> : 将就绪进程插入到相应的就绪队列中.</li>
<li><strong>策略</strong> : 依据调度算法 ( 如 FCFS, 优先级, 多级队列 )
维护队列结构.</li>
</ul></li>
<li><strong>分派器 ( Dispatcher )</strong> :
<ul>
<li><strong>职责</strong> : 依据 <strong>调度程序 ( Scheduler )</strong>
的决策，从就绪队列中取出进程.</li>
<li><strong>动作</strong> : 它是调度逻辑与底层切换机制的衔接点.</li>
</ul></li>
<li><strong>上下文切换器 ( Context Switcher )</strong> :
<ul>
<li><strong>职责</strong> : 执行实际的硬件级切换.</li>
<li><strong>动作</strong> :
<ol type="1">
<li><strong>保存</strong> 当前进程的硬件上下文 ( 寄存器/PC/栈指针 ) 到其
PCB.</li>
<li><strong>加载</strong> 选定进程的硬件上下文.</li>
<li><strong>刷新</strong> TLB/Cache ( 视架构而定，导致隐式开销 ).</li>
</ol></li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef comp fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef core fill:#fce7f3,stroke:#db2777,stroke-width:2px,color:#be185d,rx:5,ry:5;
    classDef hw fill:#f3f4f6,stroke:#475569,stroke-width:2px,color:#1f2937,rx:5,ry:5;

    subgraph OS[&quot;操作系统调度子系统&quot;]
        direction TB
        Q[&quot;排队器&lt;br&#x2F;&gt;(Queuer)&quot;]:::comp
        S[&quot;调度程序&lt;br&#x2F;&gt;(Scheduler)&quot;]:::comp
        D[&quot;分派器&lt;br&#x2F;&gt;(Dispatcher)&quot;]:::comp
        CS[&quot;上下文切换器&lt;br&#x2F;&gt;(Context Switcher)&quot;]:::core
    end

    P[&quot;进程&lt;br&#x2F;&gt;(Process)&quot;]:::default --&gt; Q
    Q --&gt;|入队| RQ[&quot;就绪队列&lt;br&#x2F;&gt;(Ready Queue)&quot;]:::default
    
    S --&gt;|决策| D
    D --&gt;|出队| RQ
    D --&gt;|触发| CS
    CS --&gt;|保存&#x2F;恢复| CPU((CPU)):::hw

    style OS fill:#f8fafc,stroke:#94a3b8,stroke-width:2px,stroke-dasharray: 5 5,color:#475569
  </pre></div>
<h4 id="调度的时机">2. 调度的时机</h4>
<p>调度请求通常由 <strong>中断</strong> 或 <strong>系统调用</strong>
触发，分为以下三类情况 :</p>
<ul>
<li><strong>必须调度 ( 必须让出 CPU )</strong> :
<ol type="1">
<li><strong>进程终止</strong> : 进程执行完毕 ( <code>exit</code> ).</li>
<li><strong>进程阻塞</strong> : 进程主动请求 I/O、等待锁或信号量 (
<code>wait</code>, <code>block</code> ).</li>
<li><strong>异常终止</strong> : 发生不可恢复的错误 ( 如除零、段错误
).</li>
</ol></li>
<li><strong>可以调度 ( 抢占式系统 )</strong> :
<ol type="1">
<li><strong>时间片耗尽</strong> : 时钟中断触发，防止进程独占 CPU.</li>
<li><strong>更高优先级进程就绪</strong> :
<ul>
<li>I/O 完成中断唤醒了高优先级进程.</li>
<li>新进程创建且优先级更高.</li>
<li>进程优先级动态改变 ( 变高 ).</li>
</ul></li>
<li><strong>系统调用返回用户态时</strong> :
内核处理完系统调用，准备切回用户态前，检查调度标志.</li>
</ol></li>
<li><strong>不能调度 ( 临界情况 )</strong> :
<ol type="1">
<li><strong>处理中断服务程序 ( ISR ) 期间</strong> :
中断处理应尽快完成，不宜切换.</li>
<li><strong>处于原子操作/自旋锁期间</strong> :
切换可能导致死锁或数据不一致.</li>
<li><strong>内核临界区</strong> ( 视内核设计而定，抢占式内核允许部分抢占
).</li>
</ol></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef must fill:#FCA5A5,stroke:#B91C1C,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef can fill:#FDE68A,stroke:#CA8A04,stroke-width:2px,color:#7C2D12,rx:5,ry:5;
    classDef no fill:#E5E7EB,stroke:#374151,stroke-width:2px,color:#1F2937,rx:5,ry:5;
    classDef scheduler fill:#3B82F6,stroke:#1D4ED8,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;
    classDef act fill:#A7F3D0,stroke:#065F46,stroke-width:2px,color:#065F46,rx:5,ry:5;

    Scheduler{&quot;调度器&lt;br&#x2F;&gt;( Scheduler )&quot;}:::scheduler
    
    subgraph Must[&quot;必须调度 ( 主动&#x2F;终止 )&quot;]
      direction TB
      Term[&quot;进程终止&lt;br&#x2F;&gt;( Exit )&quot;]:::must
      Block[&quot;I&#x2F;O 阻塞&#x2F;等待&lt;br&#x2F;&gt;( Wait&#x2F;Block )&quot;]:::must
      Exc[&quot;异常终止&lt;br&#x2F;&gt;( Exception )&quot;]:::must
    end

    subgraph Can[&quot;可以调度 ( 被动&#x2F;抢占 )&quot;]
      direction TB
      Time[&quot;时间片用完&lt;br&#x2F;&gt;( Time Slice )&quot;]:::can
      Wake[&quot;唤醒高优进程&lt;br&#x2F;&gt;( Wakeup )&quot;]:::can
      Ret[&quot;系统调用返回&lt;br&#x2F;&gt;( Syscall Return )&quot;]:::can
    end

    subgraph No[&quot;不能调度 ( 保护 )&quot;]
      direction TB
      ISR[&quot;中断处理中&lt;br&#x2F;&gt;( ISR )&quot;]:::no
      Lock[&quot;持有自旋锁&lt;br&#x2F;&gt;( Spinlock )&quot;]:::no
      Crit[&quot;内核临界区&lt;br&#x2F;&gt;( Kernel Critical )&quot;]:::no
    end
    
    class Must must
    class Can can
    class No no

    Term --&gt;|&quot;触发&quot;| Scheduler
    Block --&gt;|&quot;触发&quot;| Scheduler
    Exc --&gt;|&quot;触发&quot;| Scheduler
    
    Time --&gt;|&quot;触发&quot;| Scheduler
    Wake --&gt;|&quot;触发&quot;| Scheduler
    Ret --&gt;|&quot;触发&quot;| Scheduler
    
    ISR -.-x|&quot;禁止&quot;| Scheduler
    Lock -.-x|&quot;禁止&quot;| Scheduler
    Crit -.-x|&quot;禁止&quot;| Scheduler

    %% Result
    Switch[&quot;进程切换&lt;br&#x2F;&gt;( Context Switch )&quot;]:::act
    Scheduler --&gt;|&quot;决定切换&quot;| Switch
  </pre></div>
<h4 id="调度的方式">3. 调度的方式</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">方式</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">触发条件</th>
<th style="text-align: left;">优点</th>
<th style="text-align: left;">缺点</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: left;"><strong>非抢占式</strong><br>(Non-preemptive)</td>
<td style="text-align: left;">一旦分配 CPU，直至进程
<strong>完成</strong> 或 <strong>阻塞</strong> 才释放.</td>
<td style="text-align: left;">主动放弃 ( 终止/IO )</td>
<td style="text-align: left;">实现简单、开销小、适合批处理</td>
<td style="text-align: left;">响应差、可能导致
<strong>饥饿</strong></td>
<td style="text-align: left;">早期 OS、批处理系统</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>抢占式</strong><br>(Preemptive)</td>
<td
style="text-align: left;">允许中断当前执行的进程，强行分配给更重要的进程.</td>
<td style="text-align: left;">时间片耗尽、高优先级到达、中断返回</td>
<td style="text-align: left;"><strong>响应快</strong>、公平、防死锁</td>
<td style="text-align: left;">切换频繁开销大、需处理
<strong>竞态条件</strong></td>
<td style="text-align: left;"><strong>现代通用 OS</strong> ( Win/Lin/Mac
)</td>
</tr>
</tbody>
</table>
<p><strong>抢占的原则 ( 依据 )</strong> :</p>
<ol type="1">
<li><strong>优先权原则</strong> : 只要出现更高优先级的进程，立即抢占 (
如实时系统 ).</li>
<li><strong>短作业优先原则</strong> :
新到达作业比当前剩余时间短，则抢占.</li>
<li><strong>时间片原则</strong> : 运行完一个时间片，必须释放 CPU.</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
gantt
    title 抢占式 vs 非抢占式 ( P1高优, P2低优 )
    dateFormat s
    axisFormat %S
    tickInterval 1second
    
    section 非抢占式
    P2 (低优) 运行      :active, p2_nopre, 0, 4s
    P1 (高优) 到达但等待 :crit, 2, 2s
    P1 (高优) 运行      :crit, p1_nopre, after p2_nopre, 2s
    
    section 抢占式
    P2 (低优) 运行      :active, p2_pre1, 0, 2s
    P1 (高优) 抢占运行  :crit, p1_pre, 2, 2s
    P2 (低优) 恢复运行  :active, p2_pre2, after p1_pre, 2s
  </pre></div>
<h4 id="分派延迟-dispatch-latency">4. 分派延迟 ( Dispatch Latency )</h4>
<ul>
<li><strong>定义</strong> : 停止一个进程到启动另一个进程的时间 (
纯系统开销 ).</li>
<li><strong>组成</strong> : 保存旧进程 PCB + 调度算法选择 + 恢复新进程
PCB.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
sequenceDiagram
    autonumber
    box &quot;用户态 ( User Space )&quot; #f8fafc
        participant P0 as 进程 P0
        participant P1 as 进程 P1
    end
    box &quot;内核态 ( Kernel Space )&quot; #fffbeb
        participant OS as OS ( 调度&#x2F;分派 )
    end

    Note over P0: 正在运行 ( Running )
    Note over P1: 就绪等待 ( Ready )
    
    P0-&gt;&gt;OS: 中断 &#x2F; 系统调用 &#x2F; 异常
    
    Note right of OS: 陷入内核 ( Trap )
    
    Note right of OS: 1. 保存 P0 上下文 -&gt; PCB_0
    Note over P0: 状态更新:&lt;br&#x2F;&gt;运行 -&gt; 就绪&#x2F;阻塞
    Note right of OS: 2. 调度程序选择 P1
    
    Note right of OS: 3. 分派程序恢复 P1 &lt;- PCB_1
    Note right of OS: ( 隐式开销: 刷新 TLB &#x2F; Cache )
    
    OS--&gt;&gt;P1: 切换回用户态 ( IRET )
    Note over P1: 开始运行 ( Running )

    Note over OS: 步骤 1+2+3 总耗时即为&lt;br&#x2F;&gt;分派延迟 ( Dispatch Latency )
  </pre></div>
<h4 id="闲逛进程-idle-process">5. 闲逛进程 ( Idle Process )</h4>
<ul>
<li><strong>定义</strong> : 当系统中 <strong>没有就绪进程</strong>
时，调度程序选择运行的特殊进程 ( PID=0 或特殊标识 ).</li>
<li><strong>特性</strong> :
<ul>
<li><strong>优先级最低</strong> : 只有在就绪队列为空时才运行.</li>
<li><strong>能耗优化</strong> : 现代 CPU 在执行 idle
循环时会进入低功耗模式 ( <code>hlt</code> 指令 ).</li>
<li><strong>不可阻塞</strong> :
闲逛进程不应执行任何可能导致阻塞的操作.</li>
<li><strong>0 地址空间</strong> :
通常不需要独立的用户地址空间，仅在内核态运行.</li>
</ul></li>
</ul>
<h4 id="两种线程的调度">6. 两种线程的调度</h4>
<ul>
<li><strong>用户级线程 ( ULT ) 调度</strong> :
<ul>
<li><strong>调度者</strong> : 应用程序内部的 <strong>线程库</strong> (
如 Java JVM, Go Runtime ).</li>
<li><strong>内核视角</strong> :
内核只看到一个进程，不知道内部有多个线程.</li>
<li><strong>特点</strong> : 即使有多个 CPU，该进程的多个 ULT
也只能分时复用 <strong>一个</strong> 内核分配的时间片 ( 除非 M:N 模型
).</li>
</ul></li>
<li><strong>内核级线程 ( KLT ) 调度</strong> :
<ul>
<li><strong>调度者</strong> : <strong>操作系统内核</strong>.</li>
<li><strong>内核视角</strong> : 内核维护每个线程的
TCB，将其视为独立的调度实体.</li>
<li><strong>特点</strong> : 可以将同一进程的多个 KLT 分配到 <strong>不同
CPU</strong> 上并行执行.</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef ult fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef klt fill:#fef3c7,stroke:#d97706,stroke-width:2px,color:#b45309,rx:5,ry:5;
    classDef cpu fill:#f3e8ff,stroke:#9333ea,stroke-width:2px,color:#7e22ce,rx:5,ry:5;

    subgraph UserSpace[&quot;用户态调度 ( ULT )&quot;]
      direction TB
      App[&quot;应用程序&lt;br&#x2F;&gt;运行时&quot;]:::ult
      T1[&quot;ULT 1&quot;]:::ult
      T2[&quot;ULT 2&quot;]:::ult
      App --&quot;库调度&quot;--&gt; T1
      App --&quot;库调度&quot;--&gt; T2
    end

    subgraph KernelSpace[&quot;内核态调度 ( KLT )&quot;]
      direction TB
      OS[&quot;OS 调度器&quot;]:::klt
      K1[&quot;KLT&lt;br&#x2F;&gt;(对应进程)&quot;]:::klt
    end
    
    subgraph HW[&quot;硬件 ( Hardware )&quot;]
      direction TB
      CPU1((CPU)):::cpu
    end

    T1 -.-&gt;|&quot;复用&quot;| K1
    T2 -.-&gt;|&quot;复用&quot;| K1
    OS --&quot;系统调度&quot;--&gt; K1
    K1 --&quot;执行&quot;--&gt; CPU1
    
    style UserSpace fill:#f8fafc,stroke:#94a3b8,stroke-width:2px,stroke-dasharray: 5 5
    style KernelSpace fill:#fffbeb,stroke:#f59e0b,stroke-width:2px,stroke-dasharray: 5 5
    style HW fill:#f3f4f6,stroke:#cbd5e1,stroke-width:2px,stroke-dasharray: 5 5
  </pre></div>
<h3 id="调度的目标-评价指标">2.2.3 调度的目标 ( 评价指标 )</h3>
<p>调度算法的选择取决于系统的设计目标. 不同的系统 ( 批处理、分时、实时 )
有不同的侧重点，但通常围绕以下核心指标进行评价 :</p>
<h4 id="评价指标详解">1. 评价指标详解</h4>
<h5 id="cpu-利用率-cpu-utilization">(1) CPU 利用率 ( CPU Utilization
)</h5>
<ul>
<li><strong>定义</strong> : CPU 处于忙碌状态的时间占总时间的比例.</li>
<li><strong>公式</strong> : <span class="math display">\[\text{CPU
利用率} = \frac{\text{CPU 有效工作时间}}{\text{CPU 有效工作时间} +
\text{CPU 空闲等待时间}}\]</span></li>
<li><strong>目标</strong> : 尽可能高 ( 40%~90% ).</li>
<li><strong>注意</strong> : I/O 密集型作业会导致 CPU 利用率下降 (
需多道程序提高 ).</li>
</ul>
<h5 id="系统吞吐量-system-throughput">(2) 系统吞吐量 ( System Throughput
)</h5>
<ul>
<li><strong>定义</strong> : 单位时间内 CPU 完成作业的数量.</li>
<li><strong>公式</strong> : <span class="math display">\[\text{吞吐量} =
\frac{\text{完成作业总数}}{\text{总花费时间}}\]</span></li>
<li><strong>目标</strong> : 尽可能高. 适合
<strong>批处理系统</strong>.</li>
</ul>
<h5 id="周转时间-turnaround-time">(3) 周转时间 ( Turnaround Time )</h5>
<ul>
<li><strong>定义</strong> : 从作业 <strong>提交</strong>
给系统开始，到作业 <strong>完成</strong> 为止的时间间隔.</li>
<li><strong>组成</strong> :
<ul>
<li>作业在外存后备队列等待调度的时间 ( 高级调度 ).</li>
<li>进程在就绪队列等待进程调度的时间 ( 低级调度,
<strong>等待时间</strong> ).</li>
<li>进程在 CPU 上执行的时间 ( <strong>运行时间</strong> ).</li>
<li>进程等待 I/O 操作完成的时间.</li>
</ul></li>
<li><strong>公式</strong> : <span class="math display">\[T_{周转} =
T_{完成} - T_{提交}\]</span></li>
<li><strong>平均周转时间</strong> : <span class="math display">\[\bar{T}
= \frac{\sum_{i=1}^{n} T_{周转}(i)}{n}\]</span></li>
<li><strong>目标</strong> : 越短越好.</li>
</ul>
<h5 id="带权周转时间-weighted-turnaround-time">(4) 带权周转时间 (
Weighted Turnaround Time )</h5>
<ul>
<li><strong>定义</strong> :
作业的周转时间与系统为其提供服务的时间之比.</li>
<li><strong>公式</strong> : <span class="math display">\[W =
\frac{T_{周转}}{T_{运行}} = \frac{T_{等待} + T_{运行}}{T_{运行}} = 1 +
\frac{T_{等待}}{T_{运行}}\]</span></li>
<li><strong>意义</strong> : <span class="math inline">\(W \ge
1\)</span>. <span class="math inline">\(W\)</span>
越小，说明作业在系统中等待的时间比例越小，用户体验越好.</li>
<li><strong>目标</strong> : 越小越好 ( 接近 1 ).</li>
</ul>
<h5 id="等待时间-waiting-time">(5) 等待时间 ( Waiting Time )</h5>
<ul>
<li><strong>定义</strong> : 进程在 <strong>就绪队列</strong>
中等待调度的总时间.</li>
<li><strong>注意</strong> : 调度算法
<strong>只影响等待时间</strong>，不影响进程的运行时间和 I/O 时间.</li>
<li><strong>目标</strong> : 越短越好.</li>
</ul>
<h5 id="响应时间-response-time">(6) 响应时间 ( Response Time )</h5>
<ul>
<li><strong>定义</strong> : 从用户 <strong>提交请求</strong> 到系统
<strong>首次产生响应</strong> ( 输出第一个字符 ) 的时间.</li>
<li><strong>场景</strong> : <strong>交互式系统</strong> ( 分时系统 )
的核心指标.</li>
<li><strong>公式</strong> : <span class="math display">\[T_{响应} =
T_{首次响应} - T_{提交}\]</span></li>
</ul>
<h4 id="指标图解">2. 指标图解</h4>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
gantt
    title 进程生命周期与时间指标 ( Process Lifecycle Metrics )
    dateFormat s
    axisFormat %S
    tickInterval 1second
    
    section 进程 P1
    提交时刻 ( Arrival )        : milestone, m1, 0, 0s
    等待调度 ( Waiting )        : active, w1, 0, 3s
    首次被调度 ( First Run )    : crit, r1, 3, 2s
    首次响应( First Response ) : milestone, resp, 3, 0s
    I&#x2F;O 等待 ( Blocked )        : b1, after r1, 4s
    再次等待 ( Waiting )        : active, w2, after b1, 2s
    再次运行 ( Running )        : crit, r2, after w2, 3s
    完成时刻 ( Completion )     : milestone, fin, after r2, 0s

    section 指标度量
    响应时间 ( 0s -&gt; 3s )       : done, 0, 3s
    周转时间 ( 0s -&gt; 14s )      : done, 0, 14s
    等待时间( 3s + 2s &#x3D; 5s )   : active, 0, 5s
    运行时间( 2s + 3s &#x3D; 5s )   : crit, 0, 5s
  </pre></div>
<ul>
<li><strong>响应时间</strong> : 提交 (0s) <span
class="math inline">\(\rightarrow\)</span> 首次运行/响应 (3s) =
<strong>3s</strong></li>
<li><strong>等待时间</strong> : 灰色段总和 ( 3s + 2s ) =
<strong>5s</strong> ( 仅计算 <strong>就绪队列</strong> 中的等待 )</li>
<li><strong>运行时间</strong> : 红色段总和 ( 2s + 3s ) =
<strong>5s</strong></li>
<li><strong>周转时间</strong> : 提交 (0s) <span
class="math inline">\(\rightarrow\)</span> 完成 (14s) =
<strong>14s</strong></li>
<li><strong>带权周转</strong> : <span class="math inline">\(14 / 5 =
2.8\)</span></li>
</ul>
<h4 id="不同系统的侧重点">3. 不同系统的侧重点</h4>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">系统类型</th>
<th style="text-align: left;">核心目标</th>
<th style="text-align: left;">关注指标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>批处理系统</strong></td>
<td style="text-align: left;">吞吐量大，周转时间短，CPU 利用率高</td>
<td style="text-align: left;"><strong>系统吞吐量</strong>,
<strong>周转时间</strong>, CPU 利用率</td>
</tr>
<tr>
<td style="text-align: left;"><strong>分时系统</strong></td>
<td style="text-align: left;">响应快，均衡性</td>
<td style="text-align: left;"><strong>响应时间</strong> ( 关键 ), 均衡性
( 响应时间与复杂性成比例 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>实时系统</strong></td>
<td style="text-align: left;">截止时间保证，可预测性</td>
<td style="text-align: left;"><strong>满足截止时间</strong> ( Deadline
), 快速处理中断</td>
</tr>
</tbody>
</table>
<h3 id="进程切换-process-switching">2.2.4 进程切换 ( Process Switching
)</h3>
<h4 id="模式切换-vs-上下文切换">1. 模式切换 vs 上下文切换</h4>
<ul>
<li><strong>模式切换 ( Mode Switch )</strong> :
<ul>
<li><strong>定义</strong> : CPU 执行状态在 <strong>用户态 ( User Mode
)</strong> 与 <strong>内核态 ( Kernel Mode )</strong> 之间的切换.</li>
<li><strong>触发</strong> : 系统调用、中断、异常.</li>
<li><strong>内容</strong> : 仅需保存/恢复 <strong>少量寄存器</strong> (
PC, SP, PSW ) 到内核栈. <strong>不改变地址空间</strong> (
页表基址寄存器不变 ).</li>
<li><strong>开销</strong> : 较小.</li>
<li><strong>注意</strong> : 模式切换是进程切换的
<strong>前置条件</strong>，但模式切换 <strong>不一定</strong>
导致进程切换 ( 如: 简单的系统调用返回 ).</li>
</ul></li>
<li><strong>进程切换 ( Context Switch )</strong> :
<ul>
<li><strong>定义</strong> : CPU 从运行一个进程转为运行另一个进程.</li>
<li><strong>触发</strong> : 调度程序 ( Scheduler ) 决定抢占或主动放弃
CPU.</li>
<li><strong>内容</strong> : 需保存 <strong>完整上下文</strong> (
通用寄存器、浮点寄存器、<strong>页表基址/地址空间</strong> ).</li>
<li><strong>开销</strong> : 较大 ( 显式开销 + 隐式开销 ).</li>
</ul></li>
</ul>
<h4 id="进程切换的详细步骤">2. 进程切换的详细步骤</h4>
<ol type="1">
<li><strong>挂起当前进程</strong> :
<ul>
<li>保存 CPU 上下文 ( PC, SP, PSW, 通用寄存器 ) 到当前进程的
<strong>PCB</strong>.</li>
<li>更新 PCB 状态 ( 运行 <span
class="math inline">\(\rightarrow\)</span> 就绪/阻塞 )
并移入相应队列.</li>
</ul></li>
<li><strong>执行调度程序</strong> :
<ul>
<li>决定下一个要运行的进程.</li>
</ul></li>
<li><strong>恢复新进程</strong> :
<ul>
<li>更新新进程 PCB 状态 ( <span
class="math inline">\(\rightarrow\)</span> 运行 ).</li>
<li><strong>切换地址空间</strong> : 更新 CR3 / 页表基址寄存器 (
最昂贵的操作, 导致 TLB 失效 ).</li>
<li>恢复 CPU 上下文 ( 从新进程 PCB 载入寄存器 ).</li>
</ul></li>
</ol>
<h4 id="切换开销分析">3. 切换开销分析</h4>
<ul>
<li><strong>直接开销 ( 显式 )</strong> :
<ul>
<li>执行切换代码本身的指令 ( 保存/恢复寄存器 ).</li>
<li>内核调度算法的执行时间.</li>
</ul></li>
<li><strong>间接开销 ( 隐式 )</strong> :
<ul>
<li><strong>TLB 刷新</strong> : 切换地址空间导致 TLB ( 快表 ) 全部失效,
后续访存变慢.</li>
<li><strong>Cache 污染</strong> : 新进程的数据不在 L1/L2 Cache 中,
导致冷启动 ( Cache Miss ).</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef mode fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef ctx fill:#fef3c7,stroke:#d97706,stroke-width:2px,color:#b45309,rx:5,ry:5;
    
    subgraph ModeSwitch[&quot;模式切换&lt;br&#x2F;&gt;( Mode Switch )&quot;]
      direction TB
      U[&quot;用户态&lt;br&#x2F;&gt;( User )&quot;]:::mode &lt;--&gt;|中断&#x2F;系统调用| K[&quot;内核态&lt;br&#x2F;&gt;( Kernel )&quot;]:::mode
    end
    
    subgraph CtxSwitch[&quot;进程切换( Context Switch )&quot;]
      direction TB
      P1[&quot;进程 A&lt;br&#x2F;&gt;( Process A )&quot;]:::ctx --&gt;|保存上下文| S{&quot;调度器&lt;br&#x2F;&gt;( Scheduler )&quot;}:::default
      S --&gt;|恢复上下文&lt;br&#x2F;&gt;切换页表| P2[&quot;进程 B&lt;br&#x2F;&gt;( Process B )&quot;]:::ctx
    end
    
    K -.-&gt;|可能触发| CtxSwitch
    
    style ModeSwitch fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
    style CtxSwitch fill:#fffbeb,stroke:#f59e0b,stroke-dasharray: 5 5,stroke-width:2px
  </pre></div>
<h3 id="cpu-调度算法">2.2.5 CPU 调度算法</h3>
<p>调度算法可根据适用场景分为两类 : <strong>批处理系统</strong> (
追求吞吐量 ) 和 <strong>交互式/分时系统</strong> ( 追求响应时间 ).</p>
<h4 id="适用于批处理系统的算法">1. 适用于批处理系统的算法</h4>
<h5 id="先来先服务-fcfs-first-come-first-served">(1) 先来先服务 ( FCFS,
First-Come First-Served )</h5>
<ul>
<li><strong>规则</strong> : 严格按照作业/进程
<strong>到达就绪队列的顺序</strong> 进行服务.</li>
<li><strong>抢占性</strong> : <strong>非抢占</strong>.</li>
<li><strong>优点</strong> : 算法简单，公平 ( 对谁都一样 ).</li>
<li><strong>缺点</strong> :
<ul>
<li><strong>护航效应 ( Convoy Effect )</strong> : 如果一个长作业 ( CPU
密集型 ) 先到达，后续的短作业 ( I/O 密集型 )
必须长时间等待，导致平均等待时间剧增，I/O 设备利用率低.</li>
</ul></li>
<li><strong>适用</strong> : 作业调度，或作为优先级相同时的辅助规则.</li>
</ul>
<h5 id="短作业优先-sjf-shortest-job-first">(2) 短作业优先 ( SJF,
Shortest Job First )</h5>
<ul>
<li><strong>规则</strong> : 选择 <strong>估计运行时间最短</strong>
的进程.</li>
<li><strong>变种</strong> :
<ul>
<li><strong>非抢占式 ( SPF )</strong> :
进程一旦运行，直到完成或阻塞才释放 CPU.</li>
<li><strong>抢占式 ( SRTN - 最短剩余时间优先 )</strong> :
如果新到达进程的 <strong>剩余时间</strong> &lt;
当前运行进程的剩余时间，则立即抢占.</li>
</ul></li>
<li><strong>优点</strong> : 理论上拥有
<strong>最小的平均等待时间</strong> ( Greedy 策略 ).</li>
<li><strong>缺点</strong> :
<ul>
<li><strong>饥饿现象</strong> :
如果短作业源源不断，长作业可能永远得不到服务.</li>
<li><strong>预估困难</strong> : 很难准确预知作业的运行时间 (
依赖用户估计或历史统计 ).</li>
</ul></li>
</ul>
<h5 id="高响应比优先-hrrn-highest-response-ratio-next">(3) 高响应比优先
( HRRN, Highest Response Ratio Next )</h5>
<ul>
<li><strong>规则</strong> : 每次调度计算 <strong>响应比 <span
class="math inline">\(R_p\)</span></strong>，选择最高的进程. 综合了 FCFS
和 SJF 的优点.</li>
<li><strong>公式</strong> : <span class="math display">\[R_p =
\frac{\text{等待时间} + \text{要求服务时间}}{\text{要求服务时间}} = 1 +
\frac{\text{等待时间}}{\text{要求服务时间}}\]</span></li>
<li><strong>分析</strong> :
<ul>
<li><strong>等待时间相同</strong> : 服务时间越短，<span
class="math inline">\(R_p\)</span> 越高 ( 类 SJF ).</li>
<li><strong>服务时间相同</strong> : 等待时间越长，<span
class="math inline">\(R_p\)</span> 越高 ( 类 FCFS ).</li>
<li><strong>长作业</strong> : 随着等待时间增加，<span
class="math inline">\(R_p\)</span> 逐渐增加，最终会获得 CPU (
<strong>避免饥饿</strong> ).</li>
</ul></li>
<li><strong>抢占性</strong> : <strong>非抢占</strong>.</li>
<li><strong>缺点</strong> : 每次调度都要重新计算所有进程的 <span
class="math inline">\(R_p\)</span>，系统开销大.</li>
</ul>
<h4 id="适用于交互式系统的算法">2. 适用于交互式系统的算法</h4>
<h5 id="时间片轮转-rr-round-robin">(4) 时间片轮转 ( RR, Round Robin
)</h5>
<ul>
<li><strong>规则</strong> : 将 CPU 时间划分为固定长度的 <strong>时间片 (
Time Quantum, <span class="math inline">\(q\)</span>
)</strong>，就绪队列按 FCFS 排序，进程轮流执行一个时间片.
当进程执行完一个时间片后，无论是否完成，都必须释放 CPU
并回到就绪队列的尾部.</li>
<li><strong>抢占性</strong> : <strong>抢占式</strong> ( 时间片耗尽即抢占
).</li>
<li><strong>优点</strong> : <strong>响应快</strong>，公平 ( 没人能独占
CPU )，适用于交互式系统.</li>
<li><strong>缺点</strong> :
进程切换开销大，吞吐量受时间片大小影响较大.</li>
<li><strong>关键点 - 时间片 <span class="math inline">\(q\)</span>
的选择</strong> :
<ul>
<li><strong><span class="math inline">\(q\)</span> 太大</strong> :
退化为 FCFS，响应变慢，无法满足交互式系统的需求.</li>
<li><strong><span class="math inline">\(q\)</span> 太小</strong> :
进程切换过于频繁，<strong>上下文切换开销</strong> 占比过高 ( 吞吐量下降
).</li>
<li><strong>经验值</strong> : <span class="math inline">\(q\)</span>
通常取 10ms ~ 100ms，切换开销应 &lt; 1% 的 <span
class="math inline">\(q\)</span>.</li>
<li><strong>影响因素</strong> :
时间片大小应根据系统的硬件性能、进程数量、进程类型等因素进行调整.
对于交互式系统，应选择较小的时间片以提高响应速度;
对于批处理系统，应选择较大的时间片以减少进程切换开销.</li>
</ul></li>
<li><strong>适用场景</strong> : <strong>分时系统</strong> ( 交互式
)、通用操作系统.</li>
</ul>
<h5 id="优先级调度-priority-scheduling">(5) 优先级调度 ( Priority
Scheduling )</h5>
<ul>
<li><strong>定义</strong> : 每个进程具有一个
<strong>优先级</strong>，选择优先级最高者运行.</li>
<li><strong>抢占性</strong> : 可抢占/非抢占; 抢占式在更高优先级进程
<strong>到达/唤醒</strong> 时立即剥夺 CPU.</li>
<li><strong>优先级来源</strong> :
<ul>
<li><strong>静态优先级</strong> : 创建时确定 ( 系统进程 &gt; 用户进程;
交互型/I/O 型 &gt; 计算型 ).</li>
<li><strong>动态优先级</strong> : 随 <strong>等待时间/交互性/I/O
密集度</strong> 等变化.</li>
</ul></li>
<li><strong>饥饿与缓解</strong> :
<ul>
<li><strong>问题</strong> : 低优先级进程可能长期得不到运行 ( 饥饿
).</li>
<li><strong>老化 ( Aging )</strong> : 随等待时间提高优先级，例如
<code>priority = base + α · waiting_time</code>.</li>
</ul></li>
<li><strong>优先级反转与解决</strong> :
<ul>
<li><strong>反转</strong> :
低优线程持有锁，<strong>高优线程阻塞</strong>，而中优线程持续运行 →
高优实际被更低优”压制”.</li>
<li><strong>优先级继承</strong> : 持锁者 <strong>临时提升</strong>
到被阻塞者的优先级，直至释放锁.</li>
<li><strong>优先级上限协议</strong> : 进入受控区前提升至该资源的
<strong>上限优先级</strong>，防止反转发生.</li>
</ul></li>
<li><strong>细节与约束</strong> :
<ul>
<li>同优先级进程采用 <strong>FCFS</strong> 或 <strong>RR</strong>
作为次级规则.</li>
<li>I/O 型与交互型进程常给予更高优先级以提升 <strong>响应</strong>.</li>
<li>实时场景常结合 <strong>固定优先级策略</strong> ( 如 Rate Monotonic
)，与 <strong>EDF</strong> 的动态优先级不同.</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef thr fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef res fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef sch fill:#fef3c7,stroke:#d97706,stroke-width:2px,color:#b45309,rx:5,ry:5;
    classDef issue fill:#fee2e2,stroke:#dc2626,stroke-width:2px,color:#b91c1c,rx:5,ry:5;
    classDef fix fill:#dcfce7,stroke:#16a34a,stroke-width:2px,color:#15803d,rx:5,ry:5;

    subgraph Inversion[&quot;优先级反转 ( Priority Inversion )&quot;]
      direction TB
      H[&quot;高优线程 H&lt;br&#x2F;&gt;( High Prio )&quot;]:::thr --&gt;|&quot;请求&lt;br&#x2F;&gt;Request&quot;| R[&quot;共享资源&#x2F;锁&lt;br&#x2F;&gt;( Lock )&quot;]:::res
      L[&quot;低优线程 L&lt;br&#x2F;&gt;( Low Prio )&quot;]:::thr ---|&quot;持锁&lt;br&#x2F;&gt;Hold&quot;| R
      H -.-&gt;|&quot;阻塞等待 R&lt;br&#x2F;&gt;Blocked&quot;| OS1[&quot;调度器&lt;br&#x2F;&gt;( Scheduler )&quot;]:::sch
      M[&quot;中优线程 M&lt;br&#x2F;&gt;( Medium Prio )&quot;]:::thr --&gt;|&quot;抢占运行&lt;br&#x2F;&gt;Preempt&quot;| OS1
      
      NoteI[&quot;现象: H 被阻塞&lt;br&#x2F;&gt;M 持续运行&lt;br&#x2F;&gt;→ 反转&quot;]:::issue
    end

    subgraph Inherit[&quot;优先级继承 ( Priority Inheritance )&quot;]
      direction TB
      OS2[&quot;调度器&lt;br&#x2F;&gt;( Scheduler )&quot;]:::sch --&gt;|&quot;提升 L 优先级&lt;br&#x2F;&gt;至 H&quot;| L2[&quot;L ( 临时升优 )&lt;br&#x2F;&gt;( Boosted L )&quot;]:::fix
      L2 --&gt;|&quot;运行并释放 R&lt;br&#x2F;&gt;Release&quot;| R2[&quot;锁释放&lt;br&#x2F;&gt;( Unlocked )&quot;]:::res
      H2[&quot;高优线程 H&lt;br&#x2F;&gt;( High Prio )&quot;]:::thr --&gt;|&quot;获得 R 后运行&lt;br&#x2F;&gt;Acquire &amp; Run&quot;| OS2
    end
    
    style Inversion fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
    style Inherit fill:#f0fdf4,stroke:#16a34a,stroke-dasharray: 5 5,stroke-width:2px
  </pre></div>
<h5 id="多级反馈队列-multilevel-feedback-queue">(6) 多级反馈队列 (
Multilevel Feedback Queue )</h5>
<ul>
<li><strong>地位</strong> : <strong>集大成者</strong>，现代操作系统 ( 如
UNIX/Linux/Windows ) 调度算法的核心思想.</li>
<li><strong>规则</strong> :
<ol type="1">
<li><strong>多级队列</strong> : 设置多个就绪队列 <span
class="math inline">\(Q_1, Q_2, \dots, Q_n\)</span>，优先级逐级降低
(<span class="math inline">\(Q_1\)</span> 最高).</li>
<li><strong>时间片差异</strong> : 优先级越高的队列，时间片越短 (<span
class="math inline">\(Q_1\)</span> 最小); 优先级低的队列时间片长.</li>
<li><strong>进程流动</strong> :
<ul>
<li>新进程进入 <span class="math inline">\(Q_1\)</span>.</li>
<li>若在 <span class="math inline">\(Q_1\)</span>
时间片内未完成，<strong>降级</strong> 到 <span
class="math inline">\(Q_2\)</span> 队尾.</li>
<li>若在 <span class="math inline">\(Q_2\)</span>
仍未完成，<strong>降级</strong> 到 <span
class="math inline">\(Q_3\)</span>，依次类推.</li>
<li>最低级队列通常采用 <strong>RR</strong> 或
<strong>FCFS</strong>.</li>
</ul></li>
<li><strong>调度时机</strong> : 仅当高级队列 (<span
class="math inline">\(Q_1 \dots Q_{i-1}\)</span>) 为空时，才调度 <span
class="math inline">\(Q_i\)</span> 的进程.</li>
<li><strong>抢占</strong> :
若低级队列运行中，有新进程进入高级队列，则立即抢占.</li>
</ol></li>
<li><strong>策略细化</strong> :
<ul>
<li><strong>惩罚</strong> : 进程 <strong>用满时间片</strong>
且未发生阻塞/等待 → <strong>降级</strong> 到下一队列尾部 (
偏向计算密集型 ).</li>
<li><strong>奖励</strong> : 进程 <strong>时间片未用尽</strong> 就因
I/O/交互而阻塞或主动让权 → <strong>保持/提升</strong> 优先级 (
偏向交互/I/O 密集型 ).</li>
<li><strong>周期性提升 ( Priority Boost )</strong> :
每隔固定周期，将所有进程 <strong>提升</strong> 至较高队列 ( 常至 <span
class="math inline">\(Q_1\)</span> ) 以避免 <strong>饥饿</strong>.</li>
<li><strong>次级规则</strong> : 同队列内通常采用 <strong>RR</strong>;
最低级队列为 <strong>RR/FCFS</strong> 以降低调度开销.</li>
</ul></li>
<li><strong>优点</strong> :
<ul>
<li><strong>短作业</strong> : 在 <span
class="math inline">\(Q_1\)</span> 快速完成 ( 极佳的响应时间 ).</li>
<li><strong>长作业</strong> : 逐渐沉底到低级队列，利用长时间片运行 (
保证吞吐量 ).</li>
<li><strong>自适应</strong> : 无需预知作业运行时间.</li>
</ul></li>
<li><strong>参数建议</strong> :
<ul>
<li><strong>队列数 <span class="math inline">\(n\)</span></strong> :
常取 3~5 层，兼顾响应与开销.</li>
<li><strong>时间片序列</strong> : 可按 <strong>倍增</strong> 设计，如
<span class="math inline">\(q_1 &lt; q_2 = 2q_1 &lt; q_3 =
4q_1\)</span>.</li>
<li><strong>提升周期</strong> : 依据负载与交互性，典型取 0.5s~1s (
亦可按时钟滴答数 ).</li>
<li><strong>到达策略</strong> : 新到达进程置入 <span
class="math inline">\(Q_1\)</span>，突发交互任务能快速响应.</li>
</ul></li>
<li><strong>注意</strong> :
<ul>
<li><strong>I/O 型进程</strong> 倾向在高优队列循环 ( 奖励策略
)，获得更好响应.</li>
<li><strong>CPU 型进程</strong>
随用满时间片逐级下降，获得更长的连续运行时间.</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef q1 fill:#dcfce7,stroke:#16a34a,stroke-width:2px,color:#15803d,rx:5,ry:5;
    classDef q2 fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef q3 fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef act fill:#f3e8ff,stroke:#9333ea,stroke-width:2px,color:#7e22ce,rx:5,ry:5;
    classDef boost fill:#fef3c7,stroke:#d97706,stroke-width:2px,color:#b45309,rx:5,ry:5;

    subgraph Queues[&quot;多级反馈队列 ( MLFQ )&quot;]
      direction TB
      Q1[&quot;Q1 ( 高优 )&lt;br&#x2F;&gt;短时间片&quot;]:::q1
      Q2[&quot;Q2 ( 中优 )&lt;br&#x2F;&gt;中时间片&quot;]:::q2
      Q3[&quot;Q3 ( 低优 )&lt;br&#x2F;&gt;长时间片&quot;]:::q3
    end

    Q1 --&gt;|&quot;用满时间片&lt;br&#x2F;&gt;Timeout&quot;| Q2
    Q2 --&gt;|&quot;用满时间片&lt;br&#x2F;&gt;Timeout&quot;| Q3

    Q1 -.-&gt;|&quot;未用完&#x2F;I&#x2F;O&lt;br&#x2F;&gt;Yield&#x2F;Block&quot;| Q1
    Q2 -.-&gt;|&quot;未用完&#x2F;I&#x2F;O&lt;br&#x2F;&gt;Yield&#x2F;Block&quot;| Q1
    Q3 -.-&gt;|&quot;未用完&#x2F;I&#x2F;O&lt;br&#x2F;&gt;Yield&#x2F;Block&quot;| Q2

    Boost[&quot;周期性提升&lt;br&#x2F;&gt;( Priority Boost )&quot;]:::boost --&gt;|&quot;所有进程&lt;br&#x2F;&gt;Reset&quot;| Q1
    New[&quot;新进程到达&lt;br&#x2F;&gt;( New Process )&quot;]:::act --&gt;|&quot;进入&lt;br&#x2F;&gt;Enter&quot;| Q1
    
    style Queues fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
  </pre></div>
<h4 id="算法可视化对比-gantt-chart">3. 算法可视化对比 ( Gantt Chart
)</h4>
<p>假设有三个进程: P1(到达0, 服务8), P2(到达1, 服务4), P3(到达2,
服务1).</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  gantt
    title 调度算法对比 ( Comparison )
    dateFormat s
    axisFormat %S
    tickInterval 1second
    
    section 标记 (Arrival)
    到达 P1 (0s)               : milestone, a1, 0, 0s
    到达 P2 (1s)               : milestone, a2, 1, 0s
    到达 P3 (2s)               : milestone, a3, 2, 0s
    
    section FCFS (非抢占)
    P1(8s) :active, p1_fcfs, 0, 8s
    P2(4s) :p2_fcfs, after p1_fcfs, 4s
    P3(1s) :p3_fcfs, after p2_fcfs, 1s
    
    section SJF (非抢占)
    P1(8s) :active, p1_sjf, 0, 8s
    P3(1s) :crit, p3_sjf, after p1_sjf, 1s
    P2(4s) :p2_sjf, after p3_sjf, 4s

    section SRTN (抢占式 SJF)
    P1(运行1s) :active, p1_srtn1, 0, 1s
    P2(抢占, 运行1s) :crit, p2_srtn1, after p1_srtn1, 1s
    P3(抢占, 运行1s) :crit, p3_srtn, after p2_srtn1, 1s
    P2(续3s) :crit, p2_srtn2, after p3_srtn, 3s
    P1(续7s) :active, p1_srtn2, after p2_srtn2, 7s
    
    section RR (q&#x3D;4)
    P1(4s) :active, p1_rr1, 0, 4s
    P2(4s) :p2_rr1, after p1_rr1, 4s
    P3(1s) :crit, p3_rr1, after p2_rr1, 1s
    P1(续4s) :active, p1_rr2, after p3_rr1, 4s
    
    section MLFQ (q1&#x3D;2, q2&#x3D;4)
    P1@Q1(2s)            :active, p1_mlfq_q1_1, 0, 2s
    P2@Q1(2s)            :p2_mlfq_q1_1, after p1_mlfq_q1_1, 2s
    P3@Q1(1s 完成)       :crit, p3_mlfq_q1_1, after p2_mlfq_q1_1, 1s
    P1@Q2(4s)            :active, p1_mlfq_q2_1, after p3_mlfq_q1_1, 4s
    P2@Q2(2s 完成)       :p2_mlfq_q2_1, after p1_mlfq_q2_1, 2s
    P1@Q2(续2s 完成)     :active, p1_mlfq_q2_2, after p2_mlfq_q2_1, 2s

    section HRRN (非抢占)
    P1(8s)               :active, p1_hrrn, 0, 8s
    P3(1s 完成)          :crit, p3_hrrn, after p1_hrrn, 1s
    P2(4s 完成)          :p2_hrrn, after p3_hrrn, 4s

    section Priority (抢占式, P3&gt;P2&gt;P1)
    P1(prio&#x3D;1, 运行1s)    :active, p1_pri1, 0, 1s
    P2(prio&#x3D;2, 运行1s)    :crit, p2_pri1, after p1_pri1, 1s
    P3(prio&#x3D;3, 完成)      :crit, p3_pri, after p2_pri1, 1s
    P2(续3s 完成)         :p2_pri2, after p3_pri, 3s
    P1(续7s 完成)         :active, p1_pri2, after p2_pri2, 7s
  </pre></div>
<ul>
<li><strong>FCFS</strong> : P3 等待最久 ( 护航效应 ).</li>
<li><strong>SJF</strong> : P3 插队到了 P2 前面.</li>
<li><strong>SRTN</strong> : P2, P3 到达时都发生了抢占，P3 最先完成.</li>
<li><strong>RR</strong> : P1 被切分，P2, P3 获得较快响应.</li>
<li><strong>MLFQ</strong> : 短任务在高优队列迅速完成;
长任务逐级下沉，用更长时间片完成，兼顾响应与吞吐.</li>
<li><strong>HRRN</strong> : 初始仅 P1，随后按响应比选择，顺序 P1 → P3 →
P2.</li>
<li><strong>Priority (抢占式)</strong> : 更高优先级到达立即抢占，顺序
P1(1s) → P2(1s) → P3 完成 → P2 完成 → P1 完成.</li>
</ul>
<h3 id="算法特性对比速查">2.2.6 算法特性对比速查</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">算法</th>
<th style="text-align: left;">抢占性</th>
<th style="text-align: left;">优点</th>
<th style="text-align: left;">缺点</th>
<th style="text-align: left;">是否会导致饥饿</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>FCFS</strong></td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">简单、公平</td>
<td style="text-align: left;">护航效应、短作业等待长</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">批处理、辅助调度</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SJF/SPF</strong></td>
<td style="text-align: left;">否</td>
<td style="text-align: left;"><strong>平均等待时间最短</strong></td>
<td style="text-align: left;">需预知时间</td>
<td style="text-align: left;"><strong>是</strong> ( 长作业 )</td>
<td style="text-align: left;">理论研究</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SRTN</strong></td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">抢占式版本 SJF</td>
<td style="text-align: left;">开销大、需预知时间</td>
<td style="text-align: left;"><strong>是</strong></td>
<td style="text-align: left;">理论研究</td>
</tr>
<tr>
<td style="text-align: left;"><strong>HRRN</strong></td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">兼顾长短作业</td>
<td style="text-align: left;">计算响应比开销大</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">批处理系统</td>
</tr>
<tr>
<td style="text-align: left;"><strong>RR</strong></td>
<td style="text-align: left;">是</td>
<td style="text-align: left;"><strong>响应快</strong>、公平</td>
<td style="text-align: left;">切换开销大</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;"><strong>分时系统/交互式</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Priority</strong></td>
<td style="text-align: left;">否/是</td>
<td style="text-align: left;">灵活</td>
<td style="text-align: left;">低优先级饥饿</td>
<td style="text-align: left;"><strong>是</strong></td>
<td style="text-align: left;">实时系统</td>
</tr>
<tr>
<td style="text-align: left;"><strong>多级反馈</strong></td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">集大成者</td>
<td style="text-align: left;">算法复杂</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;"><strong>现代通用 OS</strong></td>
</tr>
</tbody>
</table>
<h3 id="多处理机调度-multiprocessor-scheduling">2.2.7 多处理机调度 (
Multiprocessor Scheduling )</h3>
<h4 id="基本模型">1. 基本模型</h4>
<ul>
<li><strong>AMP (非对称多处理)</strong> : 将调度/I-O 等集中在
<strong>单个主处理器</strong>，其他处理器仅执行用户进程;
实现简单但可扩展性差.</li>
<li><strong>SMP (对称多处理)</strong> : 每个处理器都运行
<strong>相同的内核调度逻辑</strong>; 主流通用 OS 采用.</li>
</ul>
<h4 id="就绪队列结构">2. 就绪队列结构</h4>
<ul>
<li><strong>全局就绪队列</strong> :
<ul>
<li><strong>优点</strong> : 简单、全局可见.</li>
<li><strong>缺点</strong> : <strong>大锁竞争</strong>、迁移频繁导致
<strong>缓存/TLB 失效</strong>.</li>
</ul></li>
<li><strong>每 CPU 就绪队列</strong> :
<ul>
<li><strong>优点</strong> : <strong>锁争用低</strong>、提升
<strong>缓存局部性</strong>.</li>
<li><strong>缺点</strong> : 需要 <strong>负载均衡/迁移策略</strong>
保持各队列均衡.</li>
</ul></li>
</ul>
<h4 id="处理器亲和性-affinity">3. 处理器亲和性 ( Affinity )</h4>
<ul>
<li><strong>软亲和</strong> : 优先让线程在 <strong>上次运行的
CPU</strong> 继续运行.</li>
<li><strong>硬绑定</strong> : 将线程 <strong>绑定到 CPU 集</strong> (
<code>CPU set/pin</code> )，仅在该集合内调度.</li>
<li><strong>收益</strong> : 提升 <strong>Cache/TLB
命中率</strong>，降低迁移开销.</li>
</ul>
<h4 id="负载均衡与迁移">4. 负载均衡与迁移</h4>
<ul>
<li><strong>工作窃取 ( Work Stealing )</strong> : 空闲 CPU 从
<strong>最繁忙队列尾部</strong> 窃取任务.</li>
<li><strong>推/拉 ( Push/Pull )</strong> :
<ul>
<li><strong>Push</strong> : 过载 CPU <strong>主动推送</strong>
任务到空闲 CPU.</li>
<li><strong>Pull</strong> : 空闲 CPU <strong>主动拉取</strong>
任务.</li>
</ul></li>
<li><strong>触发</strong> :
周期性时钟、队列不平衡阈值、线程唤醒时机.</li>
</ul>
<h4 id="numa-考量">5. NUMA 考量</h4>
<ul>
<li><strong>原则</strong> : 尽量在 <strong>本地节点</strong> 运行;
跨节点迁移会引入 <strong>远程内存访问</strong> 开销.</li>
<li><strong>策略</strong> : 首触发分配、内存绑定、跨节点均衡时
<strong>优先同节点</strong>.</li>
</ul>
<h4 id="并行作业与协同调度">6. 并行作业与协同调度</h4>
<ul>
<li><strong>Gang 调度</strong> : 将 <strong>同一并行作业的线程</strong>
在同一时间片内同时分配到多个 CPU，降低同步等待与负载不均.</li>
</ul>
<h4 id="超线程核心插槽">7. 超线程/核心/插槽</h4>
<ul>
<li><strong>优先顺序</strong> : 先
<strong>分散到不同物理核心</strong>，再填充同核心的
<strong>超线程</strong>，最后跨插槽/节点;
提升真实并行度与缓存局部性.</li>
</ul>
<h4 id="实践示例-linux-cfs">8. 实践示例 ( Linux CFS )</h4>
<ul>
<li><strong>每 CPU 运行队列 (<code>rq</code>)</strong>，按
<strong><code>vruntime</code></strong> 选择最小者运行.</li>
<li><strong>分层均衡</strong> : <code>scheduler domain/group</code> 描述
<strong>拓扑</strong> ( SMT/核心/NUMA 节点/系统 )，按层级周期均衡.</li>
<li><strong>迁移决策</strong> : 综合
<strong>亲和</strong>、<strong>队列负载</strong>、<strong>拓扑层级</strong>、<strong>任务类型</strong>.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef cpu fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef rq fill:#fef3c7,stroke:#d97706,stroke-width:2px,color:#b45309,rx:5,ry:5;
    classDef act fill:#dcfce7,stroke:#16a34a,stroke-width:2px,color:#15803d,rx:5,ry:5;
    classDef warn fill:#fee2e2,stroke:#dc2626,stroke-width:2px,color:#b91c1c,rx:5,ry:5;

    subgraph CPU0[&quot;CPU0&quot;]
      RQ0[&quot;就绪队列 rq0&quot;]:::rq
    end
    subgraph CPU1[&quot;CPU1&quot;]
      RQ1[&quot;就绪队列 rq1&quot;]:::rq
    end
    subgraph CPU2[&quot;CPU2&quot;]
      RQ2[&quot;就绪队列 rq2&quot;]:::rq
    end

    New[&quot;新线程唤醒&lt;br&#x2F;&gt;(prev_cpu&#x3D;CPU0)&quot;]:::act --&gt;|&quot;软亲和&quot;| RQ0
    Over[&quot;CPU0 过载&quot;]:::warn --&gt;|&quot;Push&quot;| RQ1
    Idle[&quot;CPU2 空闲&quot;]:::act --&gt;|&quot;Work Stealing&quot;| RQ0

    NUMA[&quot;NUMA&lt;br&#x2F;&gt;优先本节点&quot;]:::act -.-&gt; RQ1
    
    style CPU0 fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
    style CPU1 fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
    style CPU2 fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
  </pre></div>
<h4 id="架构对比">9. 架构对比</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">设计</th>
<th style="text-align: left;">优点</th>
<th style="text-align: left;">缺点</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>全局就绪队列</strong></td>
<td style="text-align: left;">简单、全局公平</td>
<td style="text-align: left;">大锁争用、迁移频繁、缓存失效</td>
<td style="text-align: left;">小规模系统、教学演示</td>
</tr>
<tr>
<td style="text-align: left;"><strong>每 CPU 就绪队列</strong></td>
<td style="text-align: left;">争用低、局部性好、可扩展</td>
<td style="text-align: left;">需周期均衡与迁移策略</td>
<td style="text-align: left;">主流 SMP 通用 OS</td>
</tr>
<tr>
<td style="text-align: left;"><strong>分层调度域
(Topology-aware)</strong></td>
<td style="text-align: left;">贴合 SMT/核心/NUMA 拓扑、均衡精细</td>
<td style="text-align: left;">复杂度高、参数调优难</td>
<td style="text-align: left;">现代多核/多节点系统</td>
</tr>
</tbody>
</table>
<h4 id="关键实现要点-以-linux-为例">10. 关键实现要点 ( 以 Linux 为例
)</h4>
<ul>
<li><strong>负载度量</strong> : <strong>PELT</strong> 平滑负载跟踪 (
<code>util_avg</code> )，用于比较队列与任务负载.</li>
<li><strong>容量感知</strong> : CPU <strong>capacity</strong>
随频率/功耗状态/SMT 变化; 调度按 <code>util_avg / capacity</code>
做公平与放置.</li>
<li><strong>唤醒放置</strong> : <code>select_task_rq</code>
在唤醒/创建时选择 CPU，优先同节点/同核心，避免冷缓存与远程内存.</li>
<li><strong>均衡类型</strong> :
<ul>
<li><strong>空闲均衡 ( Idle Balance )</strong> : 空闲 CPU 主动拉取任务 (
低干扰 ).</li>
<li><strong>主动均衡 ( Active Balance )</strong> : 周期或阈值触发，繁忙
CPU 推送任务 ( 干扰较大 ).</li>
</ul></li>
<li><strong>迁移成本</strong> : <strong>Cache 热度/NUMA
远程访问</strong>，常以
<code>sched_migration_cost</code>/热度窗口约束频繁迁移.</li>
<li><strong>NOHZ/时钟抑制</strong> :
在空闲核减少计时器中断，均衡需兼顾唤醒路径与域层触发.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    classDef default fill:#f1f5f9,stroke:#64748b,stroke-width:2px,color:#1e293b,rx:5,ry:5;
    classDef dom fill:#e0f2fe,stroke:#0284c7,stroke-width:2px,color:#0369a1,rx:5,ry:5;
    classDef cpu fill:#fef3c7,stroke:#d97706,stroke-width:2px,color:#b45309,rx:5,ry:5;
    classDef act fill:#dcfce7,stroke:#16a34a,stroke-width:2px,color:#15803d,rx:5,ry:5;
    classDef warn fill:#fee2e2,stroke:#dc2626,stroke-width:2px,color:#b91c1c,rx:5,ry:5;

    subgraph NUMA0[&quot;NUMA 节点 0&quot;]
      subgraph Socket0[&quot;插槽 0 ( Socket )&quot;]
        subgraph Core0[&quot;核心 0 ( Core )&quot;]
          direction TB
          CPU0[&quot;CPU0 (SMT 线程)&quot;]:::cpu
          CPU1[&quot;CPU1 (SMT 线程)&quot;]:::cpu
        end
        subgraph Core1[&quot;核心 1 ( Core )&quot;]
          direction TB
          CPU2[&quot;CPU2&quot;]:::cpu
          CPU3[&quot;CPU3&quot;]:::cpu
        end
      end
    end
    
    class NUMA0,Socket0,Core0,Core1 dom

    Wake[&quot;线程唤醒&lt;br&#x2F;&gt;( Wakeup )&quot;]:::act --&gt;|&quot;select_task_rq&lt;br&#x2F;&gt;软亲和&#x2F;同节点&quot;| CPU0
    Busy[&quot;Core0 过载&lt;br&#x2F;&gt;( Overload )&quot;]:::warn --&gt;|&quot;域均衡&lt;br&#x2F;&gt;Push 到 Core1&quot;| CPU2
    IdleC3[&quot;CPU3 空闲&lt;br&#x2F;&gt;( Idle )&quot;]:::act --&gt;|&quot;Idle Balance&lt;br&#x2F;&gt;拉取任务&quot;| CPU0
    
    %% 使用虚线连接注释，避免孤立节点
    CPU1 -.-&gt; Note[&quot;容量感知&lt;br&#x2F;&gt;频率&#x2F;SMT 影响公平&quot;]:::act
    
    style NUMA0 fill:#f8fafc,stroke:#94a3b8,stroke-dasharray: 5 5,stroke-width:2px
    style Socket0 fill:#f1f5f9,stroke:#64748b,stroke-dasharray: 5 5,stroke-width:2px
    style Core0 fill:#e2e8f0,stroke:#475569,stroke-dasharray: 5 5,stroke-width:2px
    style Core1 fill:#e2e8f0,stroke:#475569,stroke-dasharray: 5 5,stroke-width:2px
  </pre></div>
<h2 id="同步与互斥">2.3 同步与互斥</h2>
<h3 id="同步与互斥的基本概念">2.3.1 同步与互斥的基本概念</h3>
<ul>
<li><strong>并发与竞态</strong> : 并发是同时推进，<strong>竞态</strong>
是结果依赖执行时序; 消除竞态需同步/互斥.</li>
<li><strong>临界资源</strong> : 一次仅允许一个执行实体使用的资源 (
如打印机、共享变量、文件句柄 ).</li>
<li><strong>临界区</strong> :
访问临界资源的代码片段，进入与退出需遵循协议.</li>
<li><strong>同步 ( 直接制约 )</strong> : 为满足
<strong>因果/时序</strong> 关系而协作，例如
“先生产后消费”、“先初始化后使用”.</li>
<li><strong>互斥 ( 间接制约 )</strong> :
为避免同时进入临界区而竞争资源，确保同一时刻仅一个执行实体访问.</li>
</ul>
<div class="note sparkle simple"><p><strong>注</strong>同步与互斥 必须遵守的准则</p>
<ol type="1">
<li><strong>空闲让进</strong> ( 互斥的铁律 ) :
临界区空闲时，应允许一个请求进入临界区的进程立即进入.</li>
<li><strong>忙则等待</strong> ( 互斥的铁律 ) :
当已有进程在临界区时，其他试图进入临界区的进程必须等待.</li>
<li><strong>有限等待</strong> ( 同步的铁律 ) :
对请求访问的进程，应保证能在有限时间内进入临界区 ( 防止 “死等” / “饥饿”
).</li>
<li><strong>让权等待</strong> ( 加分项 ) :
当进程不能进入临界区时，应立即释放处理机，防止进程处于 “忙等” 状态 (
阻塞而非忙等，非必须但推荐 ).</li>
</ol>
</div>
<h4 id="临界资源访问过程">临界资源访问过程</h4>
<ul>
<li><p><strong>进入区</strong> ( Entry )<br />
发起进入临界区的协议阶段，用于”申请与等待”共享资源的访问权.
常见做法是加锁或 P 操作：成功则进入临界区，失败则自旋或入队阻塞等待;
该阶段应满足互斥、公平与有限等待等准则，避免优先级反转.</p></li>
<li><p><strong>临界区</strong> ( Critical Section )<br />
真正访问共享数据或临界资源的代码片段.
该区域应尽量短小，避免执行可能阻塞或耗时的操作，降低持锁时间;
在此阶段维持数据不变式与一致性，禁止并发访问导致竞态.</p></li>
<li><p><strong>退出区</strong> ( Exit )<br />
释放访问权并进行必要的状态更新与唤醒通知. 典型操作为解锁或 V
操作，并根据策略唤醒等待队列中的下一线程 ( 如 FIFO/优先级唤醒/公平唤醒 )
，以防饥饿并提升系统吞吐.</p></li>
<li><p><strong>剩余区</strong> ( Remainder Section )<br />
非临界工作阶段，不需要访问共享数据或临界资源.
适合执行计算、I/O、准备下一次进入区的输入等;
将耗时工作放在剩余区，有助于缩短持锁时长，提升并发效率.</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  acquire();    <span class="comment">// 进入区：申请互斥 ( 锁/原语 ) ，失败则等待</span></span><br><span class="line">  critical();   <span class="comment">// 临界区：访问共享数据/资源，尽量缩短持锁时间</span></span><br><span class="line">  release();    <span class="comment">// 退出区：释放互斥并唤醒等待者 ( 若有 ) </span></span><br><span class="line">  remainder();  <span class="comment">// 剩余区：非共享工作，准备下一次进入区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> mutex = (<span class="type">sem_t</span>)&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  P(&amp;mutex);     <span class="comment">// 进入区：P(wait) 申请互斥信号量，失败则阻塞入队</span></span><br><span class="line">  critical();    <span class="comment">// 临界区：访问临界资源</span></span><br><span class="line">  V(&amp;mutex);     <span class="comment">// 退出区：V(signal) 释放互斥并唤醒一个等待者</span></span><br><span class="line">  remainder();   <span class="comment">// 剩余区：不涉及共享资源的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:6,ry:6;
    classDef run fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1;
    classDef wait fill:#FDE68A,stroke:#CA8A04,stroke-width:2px,color:#7C2D12;
    classDef crit fill:#22D3EE,stroke:#0E7490,stroke-width:2px,color:#FFFFFF;

    A[&quot;非临界区&quot;]:::run --&gt; ACQ[&quot;尝试获取互斥锁&lt;br&#x2F;&gt;( acquire )&quot;]:::wait
    ACQ --&gt;|成功| CS[&quot;进入临界区&quot;]:::crit --&gt; REL[&quot;释放互斥锁&lt;br&#x2F;&gt;( release )&quot;]:::wait --&gt; A
    ACQ --&gt;|失败| Q[&quot;等待 &#x2F; 阻塞队列&quot;]:::wait --&gt; ACQ
  </pre></div>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
sequenceDiagram
    participant P as 生产者
    participant C as 消费者
    participant S as 同步原语 (empty&#x2F;full)
    Note over P,S: 同步确保&quot;先生产后消费&quot;
    P-&gt;&gt;S: signal(full) &#x2F; wait(empty)
    P-&gt;&gt;C: 提供数据
    C-&gt;&gt;S: signal(empty) &#x2F; wait(full)
    C-&gt;&gt;C: 消费数据
  </pre></div>
<h3 id="实现临界区互斥的基本方法">2.3.2 实现临界区互斥的基本方法</h3>
<h4 id="软件实现">软件实现</h4>
<h5 id="单标志法">单标志法</h5>
<p>通过单一标志变量指示允许进入者，简单但无法同时保证互斥、进度与有限等待，易饥饿;
在多核与编译器优化下不可靠.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(turn == <span class="number">0</span>)&#123;        <span class="comment">// 允许 P0 进入的轮次</span></span><br><span class="line">      critical();         <span class="comment">// 无法保证互斥与有限等待，仅示意</span></span><br><span class="line">      turn = <span class="number">1</span>;           <span class="comment">// 切换轮次给 P1</span></span><br><span class="line">    &#125;</span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(turn == <span class="number">1</span>)&#123;        <span class="comment">// 允许 P1 进入的轮次</span></span><br><span class="line">      critical();         <span class="comment">// 仍可能饥饿/破坏互斥</span></span><br><span class="line">      turn = <span class="number">0</span>;           <span class="comment">// 切换轮次给 P0</span></span><br><span class="line">    &#125;</span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双标志先检查">双标志先检查</h5>
<p>先检查对方是否想进入再决定是否进入，存在竞态窗口导致双方同时进入破坏互斥;
冲突时缺少公平与退避策略，易
<strong>活锁</strong>/<strong>饥饿</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[<span class="number">1</span>] == <span class="number">0</span>)&#123;     <span class="comment">// 先检查对方是否想进入</span></span><br><span class="line">      flag[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">// 再声明意愿 ( 有竞态窗口 ) </span></span><br><span class="line">      critical();         <span class="comment">// 可能双方同时进入，破坏互斥</span></span><br><span class="line">      flag[<span class="number">0</span>] = <span class="number">0</span>;        <span class="comment">// 退出后清除意愿</span></span><br><span class="line">    &#125;</span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[<span class="number">0</span>] == <span class="number">0</span>)&#123;     <span class="comment">// 先检查对方</span></span><br><span class="line">      flag[<span class="number">1</span>] = <span class="number">1</span>;        <span class="comment">// 后声明意愿 ( 存在竞态 ) </span></span><br><span class="line">      critical();         <span class="comment">// 不保证互斥/公平</span></span><br><span class="line">      flag[<span class="number">1</span>] = <span class="number">0</span>;        <span class="comment">// 退出清意愿</span></span><br><span class="line">    &#125;</span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双标志后检查">双标志后检查</h5>
<p>先声明意愿再检查对方，较稳健但仍需协商避免活锁与饥饿，难以严格保证
<strong>有限等待</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="number">1</span>;          <span class="comment">// 先声明意愿</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>])&#123;&#125;      <span class="comment">// 后检查对方意愿，忙等</span></span><br><span class="line">    critical();           <span class="comment">// 仍可能饥饿/活锁 ( 缺公平 ) </span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="number">0</span>;          <span class="comment">// 退出清意愿</span></span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="number">1</span>;          <span class="comment">// 声明意愿</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>])&#123;&#125;      <span class="comment">// 忙等对方清除意愿</span></span><br><span class="line">    critical();           <span class="comment">// 不保证有限等待</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 退出清意愿</span></span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="peterson-算法">Peterson 算法</h5>
<p>两线程互斥的经典方案，借助 turn
协商让权，可证明互斥、进度、<strong>有限等待</strong> 与
<strong>让权等待</strong> 成立;
弱内存模型需配合屏障，扩展到多线程复杂度高.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="number">1</span>;              <span class="comment">// 声明 P0 想进入</span></span><br><span class="line">    turn = <span class="number">1</span>;                 <span class="comment">// 让权给 P1：冲突时优先 P1</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>)&#123;&#125;  <span class="comment">// 若 P1 也想进且轮到 P1，则等待</span></span><br><span class="line">    critical();               <span class="comment">// 进入临界区 ( 保证互斥/有限等待 ) </span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="number">0</span>;              <span class="comment">// 退出清意愿</span></span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="number">1</span>;              <span class="comment">// 声明 P1 想进入</span></span><br><span class="line">    turn = <span class="number">0</span>;                 <span class="comment">// 让权给 P0</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>)&#123;&#125;  <span class="comment">// 冲突时等待 P0</span></span><br><span class="line">    critical();               <span class="comment">// 进入临界区</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="number">0</span>;              <span class="comment">// 退出清意愿</span></span><br><span class="line">    remainder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="硬件实现">硬件实现</h4>
<h5 id="中断屏蔽-interrupt-disabling">中断屏蔽 ( Interrupt Disabling
)</h5>
<p>通过”关中断”指令禁止 CPU
响应中断，从而防止进程切换，保证临界区代码的原子性执行.</p>
<ul>
<li><strong>原理</strong> : CPU 只有在发生中断时才可能进行进程调度.
进入临界区前执行 <code>cli</code> ( 关中断 )，退出后执行
<code>sti</code> ( 开中断 ).</li>
<li><strong>优点</strong> : 简单、高效.</li>
<li><strong>缺点</strong> :
<ol type="1">
<li><strong>不适用于多处理器 ( SMP )</strong> : 关中断仅对当前 CPU
有效，无法防止其他 CPU 上的进程进入临界区.</li>
<li><strong>安全性</strong> : 若允许用户进程使用，可能导致系统挂起 (
忘记开中断 ). 通常仅限于内核态使用.</li>
</ol></li>
</ul>
<h5 id="test-and-set-ts-指令">Test-and-Set ( TS ) 指令</h5>
<p>硬件提供的原子指令，用于读取并设置内存值. 也称为 <code>TSL</code> (
Test-and-Set-Lock ).</p>
<ul>
<li><strong>指令逻辑 ( 原子操作 )</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述硬件逻辑：读出旧值，写入 TRUE，返回旧值</span></span><br><span class="line">boolean <span class="title function_">TestAndSet</span><span class="params">(boolean *target)</span> &#123;</span><br><span class="line">    boolean rv = *target; </span><br><span class="line">    *target = <span class="literal">true</span>;       </span><br><span class="line">    <span class="keyword">return</span> rv;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实现互斥</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> boolean lock = <span class="literal">false</span>; <span class="comment">// 共享锁变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P_TS</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;lock)); <span class="comment">// 自旋：若 lock 原为 true 则循环; 若为 false 则设为 true 并退出循环</span></span><br><span class="line">  critical();</span><br><span class="line">  lock = <span class="literal">false</span>;              <span class="comment">// 退出区：释放锁</span></span><br><span class="line">  remainder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong> :
<ul>
<li><strong>优点</strong> : 适用于多处理器环境; 代码简单;
支持多个临界区.</li>
<li><strong>缺点</strong> : <strong>忙等待</strong> ( Busy Waiting
)，消耗 CPU 时间; 可能导致 <strong>饥饿</strong> ( Starvation );
可能导致 <strong>死锁</strong> ( 若低优先级进程持有锁而被高优先级抢占
).</li>
</ul></li>
</ul>
<h5 id="swap-指令-exchange">Swap 指令 ( Exchange )</h5>
<p>硬件提供的原子交换两个变量值的指令.</p>
<ul>
<li><strong>指令逻辑 ( 原子操作 )</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述硬件逻辑：交换 a 和 b 的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(boolean *a, boolean *b)</span> &#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实现互斥</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> boolean lock = <span class="literal">false</span>; <span class="comment">// 全局锁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P_Swap</span><span class="params">()</span>&#123;</span><br><span class="line">  boolean key = <span class="literal">true</span>;          <span class="comment">// 局部变量，初始化为 true</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    Swap(&amp;lock, &amp;key);         <span class="comment">// 原子交换：若 lock 为 false，则 key 变为 false，退出循环</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (key);</span><br><span class="line">  </span><br><span class="line">  critical();</span><br><span class="line">  </span><br><span class="line">  lock = <span class="literal">false</span>;                <span class="comment">// 退出区：释放锁</span></span><br><span class="line">  remainder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong> : 与 TS
指令类似，属于忙等待机制，需要硬件支持.</li>
</ul>
<h3 id="互斥锁-mutex">2.3.3 互斥锁 ( Mutex )</h3>
<p>互斥锁是一种用于多线程/多进程编程中，防止多条线程同时对同一公共资源进行读写的机制.</p>
<ul>
<li><strong>基本操作</strong> :
<ul>
<li><code>acquire()</code> ( 或 <code>lock</code> ) : 获得锁.
若锁不可用，则阻塞或忙等待.</li>
<li><code>release()</code> ( 或 <code>unlock</code> ) : 释放锁.</li>
</ul></li>
<li><strong>两种实现形态</strong> :
<ol type="1">
<li><strong>自旋锁 ( Spinlock )</strong> :
<ul>
<li><strong>机制</strong> : <strong>忙等待</strong> ( Busy Waiting ).
进程不断循环检测锁的状态，直到获取锁.</li>
<li><strong>适用</strong> : 预计等待时间很短，且运行在多核 CPU 上 (
避免上下文切换开销 ).</li>
<li><strong>缺点</strong> :
若持有锁的线程被抢占或阻塞，等待线程会白白浪费 CPU.</li>
</ul></li>
<li><strong>阻塞锁 ( Blocking Mutex )</strong> :
<ul>
<li><strong>机制</strong> : <strong>睡眠等待</strong> ( Sleep Waiting ).
若无法获取锁，进程调用 <code>yield</code> 让出 CPU
并进入阻塞队列，等待被 <code>wakeup</code>.</li>
<li><strong>适用</strong> : 临界区较长，或单核 CPU 环境.</li>
<li><strong>缺点</strong> : 涉及进程上下文切换 ( Context Switch
)，开销较大.</li>
</ul></li>
</ol></li>
<li><strong>伪代码示例 ( 自旋锁实现 )</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需配合硬件原子指令 ( 如 TS ) 使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(boolean *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(lock)); <span class="comment">// 循环检测，直到 lock 原值为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(boolean *lock)</span> &#123;</span><br><span class="line">    *lock = <span class="literal">false</span>;            <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信号量-semaphore">2.3.4 信号量 ( Semaphore )</h3>
<p>由 Dijkstra 提出的有效进程同步机制. 信号量 <code>S</code>
是一个整数变量，除了初始化外，只能通过两个标准原子操作
<code>wait(S)</code> ( P操作 ) 和 <code>signal(S)</code> ( V操作 )
来访问.</p>
<ul>
<li><strong>wait(S) / P 操作</strong> :
<ul>
<li><strong>P</strong> 来自荷兰语 <em>Proberen</em> ( 意为”测试” ).</li>
<li><strong>功能</strong> : <strong>申请资源</strong>. 逻辑上，若
<code>S &gt; 0</code>，则分配资源 ( <code>S</code> 减 1 ); 若
<code>S &lt;= 0</code>，则进程需要等待 ( 忙等或阻塞
)，直到有可用资源.</li>
</ul></li>
<li><strong>signal(S) / V 操作</strong> :
<ul>
<li><strong>V</strong> 来自荷兰语 <em>Verhogen</em> ( 意为”增加” ).</li>
<li><strong>功能</strong> : <strong>释放资源</strong>.
逻辑上，<code>S</code> 加
1，并可能需要唤醒一个正在等待该资源的进程.</li>
</ul></li>
</ul>
<h4 id="整型信号量-integer-semaphore">1. 整型信号量 ( Integer Semaphore
)</h4>
<p>用一个整数型变量作为信号量，表示系统中某种资源的数量.</p>
<ul>
<li><strong>机制</strong> :
<ul>
<li><code>wait(S)</code> : 只要 <code>S &lt;= 0</code> 就不断测试 (
自旋/忙等 ); 若 <code>S &gt; 0</code> 则 <code>S--</code>.</li>
<li><code>signal(S)</code> : <code>S++</code>.</li>
</ul></li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设操作是原子的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *S)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*S &lt;= <span class="number">0</span>); <span class="comment">// 忙等待 ( Busy Waiting )：若资源不足，一直循环测试</span></span><br><span class="line">    (*S)--;          <span class="comment">// 资源充足，消耗一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> *S)</span> &#123;</span><br><span class="line">    (*S)++;          <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>缺点</strong> : 未遵循”让权等待”原则，存在
<strong>忙等待</strong> 现象.</li>
</ul>
<h4 id="记录型信号量-record-semaphore">2. 记录型信号量 ( Record
Semaphore )</h4>
<p>为了解决忙等待问题，在信号量中增加一个进程链表
<code>L</code>，用于链接所有等待该资源的阻塞进程.</p>
<ul>
<li><strong>数据结构</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;          <span class="comment">// 资源剩余数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>  <span class="comment">// 等待队列 ( 阻塞队列 )</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li>
<li><strong>P 操作 ( wait )</strong> : 申请资源 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore *S)</span> &#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        add_to_queue(S-&gt;L, running_process); <span class="comment">// 加入等待队列</span></span><br><span class="line">        block();                             <span class="comment">// 自我阻塞，放弃 CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong> : <code>S.value</code> 减 1 表示申请一个资源.
若减后 <code>&lt; 0</code>，表示无资源，进程需阻塞等待. 此时
<code>|S.value|</code> 表示等待队列中的进程数.</li>
</ul></li>
<li><strong>V 操作 ( signal )</strong> : 释放资源 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore *S)</span> &#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">process_t</span> *p = remove_from_queue(S-&gt;L); <span class="comment">// 从队列移出进程 p</span></span><br><span class="line">        wakeup(p);                              <span class="comment">// 唤醒进程 p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong> : <code>S.value</code> 加 1 表示释放一个资源.
若加后 <code>&lt;= 0</code>，表示队列中仍有等待进程，需唤醒一个.</li>
</ul></li>
</ul>
<h4 id="信号量的应用">3. 信号量的应用</h4>
<h5 id="实现进程互斥-mutual-exclusion">(1) 实现进程互斥 ( Mutual
Exclusion )</h5>
<p>用于多个进程互斥地访问临界资源.</p>
<ul>
<li><strong>原则</strong> :
<ul>
<li>设 <strong>互斥信号量</strong> <code>mutex</code>，初始值为
<strong>1</strong> ( 表示有一个可用资源 ).</li>
<li>将临界区代码置于 <code>P(mutex)</code> 和 <code>V(mutex)</code>
之间.</li>
<li>必须成对使用，且不能颠倒顺序.</li>
</ul></li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex);     <span class="comment">// 申请进入临界区 ( 加锁 )</span></span><br><span class="line">    critical_section();</span><br><span class="line">    V(mutex);     <span class="comment">// 退出临界区 ( 解锁 )</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex);     <span class="comment">// 若 P1 已进入，P2 阻塞等待</span></span><br><span class="line">    critical_section();</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="实现进程同步-synchronization">(2) 实现进程同步 ( Synchronization
)</h5>
<p>用于协调进程间的执行顺序，实现”一前一后”的约束.</p>
<ul>
<li><strong>原则</strong> :
<ul>
<li>设 <strong>同步信号量</strong> <code>S</code>，初始值为
<strong>0</strong> ( 表示”前操作”尚未完成 ).</li>
<li><strong>前操作</strong> ( 先执行 ) 之后执行 <code>V(S)</code> (
释放信号 ).</li>
<li><strong>后操作</strong> ( 后执行 ) 之前执行 <code>P(S)</code> (
等待信号 ).</li>
<li>口诀：<strong>前V后P</strong>.</li>
</ul></li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    code1();      <span class="comment">// 前操作</span></span><br><span class="line">    V(S);         <span class="comment">// 发送信号：code1 已完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    P(S);         <span class="comment">// 等待信号：等待 code1 完成</span></span><br><span class="line">    code2();      <span class="comment">// 后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="实现前趋关系-precedence-graph">(3) 实现前趋关系 ( Precedence
Graph )</h5>
<p>用于描述复杂的进程执行顺序 ( 有向无环图 DAG ).</p>
<ul>
<li><strong>原理</strong> : 为每一对前趋关系 ( 每一条有向边 )
设置一个同步信号量，初值为 0.</li>
<li><strong>示例</strong> : 设任务顺序为 <span class="math inline">\(S_1
\to S_2, S_1 \to S_3, S_2 \to S_4, S_3 \to S_4\)</span>.
<ul>
<li>需要 4 个信号量：<span class="math inline">\(a (S_1 \to S_2), b (S_1
\to S_3), c (S_2 \to S_4), d (S_3 \to S_4)\)</span>.</li>
<li><strong>前趋图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TD
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    S1((S1)) --&gt;|a| S2((S2))
    S1 --&gt;|b| S3((S3))
    S2 --&gt;|c| S4((S4))
    S3 --&gt;|d| S4
  </pre></div></li>
</ul></li>
<li><strong>代码结构</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123; S1; V(a); V(b); &#125; <span class="comment">// S1 完成后，通知 S2, S3 可开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123; P(a); S2; V(c); &#125; <span class="comment">// 等 S1; S2 完成后，通知 S4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P3</span><span class="params">()</span> &#123; P(b); S3; V(d); &#125; <span class="comment">// 等 S1; S3 完成后，通知 S4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P4</span><span class="params">()</span> &#123; P(c); P(d); S4; &#125; <span class="comment">// 等 S2, S3 都完成; 开始 S4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="经典同步问题">2.3.5 经典同步问题</h3>
<h4 id="生产者-消费者问题-producer-consumer-problem">1.
生产者-消费者问题 ( Producer-Consumer Problem )</h4>
<ul>
<li><strong>问题描述</strong> :
一组生产者进程和一组消费者进程共享一个初始为空、大小为 <code>n</code>
的缓冲区.
<ul>
<li><strong>生产者</strong> : 生产数据放入缓冲区.
若缓冲区满，则阻塞.</li>
<li><strong>消费者</strong> : 从缓冲区取数据消费.
若缓冲区空，则阻塞.</li>
<li><strong>互斥</strong> : 缓冲区是临界资源，需互斥访问.</li>
</ul></li>
<li><strong>信号量设置</strong> :
<ul>
<li><code>mutex = 1</code> : 实现对缓冲区的互斥访问.</li>
<li><code>empty = n</code> : 同步信号量，表示空闲缓冲区的数量.</li>
<li><code>full = 0</code> : 同步信号量，表示非空缓冲区的数量 ( 产品数量
).</li>
</ul></li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>, empty=n, full=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        produce_item(&amp;item);</span><br><span class="line">        P(empty);       <span class="comment">// 申请空闲位 (若无空位则阻塞)</span></span><br><span class="line">        P(mutex);       <span class="comment">// 申请互斥锁</span></span><br><span class="line">        put_item(item); <span class="comment">// 放入缓冲区</span></span><br><span class="line">        V(mutex);       <span class="comment">// 释放互斥锁</span></span><br><span class="line">        V(full);        <span class="comment">// 增加产品数 (唤醒消费者)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(full);        <span class="comment">// 申请产品 (若无产品则阻塞)</span></span><br><span class="line">        P(mutex);       <span class="comment">// 申请互斥锁</span></span><br><span class="line">        get_item(&amp;item);<span class="comment">// 取出产品</span></span><br><span class="line">        V(mutex);       <span class="comment">// 释放互斥锁</span></span><br><span class="line">        V(empty);       <span class="comment">// 增加空闲位 (唤醒生产者)</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong> : <code>P(empty)</code> 和
<code>P(mutex)</code> <strong>顺序不能颠倒</strong>，否则可能导致死锁 (
持有锁等待资源 ).</li>
</ul></li>
</ul>
<h4 id="读者-写者问题-readers-writers-problem">2. 读者-写者问题 (
Readers-Writers Problem )</h4>
<ul>
<li><strong>问题描述</strong> : 多个进程共享一个数据区.
<ul>
<li><strong>读-读</strong> : 允许同时访问.</li>
<li><strong>读-写</strong> : 互斥.</li>
<li><strong>写-写</strong> : 互斥.</li>
</ul></li>
<li><strong>信号量设置</strong> :
<ul>
<li><code>rw_mutex = 1</code> : 用于实现对文件的互斥访问 ( 写锁 ).</li>
<li><code>count_mutex = 1</code> : 用于保护 <code>count</code>
变量的互斥访问.</li>
<li><code>count = 0</code> : 记录当前读者数量.</li>
</ul></li>
<li><strong>代码示例 ( 读者优先 )</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore rw_mutex=<span class="number">1</span>, count_mutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(rw_mutex);    <span class="comment">// 申请写锁 (若有读者或写者，则阻塞)</span></span><br><span class="line">        writing();</span><br><span class="line">        V(rw_mutex);    <span class="comment">// 释放写锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(count_mutex); <span class="comment">// 保护 count</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) </span><br><span class="line">            P(rw_mutex);<span class="comment">// 第一个读者负责申请写锁 ( 阻断写者 )</span></span><br><span class="line">        count++;</span><br><span class="line">        V(count_mutex);</span><br><span class="line">        </span><br><span class="line">        reading();</span><br><span class="line">        </span><br><span class="line">        P(count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) </span><br><span class="line">            V(rw_mutex);<span class="comment">// 最后一个读者负责释放写锁</span></span><br><span class="line">        V(count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="哲学家进餐问题-dining-philosophers-problem">3. 哲学家进餐问题 (
Dining Philosophers Problem )</h4>
<ul>
<li><strong>问题描述</strong> :
<ul>
<li>由 Dijkstra 提出，是解决进程同步问题的经典案例.</li>
<li>5 名哲学家围坐在一张圆桌旁，桌上有 5 支筷子 ( 每两个哲学家中间有一支
).</li>
<li>哲学家的生活：<strong>思考 ( Thinking )</strong> -&gt; <strong>饥饿
( Hungry )</strong> -&gt; <strong>进餐 ( Eating )</strong> -&gt;
<strong>思考</strong>.</li>
<li><strong>规则</strong> :
哲学家进餐时，必须同时拿到自己左手边和右手边的两支筷子.
进餐完毕后，放下筷子继续思考.</li>
</ul></li>
<li><strong>关键问题</strong> :
<ul>
<li><strong>死锁 ( Deadlock )</strong> : 如果 5
名哲学家同时饥饿，并且都同时拿起了左手边的筷子，那么他们都会等待右手边的筷子，导致所有人都被阻塞，形成环路等待，发生死锁.</li>
<li><strong>饥饿 ( Starvation )</strong> :
在某些策略下，某个哲学家可能长期无法凑齐两支筷子而无法进餐.</li>
</ul></li>
</ul>
<h5 id="解决方案-1-限制最多允许-4-人同时进餐">解决方案 1 : 限制最多允许
4 人同时进餐</h5>
<ul>
<li><strong>原理</strong> : 破坏死锁产生的必要条件 ( 循环等待 ). 5
个位置只允许 4 个人同时抢筷子，根据抽屉原理，至少有 1 人能拿到 2
支筷子，从而进餐并释放资源.</li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore limit = <span class="number">4</span>; <span class="comment">// 限制最多 4 人同时请求进餐</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        think();                <span class="comment">// 思考</span></span><br><span class="line">        P(limit);               <span class="comment">// 申请进餐名额 (若已满4人，则阻塞)</span></span><br><span class="line">        P(chopstick[i]);        <span class="comment">// 拿左筷子</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">// 拿右筷子</span></span><br><span class="line">        </span><br><span class="line">        eat();                  <span class="comment">// 进餐</span></span><br><span class="line">        </span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">// 放右筷子</span></span><br><span class="line">        V(chopstick[i]);        <span class="comment">// 放左筷子</span></span><br><span class="line">        V(limit);               <span class="comment">// 释放进餐名额</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="解决方案-2-奇偶分层-破坏循环等待">解决方案 2 : 奇偶分层 (
破坏循环等待 )</h5>
<ul>
<li><strong>原理</strong> :
规定奇数号哲学家先拿左筷子再拿右筷子，偶数号哲学家先拿右筷子再拿左筷子.
这样相邻的哲学家会竞争同一支筷子 ( 例如 1 号和 2 号会先竞争筷子 2
)，从而打破环状等待链.</li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数号：先左后右</span></span><br><span class="line">            P(chopstick[i]);        <span class="comment">// 左</span></span><br><span class="line">            P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">// 右</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;          <span class="comment">// 偶数号：先右后左</span></span><br><span class="line">            P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">// 右</span></span><br><span class="line">            P(chopstick[i]);        <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eat();</span><br><span class="line">        </span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="解决方案-3-and-信号量-原子取锁">解决方案 3 : AND 信号量 (
原子取锁 )</h5>
<ul>
<li><strong>原理</strong> : 将 “拿起左右两支筷子” 作为一个原子操作.
只有当左右两支筷子都可用时，才一次性全部拿起; 否则一支都不拿.
这直接破坏了 “请求和保持” 条件.</li>
<li><strong>伪代码</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设系统提供 Swait(S1, S2) 原语，可同时申请两个信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        Swait(chopstick[i], chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 同时申请左、右筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        Ssignal(chopstick[i], chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 同时释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="吸烟者问题-smokers-problem">4. 吸烟者问题 ( Smokers Problem
)</h4>
<ul>
<li><strong>问题描述</strong> :
<ul>
<li>系统包含 <strong>1 个供应者 ( Provider )</strong> 和 <strong>3
个吸烟者 ( Smoker )</strong>.</li>
<li><strong>3 种材料</strong> : 烟草 ( Tobacco ), 纸 ( Paper ), 胶水 (
Glue ).</li>
<li><strong>吸烟者需求</strong> :
<ul>
<li><strong>Smoker 1</strong> : 有 烟草，缺 <strong>纸 +
胶水</strong>.</li>
<li><strong>Smoker 2</strong> : 有 纸，缺 <strong>烟草 +
胶水</strong>.</li>
<li><strong>Smoker 3</strong> : 有 胶水，缺 <strong>烟草 +
纸</strong>.</li>
</ul></li>
<li><strong>供应者行为</strong> : 无限供应，每次随机将
<strong>两种材料</strong>
放在桌上，然后等待吸烟者拿走并吸完，再放下一轮.</li>
</ul></li>
<li><strong>问题分析</strong> :
<ul>
<li>这是一个典型的 <strong>同步问题</strong>.
供应者和吸烟者之间存在直接的生产-消费关系.</li>
<li><strong>关键点</strong> :
供应者提供的虽然是两种材料，但实际上可以看作是
<strong>“提供给某一个特定吸烟者的信号”</strong>.
<ul>
<li>提供 “纸 + 胶水” -&gt; 唤醒 Smoker 1 ( 他有烟草 ).</li>
<li>提供 “烟草 + 胶水” -&gt; 唤醒 Smoker 2 ( 他有纸 ).</li>
<li>提供 “烟草 + 纸” -&gt; 唤醒 Smoker 3 ( 他有胶水 ).</li>
</ul></li>
<li><strong>死锁风险</strong> : 如果用 3 个信号量分别代表 3
种材料，可能会导致死锁 ( 例如桌上有烟草和纸，Smoker 1 拿了烟草，Smoker 2
拿了纸，结果谁都凑不齐 ). 因此，应该将 “材料组合” 抽象为事件信号.</li>
</ul></li>
<li><strong>信号量设置</strong> :
<ul>
<li><code>offer1 = 0</code> : 代表桌上有组合 “纸 + 胶水” ( 唤醒 Smoker 1
).</li>
<li><code>offer2 = 0</code> : 代表桌上有组合 “烟草 + 胶水” ( 唤醒 Smoker
2 ).</li>
<li><code>offer3 = 0</code> : 代表桌上有组合 “烟草 + 纸” ( 唤醒 Smoker 3
).</li>
<li><code>finish = 0</code> :
表示吸烟者已完成吸烟，桌子变空，通知供应者放下一轮.</li>
</ul></li>
<li><strong>代码示例</strong> : <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>; <span class="comment">// 对应 Smoker 1 的需求</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>; <span class="comment">// 对应 Smoker 2 的需求</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>; <span class="comment">// 对应 Smoker 3 的需求</span></span><br><span class="line">semaphore finish = <span class="number">0</span>; <span class="comment">// 只有 0 或 1，也可以看作互斥变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 供应者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">provider</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> rand = random() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (rand == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 放 纸 + 胶水 -&gt; 唤醒 Smoker 1</span></span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rand == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 放 烟草 + 胶水 -&gt; 唤醒 Smoker 2</span></span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 放 烟草 + 纸 -&gt; 唤醒 Smoker 3</span></span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待吸烟者吸完</span></span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吸烟者 1 ( 有烟草，缺 纸 + 胶水 )</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smoker1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer1); <span class="comment">// 等待 &quot;纸 + 胶水&quot; 组合</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拿走材料，卷烟，抽掉</span></span><br><span class="line">        </span><br><span class="line">        V(finish); <span class="comment">// 通知供应者继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吸烟者 2 ( 有纸，缺 烟草 + 胶水 )</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smoker2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer2); </span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吸烟者 3 ( 有胶水，缺 烟草 + 纸 )</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smoker3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="管程-monitor">2.3.6 管程 ( Monitor )</h3>
<ul>
<li><strong>背景</strong> : 信号量机制 ( Semaphores )
虽然功能强大，但编程困难且容易出错 ( 例如 P/V 操作顺序错误可能导致死锁
). 为了简化同步控制，Hansen 和 Hoare 提出了管程机制.</li>
<li><strong>定义</strong> :
一种高级同步机制，它封装了共享数据结构、对该数据结构的一组操作过程 (
Procedures ) 以及初始化代码.
<ul>
<li><strong>本质</strong> : <strong>抽象数据类型 ( ADT )</strong>
的一种特例，专门用于并发编程.</li>
</ul></li>
<li><strong>基本特征</strong> :
<ol type="1">
<li><strong>模块化</strong> : 将共享资源及其操作封装在一个模块中.</li>
<li><strong>信息隐藏</strong> :
管程外的进程无法直接访问管程内的共享数据，只能通过调用管程提供的公共过程
( Public Procedures ) 来访问.</li>
<li><strong>自动互斥</strong> :
<strong>管程由编译器/语言层面负责实现互斥</strong>.
任一时刻，最多只能有一个进程在管程中执行.
其他试图进入管程的进程将被阻塞在 <strong>入口等待队列 ( Entry Queue
)</strong>.</li>
</ol></li>
<li><strong>条件变量 ( Condition Variables )</strong> :
<ul>
<li>管程虽然自动实现了互斥，但为了解决同步问题 ( 如 “缓冲区满”
时需要等待 )，引入了 <strong>条件变量</strong>.</li>
<li><code>condition x;</code> : 定义条件变量 x.</li>
<li><code>x.wait()</code> : 当条件不满足时，进程调用此操作. 该进程会
<strong>释放管程锁</strong>，并阻塞在 x 的等待队列中.</li>
<li><code>x.signal()</code> : 唤醒一个阻塞在 x 等待队列中的进程.
若没有进程在等待，则该操作无任何效果 ( 注意：这与信号量的 V
操作不同，信号量 V 会累加计数 ).</li>
</ul></li>
</ul>
<h4 id="代码示例-管程解决生产者-消费者问题">代码示例 :
管程解决生产者-消费者问题</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer &#123;</span><br><span class="line">    item buffer[N];      <span class="comment">// 共享数据</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;       <span class="comment">// 计数器</span></span><br><span class="line">    condition not_full;  <span class="comment">// 条件变量：缓冲区不满</span></span><br><span class="line">    condition not_empty; <span class="comment">// 条件变量：缓冲区不空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入数据</span></span><br><span class="line">    public <span class="type">void</span> <span class="title function_">put</span><span class="params">(item x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == N) &#123;</span><br><span class="line">            not_full.wait(); <span class="comment">// 缓冲区满，等待 &quot;不满&quot; 信号 (释放锁并阻塞)</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buffer[count] = x;   <span class="comment">// 放入数据</span></span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        not_empty.signal();  <span class="comment">// 放入数据后，缓冲区肯定不空，唤醒等待 &quot;不空&quot; 的消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者取出数据</span></span><br><span class="line">    public <span class="type">void</span> <span class="title function_">get</span><span class="params">(item &amp;x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            not_empty.wait(); <span class="comment">// 缓冲区空，等待 &quot;不空&quot; 信号 (释放锁并阻塞)</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        x = buffer[count<span class="number">-1</span>];  <span class="comment">// 取出数据</span></span><br><span class="line">        count--;</span><br><span class="line">        </span><br><span class="line">        not_full.signal();    <span class="comment">// 取出数据后，缓冲区肯定不满，唤醒等待 &quot;不满&quot; 的生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优势</strong> : 程序员无需手动编写互斥锁代码 ( P/V 操作
)，只需关注业务逻辑和同步条件，大大降低了死锁风险和编程难度.</li>
<li><strong>现实应用</strong> : Java 的 <code>synchronized</code>
关键字、<code>Object.wait()</code> / <code>Object.notify()</code>
机制就是管程概念的经典实现.</li>
</ul>
<h2 id="死锁-deadlock">2.4 死锁 ( Deadlock )</h2>
<h3 id="死锁的概念">2.4.1 死锁的概念</h3>
<ul>
<li><strong>定义</strong> :
多个进程因竞争不可剥夺资源或协同推进顺序非法而造成的一种僵局 ( Deadlock
)，若无外力作用，这些进程都无法向前推进.</li>
<li><strong>死锁 vs 饥饿 vs 活锁</strong> :
<ul>
<li><strong>死锁 ( Deadlock )</strong> : 涉及的进程都
<strong>阻塞</strong>，等待永远不会发生的事件 ( 互相持有对方需要的资源 )
.</li>
<li><strong>饥饿 ( Starvation )</strong> : 进程长时间得不到资源 (
如优先级调度中的低优先级进程 ) ，进程可能处于 <strong>就绪态</strong> (
长期得不到 CPU 时间 ) / <strong>阻塞态</strong> ( 等待资源，如 I/O 操作
).</li>
<li><strong>活锁 ( Livelock )</strong> :
进程未被阻塞，但由于互相礼让或状态不断改变，导致无法推进 (
如两个人在窄巷相遇互相避让 ) .</li>
</ul></li>
<li><strong>死锁产生的原因</strong> :
<ol type="1">
<li><strong>系统资源的竞争</strong> :
系统中不可剥夺的资源数量不足以满足多个进程的需求，导致进程争夺资源而陷入僵局.</li>
<li><strong>进程推进顺序非法</strong> :
进程在运行过程中，请求和释放资源的顺序不当 ( 如 P1 占有 A 请求 B，P2
占有 B 请求 A ).</li>
</ol></li>
<li><strong>死锁产生的四个必要条件 ( 缺一不可 )</strong> :
<ol type="1">
<li><strong>互斥条件 ( Mutual Exclusion )</strong> :
资源是独占的，同一时刻只能由一个进程使用.</li>
<li><strong>不剥夺条件 ( No Preemption )</strong> :
进程获得的资源在未使用完之前，不能被其他进程强行夺走，只能主动释放.</li>
<li><strong>请求和保持条件 ( Hold and Wait )</strong> :
进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有.</li>
<li><strong>循环等待条件 ( Circular Wait )</strong> :
存在一个进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求.</li>
</ol></li>
</ul>
<h3 id="死锁处理策略">2.4.2 死锁处理策略</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">策略</th>
<th style="text-align: left;">原理</th>
<th style="text-align: left;">优点</th>
<th style="text-align: left;">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>死锁预防</strong></td>
<td style="text-align: left;">破坏四个必要条件之一</td>
<td style="text-align: left;">实现简单</td>
<td style="text-align: left;">资源利用率低，甚至不可行</td>
</tr>
<tr>
<td style="text-align: left;"><strong>死锁避免</strong></td>
<td style="text-align: left;">在分配资源前判断安全性</td>
<td style="text-align: left;">资源利用率较高</td>
<td style="text-align: left;">实现复杂，需预知最大需求</td>
</tr>
<tr>
<td style="text-align: left;"><strong>死锁检测与解除</strong></td>
<td style="text-align: left;">允许死锁发生，定期检测并恢复</td>
<td style="text-align: left;">资源利用率高</td>
<td style="text-align: left;">检测有开销，恢复代价大</td>
</tr>
<tr>
<td style="text-align: left;"><strong>死锁忽略</strong></td>
<td style="text-align: left;">鸵鸟策略 ( Ostrich Algorithm )</td>
<td style="text-align: left;">简单，适合死锁概率极低的系统</td>
<td style="text-align: left;">发生死锁需人工干预 ( 重启 )</td>
</tr>
</tbody>
</table>
<h3 id="死锁预防-prevention">2.4.3 死锁预防 ( Prevention )</h3>
<p>通过限制资源请求，<strong>破坏四个必要条件之一</strong> (
互斥条件一般无法破坏 ) :</p>
<ol type="1">
<li><strong>破坏 “不剥夺” 条件</strong> :
<ul>
<li><strong>策略</strong> :
当进程请求新资源得不到满足时，必须释放已保持的所有资源，待以后重新申请.</li>
<li><strong>缺点</strong> :
实现复杂，反复申请释放增加系统开销，可能导致饥饿.</li>
</ul></li>
<li><strong>破坏 “请求和保持” 条件</strong> :
<ul>
<li><strong>策略一 ( 静态分配 )</strong> :
进程在运行前一次性申请完所有需要的资源，若满足则运行，否则等待.</li>
<li><strong>策略二</strong> :
允许进程只获得运行初期需要的资源，但在请求新资源前，必须释放当前拥有的所有资源.</li>
<li><strong>缺点</strong> : 资源严重浪费 ( 有些资源可能很久才用
)，进程可能饥饿 ( 个别资源长期被占用导致无法凑齐所有资源 ).</li>
</ul></li>
<li><strong>破坏 “循环等待” 条件</strong> :
<ul>
<li><strong>策略</strong> :
<strong>顺序资源分配法</strong>，给系统所有资源编号，规定进程只能按编号递增的顺序请求资源.</li>
<li><strong>缺点</strong> : 限制了新设备增加，限制了用户编程自主性.</li>
</ul></li>
</ol>
<h3 id="死锁避免-avoidance---银行家算法">2.4.4 死锁避免 ( Avoidance ) -
银行家算法</h3>
<p>在资源动态分配过程中，用某种方法防止系统进入
<strong>不安全状态</strong>.</p>
<ul>
<li><strong>安全状态</strong> : 系统能按某种进程顺序 ( <span
class="math inline">\(P_1, P_2, \dots, P_n\)</span> )
为每个进程分配资源，直至满足每个进程的最大需求，使每个进程都能顺利完成.
这个序列称为 <strong>安全序列</strong>.</li>
<li><strong>不安全状态</strong> : 找不到安全序列. ( 不安全状态 <span
class="math inline">\(\neq\)</span> 死锁，但死锁一定处于不安全状态
).</li>
</ul>
<h4 id="银行家算法-bankers-algorithm">银行家算法 ( Banker’s Algorithm
)</h4>
<p>Dijkstra
提出，核心思想是：<strong>在分配资源前先预演，若分配后系统处于安全状态则分配，否则暂不分配.</strong></p>
<div class="note sparkle simple"><p><strong>注</strong></p>
<p>银行家算法属于
<strong>死锁避免</strong>，它并不破坏四个必要条件中的任何一个，而是通过在每次资源分配前进行
<strong>安全性检查</strong>，避免系统进入 <strong>不安全状态</strong>
从而规避死锁.</p>
<p>与之对比 : <strong>死锁预防</strong> 是通过事先设计策略去破坏
“请求和保持”“不剥夺”“循环等待”等条件来保证系统永不形成死锁.</p>
<p>对于 <strong>单类资源</strong> ( 系统有 <span
class="math inline">\(m\)</span> 个同类资源、<span
class="math inline">\(n\)</span> 个进程 )，设进程 <span
class="math inline">\(i\)</span> 的最大需求为 <span
class="math inline">\(k_i\)</span>. 系统不发生死锁的
<strong>充要条件</strong> :</p>
<ul>
<li><span class="math inline">\(\sum k_i \le m + n - 1\)</span></li>
<li>若每进程最大需求相同为 <span
class="math inline">\(k\)</span>，则等价为 <span class="math inline">\(m
\ge n(k - 1) + 1\)</span></li>
</ul>
<p><strong>结论</strong> : 最大需求量之和必须 <strong>严格小于</strong>
<span class="math inline">\(m + n\)</span> ( 即 <span
class="math inline">\(\le m + n - 1\)</span> )</p>
</div>
<ul>
<li><strong>数据结构 ( 假设系统有 <span class="math inline">\(n\)</span>
个进程，<span class="math inline">\(m\)</span> 类资源 )</strong> :
<ol type="1">
<li><strong>可利用资源向量 <code>Available</code></strong> :
<code>vector[m]</code>，<code>Available[j] = K</code> 表示第 <span
class="math inline">\(j\)</span> 类资源现有 <span
class="math inline">\(K\)</span> 个.</li>
<li><strong>最大需求矩阵 <code>Max</code></strong> :
<code>matrix[n][m]</code>，<code>Max[i][j] = K</code> 表示进程 <span
class="math inline">\(i\)</span> 需要第 <span
class="math inline">\(j\)</span> 类资源的最大数量为 <span
class="math inline">\(K\)</span>.</li>
<li><strong>分配矩阵 <code>Allocation</code></strong> :
<code>matrix[n][m]</code>，<code>Allocation[i][j] = K</code> 表示进程
<span class="math inline">\(i\)</span> 当前已获得第 <span
class="math inline">\(j\)</span> 类资源 <span
class="math inline">\(K\)</span> 个.</li>
<li><strong>需求矩阵 <code>Need</code></strong> :
<code>matrix[n][m]</code>，<code>Need[i][j] = K</code> 表示进程 <span
class="math inline">\(i\)</span> 还需要第 <span
class="math inline">\(j\)</span> 类资源 <span
class="math inline">\(K\)</span> 个.
<ul>
<li><strong>关系</strong> :
<code>Need[i][j] = Max[i][j] - Allocation[i][j]</code></li>
</ul></li>
</ol></li>
<li><strong>算法流程 ( 资源请求算法 )</strong> : 设
<code>Request_i</code> 是进程 <span class="math inline">\(P_i\)</span>
的请求向量.
<ol type="1">
<li><strong>检查请求合法性</strong> : 若
<code>Request_i[j] &lt;= Need[i][j]</code>，转向步骤 2; 否则出错 (
请求超过宣布的最大需求 ).</li>
<li><strong>检查资源可用性</strong> : 若
<code>Request_i[j] &lt;= Available[j]</code>，转向步骤 3; 否则 <span
class="math inline">\(P_i\)</span> 等待 ( 尚无足够资源 ).</li>
<li><strong>试探性分配</strong> : 系统试探着把资源分配给进程 <span
class="math inline">\(P_i\)</span>，并修改数据结构 :
<ul>
<li><code>Available = Available - Request_i</code></li>
<li><code>Allocation[i] = Allocation[i] + Request_i</code></li>
<li><code>Need[i] = Need[i] - Request_i</code></li>
</ul></li>
<li><strong>安全性检查</strong> : 执行 <strong>安全性算法</strong>.
<ul>
<li>若系统 <strong>安全</strong>，则正式分配资源给 <span
class="math inline">\(P_i\)</span>.</li>
<li>若系统
<strong>不安全</strong>，则撤销试探分配，恢复原数据结构，<span
class="math inline">\(P_i\)</span> 阻塞等待.</li>
</ul></li>
</ol></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5 <span class="comment">// 进程数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 3 <span class="comment">// 资源种类数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量 ( 系统状态 )</span></span><br><span class="line"><span class="type">int</span> Available[M];       <span class="comment">// 可用资源</span></span><br><span class="line"><span class="type">int</span> Max[N][M];          <span class="comment">// 最大需求</span></span><br><span class="line"><span class="type">int</span> Allocation[N][M];   <span class="comment">// 已分配</span></span><br><span class="line"><span class="type">int</span> Need[N][M];         <span class="comment">// 尚需 ( Max - Allocation )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：向量比较 A &lt;= B</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">leq</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; B[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：向量加法 A = A + B</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) A[i] += B[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：向量减法 A = A - B</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) A[i] -= B[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 安全性算法 ( 核心 )</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_safe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> Work[M];</span><br><span class="line">    <span class="type">bool</span> Finish[N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;M; i++) Work[i] = Available[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) Finish[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; N) &#123;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找一个 尚未完成 且 需求 &lt;= 当前可用资源 的进程</span></span><br><span class="line">            <span class="keyword">if</span> (!Finish[i] &amp;&amp; leq(Need[i], Work, M)) &#123;</span><br><span class="line">                <span class="comment">// 模拟进程 i 执行完成并释放资源</span></span><br><span class="line">                add(Work, Allocation[i], M);</span><br><span class="line">                Finish[i] = <span class="literal">true</span>;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 找不到下一个可执行进程，不安全</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 所有进程都能执行完成，系统安全</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 资源请求算法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">request_resources</span><span class="params">(<span class="type">int</span> pid, <span class="type">int</span> request[])</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤 1: 检查请求是否合法 ( Request &lt;= Need )</span></span><br><span class="line">    <span class="keyword">if</span> (!leq(request, Need[pid], M)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 检查是否有足够资源 ( Request &lt;= Available )</span></span><br><span class="line">    <span class="keyword">if</span> (!leq(request, Available, M)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Wait</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 试探性分配</span></span><br><span class="line">    sub(Available, request, M);</span><br><span class="line">    add(Allocation[pid], request, M);</span><br><span class="line">    sub(Need[pid], request, M);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4: 安全性检查</span></span><br><span class="line">    <span class="keyword">if</span> (is_safe()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 分配成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复原状 ( 回滚 )</span></span><br><span class="line">        add(Available, request, M);</span><br><span class="line">        sub(Allocation[pid], request, M);</span><br><span class="line">        add(Need[pid], request, M);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Wait</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁检测和解除-detection-and-recovery">2.4.5 死锁检测和解除 (
Detection and Recovery )</h3>
<p>允许死锁发生，但系统会定时运行检测算法，一旦发现死锁，就采取措施解除.</p>
<h4 id="死锁检测-detection">1. 死锁检测 ( Detection )</h4>
<ul>
<li><strong>资源分配图 ( Resource Allocation Graph )</strong> :
<ul>
<li><strong>节点</strong> : 进程节点 <span class="math inline">\(P =
\{P_1, P_2, \dots\}\)</span> ( 圆圈 )，资源节点 <span
class="math inline">\(R = \{R_1, R_2, \dots\}\)</span> ( 方框 ).</li>
<li><strong>边</strong> :
<ul>
<li><strong>请求边</strong> (<span class="math inline">\(P_i \to
R_j\)</span>) : 进程 <span class="math inline">\(P_i\)</span> 请求资源
<span class="math inline">\(R_j\)</span>.</li>
<li><strong>分配边</strong> (<span class="math inline">\(R_j \to
P_i\)</span>) : 资源 <span class="math inline">\(R_j\)</span> 已分配给
<span class="math inline">\(P_i\)</span>.</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    classDef default fill:#F1F5F9,stroke:#334155,stroke-width:2px,color:#1E293B,rx:5,ry:5;
    classDef process fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;
    classDef resource fill:#F59E0B,stroke:#B45309,stroke-width:2px,color:#FFFFFF,rx:5,ry:5;

    P1((P1)):::process
    P2((P2)):::process
    R1[R1]:::resource
    R2[R2]:::resource

    R1 --&gt;|已分配| P1
    P1 --&gt;|请求| R2
    R2 --&gt;|已分配| P2
    P2 --&gt;|请求| R1
  </pre></div></li>
<li><strong>死锁定理</strong> :
<ul>
<li>如果资源分配图是 <strong>不可完全简化</strong> 的 (
即图中存在无法消除的环 )，则系统发生了死锁.</li>
<li><strong>S 状态 ( Simplified )</strong> : 找出既不阻塞又非独立的进程
<span class="math inline">\(P_i\)</span> ( 能获得所有请求资源
)，使其运行并释放所有资源 ( 消去边 ). 重复此过程. 若能消去所有边，则图是
<strong>可完全简化</strong> 的 ( 无死锁 ).</li>
</ul></li>
<li><strong>检测算法</strong> :
<ul>
<li>类似于银行家算法的安全性检查，但使用 <code>Request</code> ( 当前请求
) 而非 <code>Need</code>.</li>
<li>若找不到一个安全序列 ( 所有进程都能 finish )，则剩余未 finish
的进程处于死锁状态.</li>
</ul></li>
</ul>
<h4 id="死锁解除-recovery">2. 死锁解除 ( Recovery )</h4>
<p>一旦检测到死锁，需打破循环等待.</p>
<ol type="1">
<li><strong>资源剥夺法 ( Resource Preemption )</strong> :
<ul>
<li><strong>挂起</strong>
某些死锁进程，抢占其资源分配给其他死锁进程.</li>
<li>需防止被挂起的进程长时间 <strong>饥饿</strong>.</li>
</ul></li>
<li><strong>撤销 ( 终止 ) 进程法 ( Process Termination )</strong> :
<ul>
<li><strong>终止所有死锁进程</strong> : 代价大，前功尽弃.</li>
<li><strong>逐个终止进程</strong> : 直至死锁循环被打破.
<ul>
<li><strong>选择策略</strong> :
优先级最低、已运行时间最短、剩余时间最长、占用资源最多、交互式进程优先等.</li>
</ul></li>
</ul></li>
<li><strong>进程回退法 ( Rollback )</strong> :
<ul>
<li>让一个或多个进程回退到足以避免死锁的地步 ( 如回退到检查点 Checkpoint
).</li>
<li>系统需建立检查点机制，记录进程状态.</li>
</ul></li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">sparkle520</div><div class="post-copyright__author_desc">我一直都在寻找着什么</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/')">408-操作系统-2-进程与线程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=408-操作系统-2-进程与线程&amp;url=http://example.com/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/&amp;pic=https://pic1.imgdb.cn/item/69492ebfc154427986d9c262.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SPARKLE</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>操作系统<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/408/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>408<span class="tagsPageCount">10</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/6996f0a1d2628f800ee0f993.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492a76c154427986d991c5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">408-操作系统-1-计算机系统概述</div></div></a></div><div class="next-post pull-right"><a href="/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492cd6c154427986d9b19e.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">408-操作系统-3-内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/" title="408-操作系统-1-计算机系统概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492a76c154427986d991c5.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-22</div><div class="title">408-操作系统-1-计算机系统概述</div></div></a></div><div><a href="/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/" title="408-操作系统-3-内存管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492cd6c154427986d9b19e.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-25</div><div class="title">408-操作系统-3-内存管理</div></div></a></div><div><a href="/2025/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/" title="408-操作系统-5-输入&#x2F;输出管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492e4cc154427986d9be8f.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-26</div><div class="title">408-操作系统-5-输入&#x2F;输出管理</div></div></a></div><div><a href="/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/" title="408-操作系统-4-文件管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6951243ca0c391c56de5e622.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-25</div><div class="title">408-操作系统-4-文件管理</div></div></a></div><div><a href="/2025/12/31/%E8%AE%A1%E7%BB%841/" title="408-计算机组成原理-1-计算机系统概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6954ea8a8801094e3ab4fd8b.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-31</div><div class="title">408-计算机组成原理-1-计算机系统概述</div></div></a></div><div><a href="/2026/01/26/%E8%AE%A1%E7%BB%845/" title="408-计算机组成原理-5-中央处理器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69872af342b1cbeca1f88f3d.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2026-01-26</div><div class="title">408-计算机组成原理-5-中央处理器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/671cfe2fd29ded1a8c5ffb0b.png" alt="status"/></div></div><div class="author-info__description">不管你在<strong style="color:white">这个世界</strong>的哪个地方，我一定<strong style="color:white">会</strong>，再次去<strong style="color:white">见</strong>你的!</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">sparkle520</h1><div class="author-info__desc">我一直都在寻找着什么</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/sparkle520" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/34882250" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">Hello World! 欢迎来到我的博客~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://pic.imgdb.cn/item/66c487f1d9c307b7e9ba5c7a.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://pic.imgdb.cn/item/66c487ebd9c307b7e9ba5725.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">第2章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1.1 进程的概念和特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.1.2 进程的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E5%A4%8D%E7%94%A8-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">程序段的共享与复用 ( 多进程调用
)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pcb-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">PCB 详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.1.3 进程的状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">状态定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">扩展状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">典型触发与转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.1.4 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%AD%E4%B8%8E%E5%85%B8%E5%9E%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">基本原语与典型步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E4%B8%8E%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">约束与策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E9%80%9F%E8%AE%B0-%E7%B1%BB-unix"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">常见接口速记 ( 类 Unix )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.5.</span> <span class="toc-text">2.1.5 进程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8-shared-memory"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">共享存储 ( Shared Memory )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92-message-passing"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">消息传递 ( Message Passing )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1-pipe-fifo"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">管道通信 ( Pipe &#x2F; FIFO )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97-socket"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">套接字 ( Socket )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7-signal"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">信号 ( Signal )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6-memory-mapped-files"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">内存映射文件 ( Memory-Mapped
Files )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%89%E5%9E%8B"><span class="toc-number">1.1.5.7.</span> <span class="toc-text">对比与选型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E9%80%9F%E8%AE%B0-%E7%B1%BB-unix-1"><span class="toc-number">1.1.5.8.</span> <span class="toc-text">常见接口速记 ( 类 Unix )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">2.1.6 线程和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">线程的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">引入线程的目的与优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">线程的基本特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">线程的状态与转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-tcb-%E5%85%B8%E5%9E%8B%E5%AD%97%E6%AE%B5"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">线程控制块 (TCB) 典型字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.6.6.</span> <span class="toc-text">线程的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94%E9%80%9F%E6%9F%A5"><span class="toc-number">1.1.6.7.</span> <span class="toc-text">进程与线程对比速查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.6.8.</span> <span class="toc-text">线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.6.9.</span> <span class="toc-text">多线程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.6.10.</span> <span class="toc-text">线程调度与同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E9%80%9F%E8%AE%B0-%E7%B1%BB-unix-2"><span class="toc-number">1.1.6.11.</span> <span class="toc-text">常见接口速记 ( 类 Unix )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu-%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 CPU 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2.1 调度的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">三级调度的联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2.2 调度的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 逻辑组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. 调度的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. 调度的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B4%BE%E5%BB%B6%E8%BF%9F-dispatch-latency"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. 分派延迟 ( Dispatch Latency )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B-idle-process"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. 闲逛进程 ( Idle Process )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">6. 两种线程的调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E7%9B%AE%E6%A0%87-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.2.3 调度的目标 ( 评价指标 )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 评价指标详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cpu-%E5%88%A9%E7%94%A8%E7%8E%87-cpu-utilization"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">(1) CPU 利用率 ( CPU Utilization
)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F-system-throughput"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">(2) 系统吞吐量 ( System Throughput
)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4-turnaround-time"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">(3) 周转时间 ( Turnaround Time )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4-weighted-turnaround-time"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">(4) 带权周转时间 (
Weighted Turnaround Time )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4-waiting-time"><span class="toc-number">1.2.3.1.5.</span> <span class="toc-text">(5) 等待时间 ( Waiting Time )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4-response-time"><span class="toc-number">1.2.3.1.6.</span> <span class="toc-text">(6) 响应时间 ( Response Time )</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%A0%87%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. 指标图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%A7%E9%87%8D%E7%82%B9"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3. 不同系统的侧重点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2-process-switching"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.2.4 进程切换 ( Process Switching
)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2-vs-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1. 模式切换 vs 上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2. 进程切换的详细步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%E5%88%86%E6%9E%90"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3. 切换开销分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.2.5 CPU 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. 适用于批处理系统的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-fcfs-first-come-first-served"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">(1) 先来先服务 ( FCFS,
First-Come First-Served )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-sjf-shortest-job-first"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">(2) 短作业优先 ( SJF,
Shortest Job First )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-hrrn-highest-response-ratio-next"><span class="toc-number">1.2.5.1.3.</span> <span class="toc-text">(3) 高响应比优先
( HRRN, Highest Response Ratio Next )</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BA%8E%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. 适用于交互式系统的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-rr-round-robin"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">(4) 时间片轮转 ( RR, Round Robin
)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-priority-scheduling"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">(5) 优先级调度 ( Priority
Scheduling )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-multilevel-feedback-queue"><span class="toc-number">1.2.5.2.3.</span> <span class="toc-text">(6) 多级反馈队列 (
Multilevel Feedback Queue )</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AF%B9%E6%AF%94-gantt-chart"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3. 算法可视化对比 ( Gantt Chart
)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94%E9%80%9F%E6%9F%A5"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.2.6 算法特性对比速查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6-multiprocessor-scheduling"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.2.7 多处理机调度 (
Multiprocessor Scheduling )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">1. 基本模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2. 就绪队列结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E4%BA%B2%E5%92%8C%E6%80%A7-affinity"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">3. 处理器亲和性 ( Affinity )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E8%BF%81%E7%A7%BB"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">4. 负载均衡与迁移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#numa-%E8%80%83%E9%87%8F"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">5. NUMA 考量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A%E4%B8%8E%E5%8D%8F%E5%90%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">6. 并行作业与协同调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8F%92%E6%A7%BD"><span class="toc-number">1.2.7.7.</span> <span class="toc-text">7. 超线程&#x2F;核心&#x2F;插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B-linux-cfs"><span class="toc-number">1.2.7.8.</span> <span class="toc-text">8. 实践示例 ( Linux CFS )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.7.9.</span> <span class="toc-text">9. 架构对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9-%E4%BB%A5-linux-%E4%B8%BA%E4%BE%8B"><span class="toc-number">1.2.7.10.</span> <span class="toc-text">10. 关键实现要点 ( 以 Linux 为例
)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.3.1 同步与互斥的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">临界资源访问过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.3.2 实现临界区互斥的基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">软件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">双标志先检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">双标志后检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#peterson-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.1.4.</span> <span class="toc-text">Peterson 算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">硬件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD-interrupt-disabling"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">中断屏蔽 ( Interrupt Disabling
)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#test-and-set-ts-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">Test-and-Set ( TS ) 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#swap-%E6%8C%87%E4%BB%A4-exchange"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">Swap 指令 ( Exchange )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3.3 互斥锁 ( Mutex )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-semaphore"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.3.4 信号量 ( Semaphore )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F-integer-semaphore"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1. 整型信号量 ( Integer Semaphore
)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F-record-semaphore"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2. 记录型信号量 ( Record
Semaphore )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3. 信号量的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-mutual-exclusion"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">(1) 实现进程互斥 ( Mutual
Exclusion )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronization"><span class="toc-number">1.3.4.3.2.</span> <span class="toc-text">(2) 实现进程同步 ( Synchronization
)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB-precedence-graph"><span class="toc-number">1.3.4.3.3.</span> <span class="toc-text">(3) 实现前趋关系 ( Precedence
Graph )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.5.</span> <span class="toc-text">2.3.5 经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98-producer-consumer-problem"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">1.
生产者-消费者问题 ( Producer-Consumer Problem )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98-readers-writers-problem"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">2. 读者-写者问题 (
Readers-Writers Problem )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98-dining-philosophers-problem"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">3. 哲学家进餐问题 (
Dining Philosophers Problem )</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1-%E9%99%90%E5%88%B6%E6%9C%80%E5%A4%9A%E5%85%81%E8%AE%B8-4-%E4%BA%BA%E5%90%8C%E6%97%B6%E8%BF%9B%E9%A4%90"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">解决方案 1 : 限制最多允许
4 人同时进餐</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2-%E5%A5%87%E5%81%B6%E5%88%86%E5%B1%82-%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">解决方案 2 : 奇偶分层 (
破坏循环等待 )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3-and-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%8E%9F%E5%AD%90%E5%8F%96%E9%94%81"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">解决方案 3 : AND 信号量 (
原子取锁 )</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98-smokers-problem"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">4. 吸烟者问题 ( Smokers Problem
)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B-monitor"><span class="toc-number">1.3.6.</span> <span class="toc-text">2.3.6 管程 ( Monitor )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">代码示例 :
管程解决生产者-消费者问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81-deadlock"><span class="toc-number">1.4.</span> <span class="toc-text">2.4 死锁 ( Deadlock )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.4.1 死锁的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.4.2 死锁处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2-prevention"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.4.3 死锁预防 ( Prevention )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D-avoidance---%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.4.4 死锁避免 ( Avoidance ) -
银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-bankers-algorithm"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">银行家算法 ( Banker’s Algorithm
)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4-detection-and-recovery"><span class="toc-number">1.4.5.</span> <span class="toc-text">2.4.5 死锁检测和解除 (
Detection and Recovery )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B-detection"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">1. 死锁检测 ( Detection )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4-recovery"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">2. 死锁解除 ( Recovery )</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/19/%E9%AB%98%E6%95%B0-%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E6%B1%82%E8%A7%A3/" title="高等数学-难点-高阶导数求解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6996f0a1d2628f800ee0f993.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高等数学-难点-高阶导数求解"/></a><div class="content"><a class="title" href="/2026/02/19/%E9%AB%98%E6%95%B0-%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E6%B1%82%E8%A7%A3/" title="高等数学-难点-高阶导数求解">高等数学-难点-高阶导数求解</a><time datetime="2026-02-19T12:00:27.000Z" title="发表于 2026-02-19 20:00:27">2026-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/26/%E8%AE%A1%E7%BB%845/" title="408-计算机组成原理-5-中央处理器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69872af342b1cbeca1f88f3d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="408-计算机组成原理-5-中央处理器"/></a><div class="content"><a class="title" href="/2026/01/26/%E8%AE%A1%E7%BB%845/" title="408-计算机组成原理-5-中央处理器">408-计算机组成原理-5-中央处理器</a><time datetime="2026-01-26T15:00:27.000Z" title="发表于 2026-01-26 23:00:27">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/26/%E8%AE%A1%E7%BB%844/" title="408-计算机组成原理-4-指令系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69872ac742b1cbeca1f88f3a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="408-计算机组成原理-4-指令系统"/></a><div class="content"><a class="title" href="/2026/01/26/%E8%AE%A1%E7%BB%844/" title="408-计算机组成原理-4-指令系统">408-计算机组成原理-4-指令系统</a><time datetime="2026-01-26T15:00:27.000Z" title="发表于 2026-01-26 23:00:27">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/14/%E8%AE%A1%E7%BB%843/" title="408-计算机组成原理-3-存储系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69677a4999f37a647f58e412.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="408-计算机组成原理-3-存储系统"/></a><div class="content"><a class="title" href="/2026/01/14/%E8%AE%A1%E7%BB%843/" title="408-计算机组成原理-3-存储系统">408-计算机组成原理-3-存储系统</a><time datetime="2026-01-14T15:00:27.000Z" title="发表于 2026-01-14 23:00:27">2026-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/12/%E8%8B%B1%E8%AF%AD%E4%BB%8E%E5%8F%A5%E7%AE%80%E5%8C%96/" title="英语从句简化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6964b36351d5e4e5d5707e53.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="英语从句简化"/></a><div class="content"><a class="title" href="/2026/01/12/%E8%8B%B1%E8%AF%AD%E4%BB%8E%E5%8F%A5%E7%AE%80%E5%8C%96/" title="英语从句简化">英语从句简化</a><time datetime="2026-01-12T15:00:27.000Z" title="发表于 2026-01-12 23:00:27">2026-01-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#footer-type-tips", {
      strings: ["只要记住你的名字&#44; 不管你在世界的哪个地方&#44; 我一定&#44; 会去见你 !"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("footer-type-tips").innerHTML = '只要记住你的名字&#44; 不管你在世界的哪个地方&#44; 我一定&#44; 会去见你 !'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/sparkle520" title="sparkle">sparkle</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/sparkle520?tab=repositories" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size: 0.88rem;">408<sup>10</sup></a><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Deep-Learning/" style="font-size: 0.88rem;">Deep Learning<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/JSR303/" style="font-size: 0.88rem;">JSR303<sup>1</sup></a><a href="/tags/Matplotlib/" style="font-size: 0.88rem;">Matplotlib<sup>3</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c#<sup>2</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>4</sup></a><a href="/tags/npc%E5%88%86%E6%9E%90%E6%B3%95/" style="font-size: 0.88rem;">npc分析法<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>5</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>1</sup></a><a href="/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/" style="font-size: 0.88rem;">二次型<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%82/" style="font-size: 0.88rem;">你的名字。<sup>3</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">你的名字同名小说<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%A4%96%E4%BC%A0%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">你的名字外传小说<sup>1</sup></a><a href="/tags/%E5%80%92%E8%A3%85%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">倒装结构<sup>1</sup></a><a href="/tags/%E5%86%99%E4%BD%9C/" style="font-size: 0.88rem;">写作<sup>4</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">包管理<sup>1</sup></a><a href="/tags/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/" style="font-size: 0.88rem;">卷积公式<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/" style="font-size: 0.88rem;">天气之子<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">天气之子同名小说<sup>1</sup></a><a href="/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/" style="font-size: 0.88rem;">定积分<sup>1</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">小说<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" style="font-size: 0.88rem;">数据校验<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 0.88rem;">概率论<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" style="font-size: 0.88rem;">概率论与数理统计<sup>7</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 0.88rem;">汇编<sup>9</sup></a><a href="/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" style="font-size: 0.88rem;">泰勒展开<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%80%BC/" style="font-size: 0.88rem;">特征值<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" style="font-size: 0.88rem;">特征向量<sup>1</sup></a><a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 0.88rem;">线性代数<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/" style="font-size: 0.88rem;">英语听力<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 0.88rem;">英语语法<sup>16</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">计算机组成原理<sup>6</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/" style="font-size: 0.88rem;">词根词缀<sup>1</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" style="font-size: 0.88rem;">高等代数<sup>2</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">高等数学<sup>9</sup></a><a href="/tags/%E9%AB%98%E9%A2%91%E8%AF%8D%E7%BB%84/" style="font-size: 0.88rem;">高频词组<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.9.1/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://sparkle521.xyz',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://sparkle521.xyz',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://sparkle521.xyz',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>