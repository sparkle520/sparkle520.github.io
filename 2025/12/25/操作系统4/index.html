<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>408-操作系统-4-文件管理 | SPARKLE</title><meta name="keywords" content="操作系统,408"><meta name="author" content="sparkle520"><meta name="copyright" content="sparkle520"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="408-操作系统-4-文件管理"><meta name="application-name" content="408-操作系统-4-文件管理"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="408-操作系统-4-文件管理"><meta property="og:url" content="http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/index.html"><meta property="og:site_name" content="SPARKLE"><meta property="og:description" content="第4章 文件管理 4.1 文件系统基础 4.1.1 文件的基本概念 1. 文件的定义  文件 ( File ) : 是以计算机硬盘为载体存储在计算机上的信息集合. 逻辑结构 : 在用户看来, 文件是 记录 的集合 ( 逻辑文件 ). 物理结构 : 在操作系统看来, 文件是 物理块"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pic1.imgdb.cn/item/6951243ca0c391c56de5e622.png"><meta property="article:author" content="sparkle520"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic1.imgdb.cn/item/6951243ca0c391c56de5e622.png"><meta name="description" content="第4章 文件管理 4.1 文件系统基础 4.1.1 文件的基本概念 1. 文件的定义  文件 ( File ) : 是以计算机硬盘为载体存储在计算机上的信息集合. 逻辑结构 : 在用户看来, 文件是 记录 的集合 ( 逻辑文件 ). 物理结构 : 在操作系统看来, 文件是 物理块"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://sparkle521.xyz',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["(❤ ω ❤)"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: sparkle520","link":"链接: ","source":"来源: SPARKLE","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#883ced","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'SPARKLE',
  title: '408-操作系统-4-文件管理',
  postAI: '',
  pageFillDescription: '第4章 文件管理, 4.1 文件系统基础, 4.1.1 文件的基本概念, 1. 文件的定义, 2. 文件的属性, 3. 文件的分类, 4. 文件的基本操作, 4.1.2 文件控制块和索引节点, 1. 文件控制块 ( FCB ), 2. 索引节点 ( Inode ), 4. 示例对比, 4.1.3 文件的操作, 1. 创建文件 ( Create ), 2. 删除文件 ( Delete ), 3. 打开文件 ( Open ), 4. 关闭文件 ( Close ), 5. 读/写文件 ( Read/Write ), 6. 文件重定位 ( Seek ), 4.1.4 文件的逻辑结构, 1. 无结构文件 ( 流式文件 ), 2. 有结构文件 ( 记录式文件 ), 组头结构 ( 示例 ), 分配流程 ( 单块/多块 ), 回收流程, 复杂度与 I/O 估算, 组大小选择建议, 与位示图/链表的对比要点, 1. 顺序文件 ( Sequential File ), 2. 索引文件 ( Indexed File ), 4.1.5 文件的物理结构, 4.1.6 文件保护, 3. 访问控制 ( Access Control ), 4.2 目录, 4.2.1 目录的基本概念, 1. 目录的定义, 2. 目录管理的要求 ( 目标 ), 4.2.2 目录的操作, 4.2.3 目录结构, 6. 目录结构检索效率对比, 4.2.4 目录实现, 1. 线性列表 ( Linear List ), 2. 哈希表 ( Hash Table ), 3. 对比总结, 4.2.5 文件共享, 3. 硬链接 vs 软链接 对比, 4.2.6 本节小结, 4.3 文件系统, 4.3.1 文件系统结构, 分层要点与示例, 层次速记表, 关键对象与职责, 路径解析与权限检查, 缓存机制 ( 读写加速 ), 日志文件系统 ( Journaling ), 4.3.2 文件系统布局, 1. 磁盘分区 ( Partition ) , 3. 常见文件系统布局示例, 4. 内存结构 , 5. 计算与实践要点, 4.3.3 文件存储空间管理, 1. 空闲表法 , 2. 空闲链表法 , 结构定义, 分配流程, 回收与合并, 维护策略, 3. 位示图法 ( Bitmap ) , 4. 成组链接法 , 盘块 vs 盘区 对比表, 方法对比, 典型计算题, 4.3.4 虚拟文件系统, 路径解析流程 ( Path Walk ), 对象与操作表, 名称缓存与负 dentry, 打开/读写流程 ( 简版 ), 挂载与命名空间, 易错点, 4.3.5 文件系统挂载, 常用操作说明, 4.3.7 文件系统类型速览, 4.4 本章疑难点, 2. 硬链接和软链接的区别第章文件管理文件系统基础文件的基本概念文件的定义文件是以计算机硬盘为载体存储在计算机上的信息集合逻辑结构在用户看来文件是记录的集合逻辑文件物理结构在操作系统看来文件是物理块的集合物理文件文件块定义文件的逻辑地址空间被划分为若干个等长的块逻辑块通常与物理块大小一致作用作为信息存储和传输的基本单位簇定义操作系统分配磁盘空间和进行磁盘的最小单位在中称为簇在中称为块关系逻辑块物理块簇扇区个簇个物理扇区如大小权衡块太小索引表过大管理开销大磁盘次数多寻道时间占比高空间利用率高碎片少块太大索引表小效率高内部碎片大空间利用率低组成文件通常由数据项记录和文件三级组成数据项基本数据项原子数据如姓名组合数据项组项如工资记录一组相关数据项的集合文件由创建者定义的具有文件名的一组相关元素的集合文件的属性操作系统通过文件控制块来维护文件属性属性名称描述备注文件名文件在目录中的名称同一目录下不允许重名用户视角方便记忆标识符文件的唯一标签对用户不可见系统视角用于区分文件类型文件的类型如决定了文件的打开方式位置指向设备和设备上文件开头的指针用于定位文件物理地址大小文件当前的大小字节块用于存储分配保护信息访问控制列表读写执行权限确保文件安全时间用户创建时间上次修改时间上次访问时间所有者用于文件保护和统计重点辨析文件名标识符文件名面向用户字符串形式方便记忆如可变性用户可以随时修改文件名但不影响文件内容非唯一性不同目录下的文件可以同名硬链接机制下一个文件可以有多个文件名标识符面向系统通常是数字如系统内部使用唯一性在整个文件系统或分区中唯一标识一个文件不可变性文件创建时分配直到文件被彻底删除才回收文件的分类按性质和用途分类系统文件操作系统核心文件通常只允许通过系统调用访问用户文件用户创建的文件归属于特定用户库文件标准子程序库或函数库允许用户调用但不允许修改按数据的组织形式分类普通文件存储用户数据如文本文件二进制文件目录文件存储文件目录信息由文件系统管理特殊文件设备文件如设备通常作为文件处理按保护级别分类只读文件仅允许读取读写文件允许读取和修改可执行文件允许加载执行按流式记录式分类流式文件无结构字节流如文件记录式文件有结构的记录集合如数据库文件文件的基本操作操作系统提供了一组系统调用来对文件进行操作创建文件分配外存空间在目录中创建目录项删除文件释放外存空间删除目录项打开文件将文件属性从外存复制到内存打开文件表返回文件描述符句柄避免多次检索目录关闭文件将内存中的及其修改写回外存释放内存表项读文件根据读指针将文件数据从外存读入内存缓冲区写文件将内存缓冲区数据写入外存文件截断文件将文件长度设为保留文件名和属性释放空间文件控制块和索引节点文件控制块为了能对一个文件进行正确的存取操作系统必须为文件设置用于描述和控制文件的数据结构称之为文件控制块与文件一一对应目录项文件目录通常是由有序的集合组成的一个就是一个文件目录项包含信息基本信息文件名物理位置起始块号块数逻辑结构物理结构存取控制信息文件主核准用户读写权限使用信息创建时间上次修改时间当前打开计数缺点包含了文件名和文件描述信息在检索目录时我们只需要匹配文件名但不得不将整个读入内存若较大一个磁盘块能容纳的目录项就少导致检索文件时磁盘次数增加索引节点为了解决过大导致的目录检索效率低的问题现代操作系统如采用了索引节点结构设计思想瘦身将文件名与文件描述信息分离目录项仅包含文件名和索引节点号体积变得非常小索引节点包含除文件名之外的所有文件描述信息如文件大小物理地址权限等优势目录项变小每个磁盘块能存更多目录项检索文件时所需的磁盘次数显著减少磁盘索引节点内存索引节点特性磁盘索引节点内存索引节点存储位置存放在磁盘上存放在内存中生命周期永久存在随文件创建而生删除而灭临时存在文件打开时创建关闭时销毁包含内容静态文件描述信息磁盘副本运行时动态信息磁盘索引节点文件主标识符拥有该文件的用户文件类型普通文件目录文件或特别文件文件存取权限各类用户对该文件的存取权限物理地址指针每个指针指向一个磁盘块直接索引间接索引文件长度文件字节数链接计数硬链接数量当此值为时回收文件空间内存索引节点索引节点编号标识该状态标识指示是否被上锁是否被修改访问计数当前有多少个进程打开了该文件时才真正从内存释放逻辑设备号文件所在设备的设备号链接指针用于将内存链接成空闲链表或哈希队列包含磁盘的所有信息示例对比传统假设一个占盘块一个盘块存个目录项法假设目录项文件名索引节点号占一个盘块存个目录项结论同等条件下法检索目录的平均次数约为传统的文件的操作创建文件系统调用核心工作分配外存在外存中寻找空闲块如空闲链表位示图创建目录项在父目录中增加一项记录文件名外存地址等信息初始化建立设置默认属性如所有者权限删除文件系统调用核心工作查找目录根据文件名找到对应的目录项回收资源释放文件占用的外存块修改位示图删除目录项将该目录项标记为无效或从目录文件中移除回收若引用计数为则回收打开文件系统调用核心工作将文件的控制信息从外存读入内存建立相关数据结构打开文件表结构进程打开文件表每个进程独有中记录当前读写指针系统表索引系统打开文件表整个系统只有一张记录信息打开计数流程图解样式定义用户空间进程文件描述符内核空间进程打开文件表读写指针权限系统打开文件表打开计数信息内存物理地址链接数跨空间连线索引应用子图样式注操作本身不进行数据传输只是把文件属性读入内存为后续读写做准备文件打开后操作系统只使用文件标识符来引用文件而不再使用文件名关闭文件系统调用核心工作删除进程表项释放进程打开文件表中的对应项减少引用计数系统打开文件表中对应项的减写回释放若将内存若修改写回磁盘并释放系统表项读写文件系统调用核心工作定位根据找到进程表项系统表项内存物理地址转换将逻辑地址偏移量转换为物理地址块号块内偏移传输在内存缓冲区和磁盘之间传输数据更新修改读写指针位置文件重定位系统调用核心工作修改进程打开文件表中该文件的读写指针位置不涉及操作文件的逻辑结构指在用户看来文件内部的数据是如何组织的无结构文件流式文件定义文件内部没有结构看作是一串字符流特点管理简单用户方便应用源程序文件目标代码文件的所有文件访问只能利用读写指针按字节依次读写有结构文件记录式文件文件由一组相似的记录组成每条记录由若干数据项组成记录是文件存取的基本单位样式定义逻辑结构类型分类顺序文件索引文件索引顺序文件直接散列文件应用子图样式组头结构示例组头字段本组可用块个数可用块号列表下一组组头所在块号内存缓存超级块常驻内存中保存当前组的拷贝分配回收时优先在内存更新必要时写回磁盘分配流程单块多块单块分配若返回若读取作为新组头替换当前组后继续分配分配块重复上述步骤次若跨组需按组头链读取新组回收流程释放一个块号若未满将写入若达到上限组满将当前组写入所在块作为新组头设置当前组原组头位置重置当前组实现有差异复杂度与估算分配回收均为平均时间组内数组压栈出栈跨组时需要读取下一组头产生次磁盘因此摊还开销随组大小增大而降低估算组大小为每分配次平均产生次摊还为次分配组大小选择建议过小频繁切换组开销增加过大组头占用空间增大更新开销增加结合块大小与缓存能力选择与文件系统页块缓存策略协同设计与位示图链表的对比要点位示图定位效率高常驻内存获取连续空间需扫描连续段盘块盘区链结构简单随机连续定位效率较低易碎片化成组链接通过组装载降低适合大规模分配回收的稳定性能需求顺序文件定义记录按某种顺序排列分类串结构记录顺序与关键字无关通常按时间查找需顺序结构记录按关键字顺序排列定长记录可实现随机访问下标计算变长记录只能顺序查找优点批量存取效率高磁带机缺点增删记录困难需移动大量记录样式定义顺序文件逻辑上连续记录记录记录索引文件定义为变长记录文件建立一张索引表记录指向记录的指针逻辑地址结构索引表本身是定长记录的顺序文件优点支持随机访问即使记录变长易于增删缺点索引表占用额外的存储空间样式定义索引表定长索引项索引项索引项逻辑记录可变长记录记录记录指针指针指针索引顺序文件定义将顺序文件中的记录分组为每组建立一个索引项类似多级页表字典目录特点是顺序文件和索引文件的结合优势既支持随机访问又减少了索引表的占用空间效率若条记录分组每组条平均查找次数由降为样式定义组索引表组组组顺序记录记录组顺序记录记录指向指向直接文件散列文件定义给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址特点没有顺序的特性优点存取速度很高缺点会产生冲突不同关键字映射到同一地址需要处理冲突样式定义关键字函数计算地址物理地址访问记录文件的物理结构指文件数据在物理存储设备上是如何分布的文件分配方式样式定义文件分配方式分配策略连续分配链接分配索引分配隐式链接显式链接单级索引多级索引混合索引连续分配定义每个文件在磁盘上占有一组连续的块示意图样式定义磁盘块数据数据数据优点速度快支持顺序访问和直接访问随机访问顺序读写速度最快磁头移动少磁盘次数访问第块仅需次中记录了物理地址直接定位读取插入需将之后的个块依次后移总读旧写新删除需将之后的个块依次前移总修改定位后次读次写覆盖总文件最大长度受中文件长度字段位数或磁盘总容量限制例如若长度字段为位单位为字节则最大文件为缺点碎片产生外部碎片类似动态分区分配扩展难文件长度扩展时若后方无空闲块需整体迁移链接分配采用离散分配消除外部碎片隐式链接定义目录项指向第一块和最后一块每个磁盘块中隐含指向下一块的指针优点无外部碎片方便扩展缺点只支持顺序访问必须从头读可靠性差指针丢失导致文件断裂磁盘次数访问第块需次必须读取前个块才能获得第块的物理指针插入需读块次修改指针写写入新块写总删除需读块次修改指针写总修改读块次次写总文件最大长度理论上受磁盘总容量限制只要有空闲块即可链接实际上受中文件大小字段位数限制显式链接定义将链接指针集中存放在内存的一张表中文件分配表特点一个磁盘仅设置一张表表项与磁盘块一一对应物理块号索引表项内容下一块物理块号表示文件结束开机时表被读入内存访问机制逻辑块号物理块号不需要读磁盘直接在内存查询链表次虽是链式查找但完全在内存进行速度很快故称支持随机访问磁盘次数访问第块仅需次磁盘查表在内存进行找到物理块号后直接读盘插入查内存找空闲块修改内存链表仅需写入新数据块表周期性回写删除修改内存表项为修改定位后次读次写总计算示例若硬盘块大小总块数表项需位取位表大小占用内存过大文件最大长度受表项位数决定最大簇数和簇大小限制公式为位数如例如簇大小理论上限注实际实现通常限制单文件示意图样式定义文件分配表磁盘数据块块块块优点支持随机访问查内存表即可无外部碎片方便文件扩展缺点表占用较大的内存空间索引分配定义系统为每个文件建立一张索引表记录逻辑块号到物理块号的映射索引表存放的磁盘块称为索引块特点索引表可以直接映射支持随机访问索引块通常存在磁盘上访问文件需先读索引块磁盘次数单级索引访问第块需次次读索引块次读数据块若索引块已调入内存则只需次插入读索引块修改内存索引写回索引块写新数据块总删除读索引块修改内存索引写回索引块总修改读索引块读数据写数据总示意图样式定义磁盘块索引块块块块解决索引块不够用的方案链接索引将多个索引块链接起来缺点若文件很大需顺序查找索引块无法直接定位多级索引建立索引的索引类似多级页表二级索引顶级索引块二级索引块数据块访问次数级索引需次磁盘假设索引未缓存容量计算若块大小指针一个块存个指针二级索引最大文件混合索引常用结构中包含直接地址指针一级间接二级间接三级间接优势兼顾了小文件绝大多数的访问速度和大文件的容量举例假设个直接个一级个二级个三级小文件块直接访问次额外中文件用一级间接大文件用二三级间接文件最大长度公式其中为各级指针数量样式定义索引节点直接指针直接指针一级间接指针二级间接指针三级间接指针一级索引索引块二级索引一级索引块二级索引块数据块数据块数据块优点支持随机访问易于文件扩展只需分配新块并更新索引缺点索引表需占用额外的存储空间对极小文件而言开销比例大总结对比分配方式访问支持无外部碎片扩展性缺点连续分配顺序随机最快否差外部碎片扩展需移动隐式链接仅顺序是好无法随机访问可靠性低显式链接顺序随机是好占内存索引分配顺序随机是好索引块占磁盘文件保护为了防止文件被物理损坏备份机制和逻辑损坏访问控制本节主要讨论逻辑上的访问控制口令保护机制用户在建立文件时设置一个口令系统将口令附在文件的中访问用户请求访问时需提供口令验证通过后方可访问优点开销小验证速度快存储少仅需存储一个口令字段缺点安全性差口令直接存于系统内部若系统管理员或黑客读取了口令即泄露改进存储口令的哈希值不够灵活只要知道口令任何用户都能拥有完全权限加密保护机制使用密码算法如对文件内容进行加密访问只有持有正确密钥的用户才能将文件解密并读取优点保密性极强即使文件被拷贝或物理窃取没有密钥也无法获取内容缺点效率低加密解密需要消耗大量的时间访问控制最常用的保护机制定义谁对什么可以进行何种操作访问控制矩阵二维矩阵行代表用户进程列代表文件矩阵项表示用户对文件的权限缺点矩阵非常稀疏浪费存储空间实现方式访问控制列表基于列文件的划分机制为每个文件设置一张表记录哪些用户对该文件有什么权限示例优点方便查看某个文件的权限情况实现方式用户权限表基于行用户的划分机制为每个用户设置一张表记录该用户对哪些文件有什么权限示例优点方便查看某个用户的权限集合实现方式精简的访问列表模式将用户分为三类并用个二进制位记录权限用户分类拥有者创建文件的用户同组用户与拥有者在同一组的用户其他用户系统内的其他用户权限位读写执行示例样式定义访问控制矩阵行用户进程列文件对象值访问权限实现方式基于文件基于用户模式精简按列拆分按行拆分简化目录目录的基本概念目录的定义目录是一种特殊的文件目录文件内容由若干目录项组成目录项在传统文件系统中目录项就是文件名号在现代文件系统如中目录项仅包含文件名和索引节点号目录管理的要求目标实现按名存取用户只需提供文件名系统即可找到对应文件最基本功能提高检索速度合理组织目录结构如树形结构减少磁盘次数提供访问控制目录也需要保护不同用户对不同目录有不同的权限允许文件重名允许不同用户或不同目录下使用相同的文件名实现文件共享允许多个用户共享同一个文件目录的操作搜索当用户使用一个文件时需要根据文件名搜索目录找到该文件对应的目录项创建文件当创建一个新文件时需要在目录中增加一个目录项删除文件当删除一个文件时需要在目录中删除相应的目录项创建目录在当前目录中创建一个新的空目录如删除目录删除一个已存在的目录如若目录不为空可能需要递归删除显示目录列出目录中的所有文件项和子目录如修改目录修改目录的属性如文件名访问权限等重命名通常看作是修改的一种移动目录将目录及其内容从一个位置移动到另一个位置如改变当前目录改变进程的当前工作目录如遍历文件系统从根目录出发访问文件系统中的每一个目录和文件常用于文件备份目录结构目录结构的组织方式直接影响文件存取的效率和文件共享的灵活性单级目录结构定义整个文件系统只建立一张目录表每个文件占一个目录项示意图样式定义根目录文件文件文件特点线性结构所有文件都在同一层级缺点命名冲突不同用户不能使用相同文件名限制多文件多时查找速度慢不便于文件分类两级目录结构定义将目录分为主文件目录和用户文件目录结构记录用户名及指向该用户的指针记录该用户所有文件的示意图样式定义主文件目录用户用户用户目录文件文件用户目录文件优点解决重名不同用户可使用相同文件名隔离访问控制易于实现访问限制缺点缺乏灵活用户不能对自己文件再分类无子目录多级目录结构树形目录定义允许目录中包含子目录形成树状结构现代通用路径绝对路径从根目录出发如相对路径从当前目录出发如当前目录为每个进程设置一个当前工作目录减少路径检索长度示意图样式定义优点层次清晰解决重名便于分类缺点查找文件需逐级访问磁盘次数随着层级增加无环图目录结构定义在树形结构基础上允许目录项指向已存在的文件目录实现文件共享特点允许一个文件有多个父目录共享方式硬链接多个目录项指向同一个软链接符号链接创建新文件记录目标路径示意图样式定义用户用户删除问题需维护引用计数只有当所有用户都删除引用时才真正删除文件通用图目录结构定义允许图中出现环路问题搜索时可能产生无限循环删除时引用计数可能无法归零孤岛解决需垃圾回收机制开销大一般不采用目录结构检索效率对比不同目录结构在查找文件时的磁盘开销对比假设目录已在磁盘需逐级读取目录结构检索路径命名冲突共享支持检索效率磁盘平均检索公式文件总数单级目录仅文件名严重全系统唯一否慢线性扫描整个目录表两级目录用户名文件名解决用户间隔离难中扫描扫描为用户数树形目录逐级路径解决层次化否较慢随树深度增加而增加每级平均为树高无环图目录逐级路径解决支持较慢同树形但增加了别名同树形目录哈希目录哈希值解决极快直接定位忽略冲突目录实现目录的实现方式主要有线性列表和哈希表两种决定了目录检索的效率线性列表定义将目录项文件名号按顺序排列形成一个线性表实现可以使用数组或链表操作查找顺序遍历目录项匹配文件名创建扫描列表检查重名寻找空闲项插入删除扫描列表找到目标释放可选移动最后一种覆盖或标记为无效示意图样式定义优点实现简单逻辑清晰易于编程缺点检索慢线性查找时间复杂度为当目录中文件很多时效率显著下降优化排序将目录项按文件名排序可使用二分查找但插入删除时维护顺序开销大树现代文件系统如常使用树来管理目录大幅提高大规模目录的检索速度哈希表定义根据文件名通过哈希函数计算出目录项在表中的位置桶实现文件名索引值哈希表中的每一项指向一个线性列表解决冲突示意图样式定义文件名索引哈希表冲突链优点检索快平均查找时间为缺点哈希冲突需要机制解决冲突如链地址法定长限制哈希表大小通常固定扩展需重哈希管理复杂需设计良好的哈希函数对比总结特性线性列表哈希表查找速度慢未排序快实现难度简单较复杂需处理冲突空间开销紧凑需预分配哈希桶适用场景小规模目录大规模目录文件共享文件共享允许不同用户通过不同的文件名访问同一个文件既节省存储空间又便于协同工作主要有硬链接和软链接两种方式基于索引节点的共享硬链接定义在目录中创建一个新的目录项直接指向目标文件的索引节点原理两个目录项文件名不同指向同一个中维护一个链接计数操作创建增加目录项删除删除目录项真正删除当且仅当时才释放和数据块示意图样式定义用户目录用户目录硬链接数据块指向指向优点速度快直接访问无额外开销同步修改其中一个另一个立即可见实际是同一文件缺点不可跨文件系统编号仅在当前分区唯一不可链接目录防止形成环路导致文件遍历死循环基于符号链的共享软链接定义创建一个特殊的类型文件其内容是目标文件的完整路径名类似的快捷方式原理系统访问软链接时发现是类型读取其内容路径然后根据路径重新查找文件示意图样式定义用户目录原文件用户目录软链接数据块数据块内容解析路径优点跨文件系统可以链接网络文件系统或其他分区的文件可链接目录不会造成死循环系统可检测层级缺点访问慢需要多次读盘读软链接解析路径读原文件空间开销需要额外的和数据块存储路径悬空指针若原文件被删除移动软链接失效找不到目标硬链接软链接对比特性硬链接软链接实现机制指向同一存储目标路径跨文件系统不可可以链接目录不可可以删除原文件仍可访问只要失效悬空访问速度快较慢需解析路径数量不增加共用增加新文件本节小结树形目录结构是现代的主流硬链接就像别名软链接就像快捷方式注意删除操作对两种链接的不同影响文件系统文件系统结构从上到下层次结构用户接口命令系统调用文件目录系统目录管理与检索存取控制与保护权限与访问控制逻辑文件系统与文件信息缓冲区逻辑记录到逻辑块物理文件系统逻辑块到物理块子系统设备管理与调度设备驱动程序与硬件交互文件系统七层结构用户接口文件目录系统存取控制与保护逻辑文件系统文件信息缓冲区物理文件系统子系统设备驱动程序分层要点与示例用户接口命令系统调用提供面向用户程序的入口文件目录系统组织目录与目录项支持路径检索与重名处理维护关联存取控制与保护口令加密访问控制矩阵权限位与文件锁逻辑文件系统与文件信息缓冲区逻辑记录到逻辑块的转换缓冲区管理与一致性维护物理文件系统块分配与回收连续链接索引分配空闲空间管理位示图链表成组链接子系统缓存预读写回调度算法减少寻道与旋转延迟设备驱动程序中断队列与硬件协议交互层次速记表层次职责关键词用户接口命令系统调用文件目录系统目录项检索与管理路径存取控制与保护权限与访问控制加密锁逻辑文件系统与缓冲区记录逻辑块缓冲一致性缓存物理文件系统逻辑块物理块分配位示图成组链接子系统调度与缓存设备驱动程序硬件交互中断关键对象与职责记录文件系统整体元信息总块数空闲块数数挂载信息记录单个文件的元数据权限时间戳大小块地址目录项缓存维护名称到的映射加速路径解析打开文件的会话对象维护读写偏移访问模式指向的引用路径解析与权限检查路径分解为组件逐级在缓存中查找未命中则访问底层文件系统并回填缓存每级目录进行权限检查读执行权限决定是否可穿越目录目标文件检查读写权限与锁状态遇到挂载点时切换到挂载的继续解析遇到软链接可选择原子解析或逐段解析缓存机制读写加速以页为单位缓存文件数据支撑内存映射与顺序读写预取缓冲块设备的元数据与小块减少实际磁盘访问减少目录项与的重复读盘日志文件系统写前日志记录元数据变更崩溃后回放保证一致性模式示例默认最强一致性代价最大文件系统布局磁盘分区引导块存放操作系统引导程序超级块记录文件系统的整体信息空闲块数数等空闲空间管理信息位示图或空闲链表区域存放所有的数据区域存放文件数据主引导记录位于磁盘第扇区包含引导代码分区表项签名支持最多个主分区通过扩展分区链组织多个逻辑分区分区表现代分区方案包含保护性头分区项表起分区项通常默认可记录项支持分区冗余与更强的一致性卷引导记录位于分区内的文件系统引导区等与属于磁盘级不同属于分区卷级磁盘主分区主分区扩展分区逻辑分区逻辑分区数据与分区区域引导块超级块组描述符控制信息位示图空闲链表表数据区日志区重要字段举例以类为例直接间接索引指针目录项类型普通目录链接常见文件系统布局示例由引导扇区两份表根目录区固定位于数据区数据区组成以簇为最小分配单位副本采用分组布局每组包含位示图表与数据块超级块与组描述符在磁盘开头并有稀疏备份一切皆文件以主文件表为核心包含日志空闲位图镜像等主文件表日志空闲位图镜像数据区内存结构系统打开文件表整个系统一张记录所有打开文件的信息引用计数进程打开文件表每个进程一张记录该进程打开的文件指向系统表的指针计算与实践要点位示图大小字节盘块总数表大小数结构大小单分组设计有利于局部性在同组内尽量让目录数据块相邻降低寻道与读盘次数双表冗余用于容错通过与日志保证一致性系列支持稀疏超级块与日志模式选择分区表最多项扩展分区通过链组织多个逻辑分区分区项大小通常分区项表大小分区项数量具备保护性与冗余备份文件存储空间管理管理磁盘上的空闲块空闲表法记录所有空闲区的起始块号和长度适用于连续分配表项形式起始块号长度常见策略首次适应从头扫描遇到第一个长度需求即分配简单高效最佳适应从所有空闲区中选长度最接近的减少碎片但查找成本高最坏适应从最大空闲区分配保留大块适用性有限回收与合并回收时按块号插入尝试与前后相邻空闲区合并降低外部碎片适用场景需要较多连续空间时大文件顺序效果好空闲表空闲链表法空闲盘块链以盘块为单位链接空闲盘区链以盘区为单位链接分配盘块链支持按块逐个取用盘区链支持一次取连续区常配合首次最佳适应回收插入链表并尝试与相邻合并盘区链盘块链直接挂接简单但连续性差适用场景文件增长为小步多次追加写链表易维护结构定义盘块链节点指向下一个空闲块的块号盘区链节点表示连续空闲区分配流程盘块链分配个块从链表头按需取次更新链表头不保证连续性盘区链分配个连续块顺序查找第一个的节点若直接摘除该节点若保持链有序回收与合并盘块链将释放块以头插尾插方式接回链表盘区链按有序插入若与前后相邻区满足或则合并两侧相邻时三段归并降低外部碎片维护策略有序链盘区链按有序利于合并按有序利于最佳适应但插入维护成本高分级空闲链依据区段大小分桶维护多条链快速定位近似大小区段减少线性扫描循环双向链提升插入与合并时前驱后继访问效率位示图法用二进制位表示盘块的使用情况为空闲为占用优点容易找到连续空闲块位示图小可常驻内存盘块号与行列号转换字长行号列号常用计算位示图大小字节盘块总数例块块数位示图大小操作扫描连续的区段实现连续分配支持快速定位与批量设置清零适用场景需要高效定位与可常驻内存的系统亦使用位图管理空闲成组链接法系统采用将空闲块分组每组的第一个块记录下一组的空闲块号优点适合大型文件系统结构与操作每组保存若干可用块号当当前组耗尽时使用组头信息加载下一组减少磁盘访问次数适用场景超大磁盘高并发环境降低维护与读盘开销盘块盘区对比表项目盘块盘区盘区定义固定大小的最小分配传输单位由连续多个盘块组成的变长区域大小固定如簇变长若干块组成连续性不保证可离散分配保证连续一次分配一段分配粒度按块逐个分配回收按区成段分配回收管理结构位示图盘块链空闲表盘区链区段树碎片特性外部碎片少随机访问跳跃多易产生外部碎片顺序访问性能好适用场景小文件频繁追加小步增长大文件顺序需连续空间检索效率随机访问友好映射简单顺序访问友好寻道旋转延迟小典型实现位图块分配方法对比方法连续空间找到效率维护开销内存占用适用场景空闲表高依策略中合并分裂低需连续空间的大文件盘块链低低低小步追加简单维护盘区链中中低连续区与合并需求位示图高低中但可常驻快速定位批量操作成组链接中低低超大规模并发典型计算题位示图大小已给出公式与示例连续区分配空闲表盘区链用首次适应记录分配区并更新剩余长度必要时合并相邻空闲区碎片评估空闲表能更好地维持连续区盘块链碎片多位示图可快速合并与检测连续段虚拟文件系统内核的一层抽象层位于用户程序和具体文件系统之间作用屏蔽底层具体文件系统的差异提供统一的接口实现定义了一组对象和操作函数指针路径解析流程拆分路径命中缓存则直接返回未命中则查询底层文件系统并创建新的目录与文件的权限在每一步校验考虑挂载点与跨文件系统边界的切换打开文件后生成对象维护读写偏移与访问模式并与关联对象与操作表对象关键字段典型操作集块大小总块数挂载信息模式权限大小时间戳块地址名称父子层级缓存标记读写偏移访问模式指针名称缓存与负负名称存在于父目录但目标不存在的缓存项避免重复磁盘查找重新验证某些文件系统或目录项在缓存命中时仍需二次校验网络远程可变大小目录大小写敏感性由底层决定例敏感可不敏感打开读写流程简版路径解析权限检查创建查找与生成对象并绑定命中则直接拷贝未命中从块设备读入页并回填缓存更新读写偏移写入页缓存并标记脏页依据策略触发写回与日志记录更新大小与时间戳直写直接绕过缓存直接与块层交互用于数据库大文件顺序挂载与命名空间挂载点切换路径解析可跨文件系统继续进行绑定挂载用于同目录多视图命名空间使不同进程拥有独立的挂载树容器场景易错点是抽象层不等同于具体文件系统对象操作集通过函数指针桥接具体实现是名称缓存项不等同于磁盘上的目录文件负可加速未找到场景打开后系统用引用不再用文件名硬链接与软链接的解析与缓存行为不同文件系统挂载将一个文件系统安装到目录树的某个节点挂载点上挂载后该节点成为新文件系统的根目录根目录分区分区常用操作说明指定设备类型挂载点与选项只读等卸载挂载点需保证不存在打开引用与活动工作目录绑定挂载将目录在多个位置呈现便于隔离与容器场景文件系统类型速览类型日志支持目录索引适用场景否否兼容性好移动介质是是桌面服务器是是桌面服务器是是大文件并发优先本章疑难点打开文件到底做了什么主要工作是将文件的控制信息从磁盘读入内存建立系统打开文件表项和进程打开文件表项并返回索引号之后的操作直接利用内存中的信息避免重复查目录硬链接和软链接的区别硬链接指向不能跨文件系统不能链接目录软链接指向路径可以跨文件系统可以链接目录效率稍低',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-04 19:40:28',
  postMainColor: '#10B981',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/sparkle520?tab=repositories" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">SPARKLE</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size: 1.05rem;">408<sup>10</sup></a><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Deep-Learning/" style="font-size: 1.05rem;">Deep Learning<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/JSR303/" style="font-size: 1.05rem;">JSR303<sup>1</sup></a><a href="/tags/Matplotlib/" style="font-size: 1.05rem;">Matplotlib<sup>3</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c#<sup>2</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>4</sup></a><a href="/tags/npc%E5%88%86%E6%9E%90%E6%B3%95/" style="font-size: 1.05rem;">npc分析法<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>5</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>1</sup></a><a href="/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/" style="font-size: 1.05rem;">二次型<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%82/" style="font-size: 1.05rem;">你的名字。<sup>3</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">你的名字同名小说<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%A4%96%E4%BC%A0%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">你的名字外传小说<sup>1</sup></a><a href="/tags/%E5%80%92%E8%A3%85%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">倒装结构<sup>1</sup></a><a href="/tags/%E5%86%99%E4%BD%9C/" style="font-size: 1.05rem;">写作<sup>4</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">包管理<sup>1</sup></a><a href="/tags/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/" style="font-size: 1.05rem;">卷积公式<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/" style="font-size: 1.05rem;">天气之子<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">天气之子同名小说<sup>1</sup></a><a href="/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/" style="font-size: 1.05rem;">定积分<sup>1</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">小说<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" style="font-size: 1.05rem;">数据校验<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 1.05rem;">概率论<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" style="font-size: 1.05rem;">概率论与数理统计<sup>7</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.05rem;">汇编<sup>9</sup></a><a href="/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" style="font-size: 1.05rem;">泰勒展开<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%80%BC/" style="font-size: 1.05rem;">特征值<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" style="font-size: 1.05rem;">特征向量<sup>1</sup></a><a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 1.05rem;">线性代数<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/" style="font-size: 1.05rem;">英语听力<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 1.05rem;">英语语法<sup>16</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">计算机组成原理<sup>6</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/" style="font-size: 1.05rem;">词根词缀<sup>1</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" style="font-size: 1.05rem;">高等代数<sup>2</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">高等数学<sup>9</sup></a><a href="/tags/%E9%AB%98%E9%A2%91%E8%AF%8D%E7%BB%84/" style="font-size: 1.05rem;">高频词组<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/02/"><span class="card-archive-list-date">二月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/01/"><span class="card-archive-list-date">一月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">十二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url">计算机</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>操作系统</span></a><a class="article-meta__tags" href="/tags/408/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>408</span></a></span></div></div><h1 class="post-title" itemprop="name headline">408-操作系统-4-文件管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-12-25T15:00:27.000Z" title="发表于 2025-12-25 23:00:27">2025-12-25</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2026-01-04T11:40:28.247Z" title="更新于 2026-01-04 19:40:28">2026-01-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">17.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="408-操作系统-4-文件管理"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为系守镇"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>系守镇</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic1.imgdb.cn/item/6951243ca0c391c56de5e622.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"><header><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url">计算机</a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">操作系统</a><a href="/tags/408/" tabindex="-1" itemprop="url">408</a><h1 id="CrawlerTitle" itemprop="name headline">408-操作系统-4-文件管理</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">sparkle520</span><time itemprop="dateCreated datePublished" datetime="2025-12-25T15:00:27.000Z" title="发表于 2025-12-25 23:00:27">2025-12-25</time><time itemprop="dateCreated datePublished" datetime="2026-01-04T11:40:28.247Z" title="更新于 2026-01-04 19:40:28">2026-01-04</time></header><h1 id="第4章-文件管理">第4章 文件管理</h1>
<h2 id="文件系统基础">4.1 文件系统基础</h2>
<h3 id="文件的基本概念">4.1.1 文件的基本概念</h3>
<h4 id="文件的定义">1. 文件的定义</h4>
<ul>
<li><strong>文件 ( File )</strong> :
是以计算机硬盘为载体存储在计算机上的信息集合.</li>
<li><strong>逻辑结构</strong> : 在用户看来, 文件是 <strong>记录</strong>
的集合 ( 逻辑文件 ).</li>
<li><strong>物理结构</strong> : 在操作系统看来, 文件是 <strong>物理块 (
Block / Cluster )</strong> 的集合 ( 物理文件 ).
<ul>
<li><strong>文件块 ( File Block )</strong> :
<ul>
<li><strong>定义</strong> : 文件的逻辑地址空间被划分为若干个等长的块 (
逻辑块 ), 通常与物理块大小一致.</li>
<li><strong>作用</strong> : 作为 <strong>信息存储</strong> 和
<strong>传输</strong> ( I/O ) 的基本单位.</li>
</ul></li>
<li><strong>簇 ( Cluster )</strong> :
<ul>
<li><strong>定义</strong> : 操作系统分配磁盘空间 ( 和进行磁盘 I/O ) 的
<strong>最小单位</strong>. ( 在 Windows 中称为簇, 在 Linux 中称为块
Block ).</li>
<li><strong>关系</strong> :
<ul>
<li><strong>逻辑块</strong> <span
class="math inline">\(\leftrightarrow\)</span> <strong>物理块 ( 簇
)</strong> <span class="math inline">\(\leftrightarrow\)</span>
<strong>扇区 ( Sector )</strong>.</li>
<li>1 个簇 = <span class="math inline">\(2^k\)</span> 个物理扇区 (
Sector ). ( 如 1 Cluster = 4KB = 8 Sectors ).</li>
</ul></li>
<li><strong>大小权衡</strong> :
<ul>
<li><strong>块太小</strong> : 索引表过大 ( 管理开销大 ); 磁盘 I/O 次数多
( 寻道时间占比高 ); 空间利用率高 ( 碎片少 ).</li>
<li><strong>块太大</strong> : 索引表小; I/O 效率高;
<strong>内部碎片</strong> 大 ( 空间利用率低 ).</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>组成</strong> : 文件通常由 <strong>数据项</strong>,
<strong>记录</strong> 和 <strong>文件</strong> 三级组成.
<ul>
<li><strong>数据项</strong> : 基本数据项 ( 原子数据, 如姓名 ),
组合数据项 ( 组项, 如工资 ).</li>
<li><strong>记录</strong> : 一组相关数据项的集合.</li>
<li><strong>文件</strong> : 由创建者定义的,
具有文件名的一组相关元素的集合.</li>
</ul></li>
</ul>
<h4 id="文件的属性">2. 文件的属性</h4>
<p>操作系统通过文件控制块 (FCB) 来维护文件属性.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">属性名称</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>文件名</strong></td>
<td style="text-align: left;">文件在目录中的名称,
同一目录下不允许重名</td>
<td style="text-align: left;">用户视角, 方便记忆</td>
</tr>
<tr>
<td style="text-align: left;"><strong>标识符</strong></td>
<td style="text-align: left;">文件的唯一标签, 对用户不可见</td>
<td style="text-align: left;">系统视角, 用于区分文件</td>
</tr>
<tr>
<td style="text-align: left;"><strong>类型</strong></td>
<td style="text-align: left;">文件的类型 ( 如 <code>.txt</code>,
<code>.exe</code> )</td>
<td style="text-align: left;">决定了文件的打开方式</td>
</tr>
<tr>
<td style="text-align: left;"><strong>位置</strong></td>
<td style="text-align: left;">指向设备和设备上文件开头的指针</td>
<td style="text-align: left;">用于定位文件物理地址</td>
</tr>
<tr>
<td style="text-align: left;"><strong>大小</strong></td>
<td style="text-align: left;">文件当前的大小 ( 字节/块 )</td>
<td style="text-align: left;">用于存储分配</td>
</tr>
<tr>
<td style="text-align: left;"><strong>保护信息</strong></td>
<td style="text-align: left;">访问控制列表 ( ACL ), 读/写/执行权限</td>
<td style="text-align: left;">确保文件安全</td>
</tr>
<tr>
<td style="text-align: left;"><strong>时间/用户</strong></td>
<td style="text-align: left;">创建时间, 上次修改时间, 上次访问时间,
所有者</td>
<td style="text-align: left;">用于文件保护和统计</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>重点辨析 : 文件名 vs 标识符</strong>
<ul>
<li><strong>文件名 ( Filename )</strong> :
<ul>
<li><strong>面向用户</strong> : 字符串形式, 方便记忆 ( 如
<code>report.docx</code> ).</li>
<li><strong>可变性</strong> : 用户可以随时修改文件名,
但不影响文件内容.</li>
<li><strong>非唯一性</strong> : 不同目录下的文件可以同名; 硬链接机制下,
一个文件可以有多个文件名.</li>
</ul></li>
<li><strong>标识符 ( Identifier )</strong> :
<ul>
<li><strong>面向系统</strong> : 通常是数字 ( 如 Inode Number ),
系统内部使用.</li>
<li><strong>唯一性</strong> : 在整个文件系统 ( 或分区 )
中唯一标识一个文件.</li>
<li><strong>不可变性</strong> : 文件创建时分配,
直到文件被彻底删除才回收.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="文件的分类">3. 文件的分类</h4>
<ul>
<li><strong>按性质和用途分类</strong> :
<ul>
<li><strong>系统文件</strong> : 操作系统核心文件,
通常只允许通过系统调用访问.</li>
<li><strong>用户文件</strong> : 用户创建的文件, 归属于特定用户.</li>
<li><strong>库文件</strong> : 标准子程序库或函数库,
允许用户调用但不允许修改.</li>
</ul></li>
<li><strong>按数据的组织形式分类</strong> :
<ul>
<li><strong>普通文件</strong> : 存储用户数据 ( 如文本文件, 二进制文件
).</li>
<li><strong>目录文件</strong> : 存储文件目录信息, 由文件系统管理.</li>
<li><strong>特殊文件</strong> : 设备文件 ( 如 I/O 设备 ),
通常作为文件处理.</li>
</ul></li>
<li><strong>按保护级别分类</strong> :
<ul>
<li><strong>只读文件</strong> : 仅允许读取.</li>
<li><strong>读写文件</strong> : 允许读取和修改.</li>
<li><strong>可执行文件</strong> : 允许加载执行.</li>
</ul></li>
<li><strong>按流式/记录式分类</strong> :
<ul>
<li><strong>流式文件</strong> : 无结构字节流 ( 如 UNIX/Linux 文件
).</li>
<li><strong>记录式文件</strong> : 有结构的记录集合 ( 如 数据库文件
).</li>
</ul></li>
</ul>
<h4 id="文件的基本操作">4. 文件的基本操作</h4>
<p>操作系统提供了一组 <strong>系统调用</strong> ( System Calls )
来对文件进行操作.</p>
<ul>
<li><strong>创建文件 ( Create )</strong> : 分配外存空间,
在目录中创建目录项.</li>
<li><strong>删除文件 ( Delete )</strong> : 释放外存空间,
删除目录项.</li>
<li><strong>打开文件 ( Open )</strong> : 将文件属性 ( FCB )
从外存复制到内存打开文件表, 返回文件描述符/句柄. ( 避免多次检索目录
).</li>
<li><strong>关闭文件 ( Close )</strong> : 将内存中的 FCB
及其修改写回外存, 释放内存表项.</li>
<li><strong>读文件 ( Read )</strong> : 根据读指针,
将文件数据从外存读入内存缓冲区.</li>
<li><strong>写文件 ( Write )</strong> :
将内存缓冲区数据写入外存文件.</li>
<li><strong>截断文件 ( Truncate )</strong> : 将文件长度设为 0,
保留文件名和属性, 释放空间.</li>
</ul>
<h3 id="文件控制块和索引节点">4.1.2 文件控制块和索引节点</h3>
<h4 id="文件控制块-fcb">1. 文件控制块 ( FCB )</h4>
<p>为了能对一个文件进行正确的存取,
操作系统必须为文件设置用于描述和控制文件的数据结构, 称之为
<strong>文件控制块 ( FCB )</strong>.</p>
<ul>
<li><strong>FCB 与 文件</strong> : 一一对应.</li>
<li><strong>目录项</strong> : 文件目录通常是由有序的 FCB 集合组成的.
一个 FCB 就是一个文件目录项.</li>
<li><strong>包含信息</strong> :
<ul>
<li><strong>基本信息</strong> : 文件名, 物理位置 ( 起始块号, 块数 ),
逻辑结构, 物理结构.</li>
<li><strong>存取控制信息</strong> : 文件主, 核准用户, 读写权限 ( R/W/X
).</li>
<li><strong>使用信息</strong> : 创建时间, 上次修改时间,
当前打开计数.</li>
</ul></li>
<li><strong>缺点</strong> : FCB 包含了文件名和文件描述信息.
在检索目录时, 我们只需要匹配文件名, 但不得不将整个 FCB 读入内存. 若 FCB
较大, 一个磁盘块能容纳的目录项就少, 导致检索文件时磁盘 I/O
次数增加.</li>
</ul>
<h4 id="索引节点-inode">2. 索引节点 ( Inode )</h4>
<p>为了解决 FCB 过大导致的目录检索效率低的问题, 现代操作系统 ( 如
UNIX/Linux ) 采用了 <strong>索引节点</strong> 结构.</p>
<ul>
<li><strong>设计思想</strong> : <strong>瘦身</strong>. 将
<strong>文件名</strong> 与 <strong>文件描述信息</strong> 分离.
<ul>
<li><strong>目录项</strong> : 仅包含 <strong>文件名</strong> 和
<strong>索引节点号 ( Inode Number )</strong>. ( 体积变得非常小 ).</li>
<li><strong>索引节点</strong> : 包含除文件名之外的所有文件描述信息 (
如文件大小, 物理地址, 权限等 ).</li>
</ul></li>
<li><strong>优势</strong> : 目录项变小 <span
class="math inline">\(\to\)</span> 每个磁盘块能存更多目录项 <span
class="math inline">\(\to\)</span> 检索文件时所需的磁盘 I/O
次数显著减少.</li>
</ul>
<h4 id="磁盘索引节点-vs-内存索引节点">3. 磁盘索引节点 vs
内存索引节点</h4>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">磁盘索引节点 ( Disk Inode )</th>
<th style="text-align: left;">内存索引节点 ( Memory Inode )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>存储位置</strong></td>
<td style="text-align: left;">存放在磁盘 ( Disk ) 上</td>
<td style="text-align: left;">存放在内存 ( RAM ) 中</td>
</tr>
<tr>
<td style="text-align: left;"><strong>生命周期</strong></td>
<td style="text-align: left;">永久存在 ( 随文件创建而生, 删除而灭 )</td>
<td style="text-align: left;">临时存在 ( 文件打开时创建, 关闭时销毁
)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>包含内容</strong></td>
<td style="text-align: left;">静态文件描述信息</td>
<td style="text-align: left;">磁盘 Inode 副本 + 运行时动态信息</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>磁盘索引节点 ( Disk Inode )</strong> :
<ul>
<li><strong>文件主标识符</strong> : 拥有该文件的用户 ID ( uid ).</li>
<li><strong>文件类型</strong> : 普通文件、目录文件或特别文件.</li>
<li><strong>文件存取权限</strong> : 各类用户对该文件的存取权限 ( rwx
).</li>
<li><strong>物理地址指针</strong> : 每个指针指向一个磁盘块 (
直接索引/间接索引 ).</li>
<li><strong>文件长度</strong> : 文件字节数.</li>
<li><strong>链接计数 ( nlink )</strong> : 硬链接数量. 当此值为 0 时,
回收文件空间.</li>
</ul></li>
<li><strong>内存索引节点 ( Memory Inode )</strong> :
<ul>
<li><strong>索引节点编号</strong> : 标识该 Inode.</li>
<li><strong>状态标识 ( state )</strong> : 指示 Inode
是否被上锁、是否被修改 ( dirty ).</li>
<li><strong>访问计数 ( count )</strong> : 当前有多少个进程打开了该文件.
( count=0 时才真正从内存释放 ).</li>
<li><strong>逻辑设备号</strong> : 文件所在设备的设备号.</li>
<li><strong>链接指针</strong> : 用于将内存 Inode
链接成空闲链表或哈希队列.</li>
<li><em>( 包含磁盘 Inode 的所有信息 )</em></li>
</ul></li>
</ul>
<h4 id="示例对比">4. 示例对比</h4>
<ul>
<li><strong>传统 FCB</strong> : 假设一个 FCB 占 64B, 盘块 1KB.
一个盘块存 <span class="math inline">\(1024/64 = 16\)</span>
个目录项.</li>
<li><strong>Inode 法</strong> : 假设目录项 ( 文件名 + 索引节点号 ) 占
16B. 一个盘块存 <span class="math inline">\(1024/16 = 64\)</span>
个目录项.</li>
<li><strong>结论</strong> : 同等条件下, Inode 法检索目录的平均 I/O
次数约为传统 FCB 的 <span class="math inline">\(1/4\)</span>.</li>
</ul>
<h3 id="文件的操作">4.1.3 文件的操作</h3>
<h4 id="创建文件-create">1. 创建文件 ( Create )</h4>
<ul>
<li><strong>系统调用</strong> : <code>create(filename, mode)</code></li>
<li><strong>核心工作</strong> :
<ol type="1">
<li><strong>分配外存</strong> : 在外存中寻找空闲块 ( 如空闲链表、位示图
).</li>
<li><strong>创建目录项</strong> : 在父目录中增加一项,
记录文件名、外存地址等信息.</li>
<li><strong>初始化</strong> : 建立 FCB/Inode, 设置默认属性 (
如所有者、权限 ).</li>
</ol></li>
</ul>
<h4 id="删除文件-delete">2. 删除文件 ( Delete )</h4>
<ul>
<li><strong>系统调用</strong> : <code>delete(filename)</code></li>
<li><strong>核心工作</strong> :
<ol type="1">
<li><strong>查找目录</strong> : 根据文件名找到对应的目录项.</li>
<li><strong>回收资源</strong> : 释放文件占用的外存块 ( 修改位示图/FAT
).</li>
<li><strong>删除目录项</strong> :
将该目录项标记为无效或从目录文件中移除.</li>
<li><strong>回收 Inode</strong> : 若引用计数 ( nlink ) 为 0, 则回收
Inode.</li>
</ol></li>
</ul>
<h4 id="打开文件-open">3. 打开文件 ( Open )</h4>
<ul>
<li><p><strong>系统调用</strong> :
<code>fd = open(filename, flags)</code></p></li>
<li><p><strong>核心工作</strong> : 将文件的控制信息 ( FCB/Inode )
从外存读入内存, 建立相关数据结构.</p></li>
<li><p><strong>打开文件表结构</strong> :</p>
<ul>
<li><strong>进程打开文件表</strong> : 每个进程独有 ( PCB 中 ). 记录
<strong>当前读写指针</strong>, <strong>系统表索引</strong>.</li>
<li><strong>系统打开文件表</strong> : 整个系统只有一张. 记录
<strong>Inode 信息</strong>, <strong>打开计数 ( count )</strong>.</li>
</ul></li>
<li><p><strong>流程图解</strong> :</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef process fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef fd fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef ptable fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef stable fill:#FFEDD5,stroke:#EA580C,stroke-width:2px,color:#9A3412,rx:5,ry:5,font-weight:bold;
    classDef inode fill:#F3E8FF,stroke:#9333EA,stroke-width:2px,color:#7E22CE,rx:5,ry:5,font-weight:bold;
    classDef sub fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    subgraph UserSpace[&quot;用户空间 ( User Space )&quot;]
        direction TB
        UserProc(&quot;进程 P ( PCB )&quot;):::process
        FD[&quot;文件描述符 ( fd )&quot;]:::fd
        
        UserProc -.- FD
    end
    
    subgraph KernelSpace[&quot;内核空间 ( Kernel Space )&quot;]
        direction TB
        PTable[&quot;进程打开文件表&lt;br&#x2F;&gt;( 读写指针, 权限 )&quot;]:::ptable
        STable[&quot;系统打开文件表&lt;br&#x2F;&gt;( 打开计数, Inode信息 )&quot;]:::stable
        Inode[&quot;内存 Inode&lt;br&#x2F;&gt;( 物理地址, 链接数 )&quot;]:::inode
        
        PTable --&gt; STable --&gt; Inode
    end
    
    %% 跨空间连线
    FD --&gt;|&quot;索引&quot;| PTable

    %% 应用子图样式
    class UserSpace,KernelSpace sub
  </pre></div></li>
</ul>
<div class="note sparkle simple"><p><strong>注</strong></p>
<ol type="1">
<li><code>Open</code> 操作本身 <strong>不进行数据传输</strong>,
只是把文件属性读入内存, 为后续读写做准备.</li>
<li>文件打开后, 操作系统只使用 <strong>文件标识符 ( fd )</strong>
来引用文件, 而不再使用文件名.</li>
</ol>
</div>
<h4 id="关闭文件-close">4. 关闭文件 ( Close )</h4>
<ul>
<li><strong>系统调用</strong> : <code>close(fd)</code></li>
<li><strong>核心工作</strong> :
<ol type="1">
<li><strong>删除进程表项</strong> : 释放进程打开文件表中的对应项.</li>
<li><strong>减少引用计数</strong> : 系统打开文件表中对应项的 count 减
1.</li>
<li><strong>写回/释放</strong> : 若 count = 0, 将内存 Inode ( 若修改 )
写回磁盘, 并释放系统表项.</li>
</ol></li>
</ul>
<h4 id="读写文件-readwrite">5. 读/写文件 ( Read/Write )</h4>
<ul>
<li><strong>系统调用</strong> : <code>read(fd, buf, size)</code>,
<code>write(fd, buf, size)</code></li>
<li><strong>核心工作</strong> :
<ol type="1">
<li><strong>定位</strong> : 根据 fd 找到进程表项 <span
class="math inline">\(\to\)</span> 系统表项 <span
class="math inline">\(\to\)</span> 内存 Inode <span
class="math inline">\(\to\)</span> 物理地址.</li>
<li><strong>转换</strong> : 将逻辑地址 ( 偏移量 ) 转换为物理地址 ( 块号
+ 块内偏移 ).</li>
<li><strong>传输</strong> : 在内存缓冲区和磁盘之间传输数据.</li>
<li><strong>更新</strong> : 修改读写指针位置.</li>
</ol></li>
</ul>
<h4 id="文件重定位-seek">6. 文件重定位 ( Seek )</h4>
<ul>
<li><strong>系统调用</strong> :
<code>lseek(fd, offset, whence)</code></li>
<li><strong>核心工作</strong> : 修改进程打开文件表中该文件的
<strong>读写指针</strong> 位置. ( 不涉及 I/O 操作 ).</li>
</ul>
<h3 id="文件的逻辑结构">4.1.4 文件的逻辑结构</h3>
<p>指在用户看来，文件内部的数据是如何组织的.</p>
<h4 id="无结构文件-流式文件">1. 无结构文件 ( 流式文件 )</h4>
<ul>
<li><strong>定义</strong> : 文件内部没有结构，看作是一串字符流.</li>
<li><strong>特点</strong> : 管理简单，用户方便.</li>
<li><strong>应用</strong> : 源程序文件、目标代码文件、UNIX/Linux
的所有文件.</li>
<li><strong>访问</strong> : 只能利用读写指针按 <strong>字节</strong>
依次读写.</li>
</ul>
<h4 id="有结构文件-记录式文件">2. 有结构文件 ( 记录式文件 )</h4>
<p>文件由一组相似的 <strong>记录</strong> 组成, 每条记录由若干
<strong>数据项</strong> 组成. 记录是文件存取的基本单位.</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef struct fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef detail fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef sub fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    Logic[&quot;逻辑结构&quot;]:::struct
    
    subgraph Types[&quot;类型分类&quot;]
        direction TB
        Seq[&quot;顺序文件&quot;]:::detail
        Idx[&quot;索引文件&quot;]:::detail
        IdxSeq[&quot;索引顺序文件&quot;]:::detail
        Hash[&quot;直接&#x2F;散列文件&quot;]:::detail
    end

    Logic --&gt; Seq
    Logic --&gt; Idx
    Logic --&gt; IdxSeq
    Logic --&gt; Hash
    
    %% 应用子图样式
    class Types sub
  </pre></div>
<h4 id="组头结构-示例">组头结构 ( 示例 )</h4>
<ul>
<li>组头字段 : Count ( 本组可用块个数 )、Array[Count] ( 可用块号列表
)、NextGroupBlock ( 下一组组头所在块号 ).</li>
<li>内存缓存 : 超级块常驻内存中保存当前组的拷贝,
分配/回收时优先在内存更新, 必要时写回磁盘.</li>
</ul>
<h4 id="分配流程-单块多块">分配流程 ( 单块/多块 )</h4>
<ul>
<li>单块分配 :
<ol type="1">
<li>若 Count&gt;0, 返回 Array[Count], Count–.</li>
<li>若 Count=0, 读取 NextGroupBlock 作为新组头,
替换当前组后继续分配.</li>
</ol></li>
<li>分配 k 块 : 重复上述步骤 k 次; 若跨组, 需按组头链读取新组.</li>
</ul>
<h4 id="回收流程">回收流程</h4>
<ul>
<li>释放一个块号 b :
<ol type="1">
<li>若 Count 未满, 将 b 写入 Array[++Count].</li>
<li>若 Count 达到上限 ( 组满 ), 将当前组写入 b 所在块作为新组头, 设置
NextGroupBlock=当前组原组头位置, 重置当前组 ( 实现有差异 ).</li>
</ol></li>
</ul>
<h4 id="复杂度与-io-估算">复杂度与 I/O 估算</h4>
<ul>
<li>分配/回收均为 O(1) 平均时间 ( 组内数组压栈/出栈 ).</li>
<li>跨组时需要读取下一组头, 产生 1 次磁盘 I/O;
因此摊还开销随组大小增大而降低.</li>
<li>估算 : 组大小为 G, 每分配 G 次平均产生 1 次 I/O, 摊还为 1/G
次/分配.</li>
</ul>
<h4 id="组大小选择建议">组大小选择建议</h4>
<ul>
<li>过小 : 频繁切换组, I/O 开销增加.</li>
<li>过大 : 组头占用空间增大, 更新开销增加.</li>
<li>结合块大小与缓存能力选择, 与文件系统页/块缓存策略协同设计.</li>
</ul>
<h4 id="与位示图链表的对比要点">与位示图/链表的对比要点</h4>
<ul>
<li>位示图 : 定位效率高, 常驻内存; 获取连续空间需扫描连续 0 段.</li>
<li>盘块/盘区链 : 结构简单, 随机/连续定位效率较低, 易碎片化.</li>
<li>成组链接 : 通过组装载降低 I/O,
适合大规模分配/回收的稳定性能需求.</li>
</ul>
<h5 id="顺序文件-sequential-file">1. 顺序文件 ( Sequential File )</h5>
<ul>
<li><strong>定义</strong> : 记录按某种顺序排列.</li>
<li><strong>分类</strong> :
<ul>
<li><strong>串结构</strong> : 记录顺序与关键字无关 ( 通常按时间 ).
查找需 <span class="math inline">\(O(n)\)</span>.</li>
<li><strong>顺序结构</strong> : 记录按关键字顺序排列.
<strong>定长记录</strong> 可实现 <strong>随机访问</strong> ( 下标计算 );
<strong>变长记录</strong> 只能顺序查找.</li>
</ul></li>
<li><strong>优点</strong> : 批量存取效率高 ( 磁带机 ).</li>
<li><strong>缺点</strong> : 增删记录困难 ( 需移动大量记录 ).</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef record fill:#FFFFFF,stroke:#334155,stroke-width:2px,rx:5,ry:5,color:#0F172A,font-weight:bold;
    classDef container fill:#EFF6FF,stroke:#60A5FA,stroke-width:2px,stroke-dasharray: 5 5,color:#1E3A8A,rx:10,ry:10;
    classDef plain fill:none,stroke:none,color:#64748b,font-weight:bold,font-size:18px;

    subgraph SF[&quot;顺序文件 ( 逻辑上连续 )&quot;]
        direction LR
        R0[&quot;记录 0&quot;]:::record --- R1[&quot;记录 1&quot;]:::record --- R2[&quot;记录 2&quot;]:::record --- R3[&quot;...&quot;]:::plain
    end
    
    class SF container
  </pre></div>
<h5 id="索引文件-indexed-file">2. 索引文件 ( Indexed File )</h5>
<ul>
<li><strong>定义</strong> : 为变长记录文件建立一张
<strong>索引表</strong>，记录指向记录的指针 ( 逻辑地址 ).</li>
<li><strong>结构</strong> : 索引表本身是 <strong>定长记录</strong>
的顺序文件.</li>
<li><strong>优点</strong> : 支持 <strong>随机访问</strong> (
即使记录变长 ); 易于增删.</li>
<li><strong>缺点</strong> : 索引表占用额外的存储空间.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef index fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef record fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    subgraph IndexTable[&quot;索引表 ( 定长 )&quot;]
        direction TB
        I0[&quot;索引项 0 ( key:0 )&quot;]:::index
        I1[&quot;索引项 1 ( key:1 )&quot;]:::index
        I2[&quot;索引项 2 ( key:2 )&quot;]:::index
    end
    
    subgraph Records[&quot;逻辑记录 ( 可变长 )&quot;]
        direction TB
        R0[&quot;记录 0&quot;]:::record
        R1[&quot;记录 1 ( Long )&quot;]:::record
        R2[&quot;记录 2&quot;]:::record
    end

    I0 --&gt;|&quot;指针&quot;| R0
    I1 --&gt;|&quot;指针&quot;| R1
    I2 --&gt;|&quot;指针&quot;| R2

    class IndexTable,Records container
  </pre></div>
<h5 id="索引顺序文件-indexed-sequential-file">3. 索引顺序文件 ( Indexed
Sequential File )</h5>
<ul>
<li><strong>定义</strong> : 将顺序文件中的记录
<strong>分组</strong>，为每组建立一个索引项. ( 类似多级页表 / 字典目录
).</li>
<li><strong>特点</strong> : 是顺序文件和索引文件的结合.</li>
<li><strong>优势</strong> : 既支持随机访问,
又减少了索引表的占用空间.</li>
<li><strong>效率</strong> : 若 <span class="math inline">\(N\)</span>
条记录, 分 <span class="math inline">\(\sqrt{N}\)</span> 组, 每组 <span
class="math inline">\(\sqrt{N}\)</span> 条. 平均查找次数由 <span
class="math inline">\(N/2\)</span> 降为 <span
class="math inline">\(\sqrt{N}\)</span>.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef index fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef record fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;
    classDef plain fill:none,stroke:none,color:#64748b,font-weight:bold;

    subgraph GroupIndex[&quot;组索引表&quot;]
        direction TB
        G0[&quot;组 0 ( Key &lt; 10 )&quot;]:::index
        G1[&quot;组 1 ( Key &lt; 20 )&quot;]:::index
        G2[&quot;...&quot;]:::plain
    end

    subgraph Group0[&quot;组 0 ( 顺序 )&quot;]
        direction TB
        R00[&quot;记录 0 ( K&#x3D;0 )&quot;]:::record --- R01[&quot;记录 1 ( K&#x3D;5 )&quot;]:::record --- R02[&quot;...&quot;]:::plain
    end

    subgraph Group1[&quot;组 1 ( 顺序 )&quot;]
        direction TB
        R10[&quot;记录 10 ( K&#x3D;11 )&quot;]:::record --- R11[&quot;记录 11 ( K&#x3D;15 )&quot;]:::record --- R12[&quot;...&quot;]:::plain
    end

    G0 --&gt;|&quot;指向&quot;| Group0
    G1 --&gt;|&quot;指向&quot;| Group1
    
    class GroupIndex,Group0,Group1 container
  </pre></div>
<h5 id="直接文件-direct-file-散列文件-hash-file">4. 直接文件 ( Direct
File ) / 散列文件 ( Hash File )</h5>
<ul>
<li><strong>定义</strong> :
给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址.</li>
<li><strong>特点</strong> : 没有顺序的特性.</li>
<li><strong>优点</strong> : 存取速度很高 ( <span
class="math inline">\(O(1)\)</span> ).</li>
<li><strong>缺点</strong> : 会产生冲突 ( 不同关键字映射到同一地址 ),
需要处理冲突.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef key fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef func fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef addr fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef record fill:#F3E8FF,stroke:#9333EA,stroke-width:2px,color:#6B21A8,rx:5,ry:5,font-weight:bold;

    Input(&quot;关键字 ( Key )&quot;):::key --&gt; Hash{&quot;Hash 函数&quot;}:::func
    Hash --&gt;|&quot;计算地址&quot;| Addr(&quot;物理地址&quot;):::addr
    Addr --&gt; Record(&quot;访问记录&quot;):::record
  </pre></div>
<h3 id="文件的物理结构">4.1.5 文件的物理结构</h3>
<p>指文件数据在物理存储设备上是如何分布的 ( 文件分配方式 ).</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef root fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef type fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef subtype fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    Alloc[&quot;文件分配方式&quot;]:::root
    
    subgraph Methods[&quot;分配策略&quot;]
        direction TB
        Cont[&quot;连续分配&quot;]:::type
        Link[&quot;链接分配&quot;]:::type
        Index[&quot;索引分配&quot;]:::type
    end

    Alloc --&gt; Cont
    Alloc --&gt; Link
    Alloc --&gt; Index
    
    Link -.-&gt; Implicit[&quot;隐式链接&quot;]:::subtype
    Link -.-&gt; Explicit[&quot;显式链接 (FAT)&quot;]:::subtype
    
    Index -.-&gt; Single[&quot;单级索引&quot;]:::subtype
    Index -.-&gt; Multi[&quot;多级索引&quot;]:::subtype
    Index -.-&gt; Hybrid[&quot;混合索引 (UNIX)&quot;]:::subtype
    
    class Methods container
  </pre></div>
<h4 id="连续分配-continuous-allocation">1. 连续分配 ( Continuous
Allocation )</h4>
<ul>
<li><strong>定义</strong> : 每个文件在磁盘上占有一组
<strong>连续</strong> 的块.</li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef fcb fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef data fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef empty fill:#F8FAFC,stroke:#CBD5E1,stroke-width:2px,color:#94A3B8,rx:5,ry:5;
    classDef container fill:#F1F5F9,stroke:#94A3B8,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    FCB[&quot;FCB ( Start:1, Len:3 )&quot;]:::fcb --&gt; B1
    
    subgraph Disk[&quot;磁盘块&quot;]
        direction LR
        B0[&quot;0&quot;]:::empty --- B1[&quot;1: 数据&quot;]:::data --- B2[&quot;2: 数据&quot;]:::data --- B3[&quot;3: 数据&quot;]:::data --- B4[&quot;4&quot;]:::empty
    end
    
    class Disk container
  </pre></div></li>
<li><strong>优点</strong> :
<ul>
<li><strong>速度快</strong> : 支持顺序访问和直接访问 ( 随机访问 ).
顺序读写速度 <strong>最快</strong> ( 磁头移动少 ).</li>
</ul></li>
<li><strong>磁盘 I/O 次数</strong> :
<ul>
<li><strong>访问第 <span class="math inline">\(i\)</span> 块</strong> :
仅需 <strong>1 次</strong> I/O. ( FCB 中记录了 <code>Start</code>,
物理地址 <span class="math inline">\(= \text{Start} + i\)</span>,
直接定位读取 ).</li>
<li><strong>插入 (Insert at <span
class="math inline">\(i\)</span>)</strong> : 需将 <span
class="math inline">\(i\)</span> 之后的 <span
class="math inline">\(N-i\)</span> 个块依次后移. 总 I/O <span
class="math inline">\(\approx 2 \times (N-i) + 1\)</span>. ( 读旧+写新
).</li>
<li><strong>删除 (Delete at <span
class="math inline">\(i\)</span>)</strong> : 需将 <span
class="math inline">\(i\)</span> 之后的 <span
class="math inline">\(N-i\)</span> 个块依次前移. 总 I/O <span
class="math inline">\(\approx 2 \times (N-i)\)</span>.</li>
<li><strong>修改 (Modify <span
class="math inline">\(i\)</span>)</strong> : 定位后, 1 次读 + 1 次写 (
覆盖 ). 总 I/O = 2.</li>
</ul></li>
<li><strong>文件最大长度</strong> :
<ul>
<li>受 <strong>FCB 中文件长度字段位数</strong> 或
<strong>磁盘总容量</strong> 限制.</li>
<li>( 例如: 若长度字段为 32 位, 单位为字节, 则最大文件为 4GB ).</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>碎片</strong> : 产生 <strong>外部碎片</strong> (
类似动态分区分配 ).</li>
<li><strong>扩展难</strong> : 文件长度扩展时, 若后方无空闲块,
需整体迁移.</li>
</ul></li>
</ul>
<h4 id="链接分配-linked-allocation">2. 链接分配 ( Linked Allocation
)</h4>
<p>采用 <strong>离散分配</strong>, 消除外部碎片.</p>
<ul>
<li><strong>隐式链接 ( Implicit Linking )</strong> :
<ul>
<li><strong>定义</strong> : 目录项指向第一块和最后一块,
每个磁盘块中隐含指向下一块的指针.</li>
<li><strong>优点</strong> : 无外部碎片, 方便扩展.</li>
<li><strong>缺点</strong> : <strong>只支持顺序访问</strong> ( 必须从头读
); 可靠性差 ( 指针丢失导致文件断裂 ).</li>
<li><strong>磁盘 I/O 次数</strong> :
<ul>
<li><strong>访问第 <span class="math inline">\(i\)</span> 块</strong> :
需 <strong><span class="math inline">\(i+1\)</span> 次</strong> I/O. (
必须读取前 <span class="math inline">\(i\)</span> 个块才能获得第 <span
class="math inline">\(i\)</span> 块的物理指针 ).</li>
<li><strong>插入 ( Insert after <span class="math inline">\(i\)</span>
)</strong> : 需读 <span class="math inline">\(0 \sim i\)</span> 块 (
<span class="math inline">\(i+1\)</span> 次 ). 修改 block <span
class="math inline">\(i\)</span> 指针 ( 1 写 ) + 写入新块 ( 1 写 ). 总
I/O <span class="math inline">\(= i + 3\)</span>.</li>
<li><strong>删除 ( Delete after <span class="math inline">\(i\)</span>
)</strong> : 需读 <span class="math inline">\(0 \sim i\)</span> 块 (
<span class="math inline">\(i+1\)</span> 次 ). 修改 block <span
class="math inline">\(i\)</span> 指针 ( 1 写 ). 总 I/O <span
class="math inline">\(= i + 2\)</span>.</li>
<li><strong>修改 ( Modify <span class="math inline">\(i\)</span>
)</strong> : 读 <span class="math inline">\(0 \sim i\)</span> 块 ( <span
class="math inline">\(i+1\)</span> 次 ) + 1 次写. 总 I/O <span
class="math inline">\(= i + 2\)</span>.</li>
</ul></li>
<li><strong>文件最大长度</strong> :
<ul>
<li>理论上受 <strong>磁盘总容量</strong> 限制. ( 只要有空闲块即可链接
).</li>
<li>( 实际上受 FCB/Inode 中文件大小字段位数限制 ).</li>
</ul></li>
</ul></li>
<li><strong>显式链接 ( Explicit Linking ) - FAT</strong> :
<ul>
<li><strong>定义</strong> : 将链接指针集中存放在内存的一张表中 (
<strong>文件分配表 FAT</strong> ).</li>
<li><strong>特点</strong> :
<ul>
<li>一个磁盘仅设置 <strong>一张</strong> FAT 表.</li>
<li>FAT 表项与磁盘块 <strong>一一对应</strong>. ( 物理块号 <span
class="math inline">\(\leftrightarrow\)</span> FAT 索引 ).</li>
<li>FAT 表项内容 : 下一块物理块号. ( <code>-1</code>/<code>EOF</code>
表示文件结束 ).</li>
<li><strong>开机</strong> 时, FAT 表被读入 <strong>内存</strong>.</li>
</ul></li>
<li><strong>访问机制</strong> :
<ul>
<li><strong>逻辑块号 <span class="math inline">\(i\)</span> <span
class="math inline">\(\to\)</span> 物理块号</strong> : 不需要读磁盘,
直接在内存查询 FAT 链表 <span class="math inline">\(i\)</span> 次.</li>
<li>虽是链式查找, 但完全在内存进行, 速度很快, 故称
<strong>支持随机访问</strong>.</li>
</ul></li>
<li><strong>磁盘 I/O 次数</strong> :
<ul>
<li><strong>访问第 <span class="math inline">\(i\)</span> 块</strong> :
仅需 <strong>1 次</strong> 磁盘 I/O. ( 查 FAT 表在内存进行,
找到物理块号后, 直接读盘 ).</li>
<li><strong>插入</strong> : 查内存 FAT 找空闲块, 修改内存 FAT 链表 ( 0
I/O ). 仅需写入新数据块 ( 1 I/O ). ( FAT 表周期性回写 ).</li>
<li><strong>删除</strong> : 修改内存 FAT 表项为 Free ( 0 I/O ).</li>
<li><strong>修改</strong> : 定位后, 1 次读 + 1 次写. 总 I/O = 2.</li>
</ul></li>
<li><strong>计算示例</strong> :
<ul>
<li>若硬盘 1TB, 块大小 4KB. 总块数 <span class="math inline">\(= 2^{40}
/ 2^{12} = 2^{28}\)</span>.</li>
<li>FAT 表项需 28 位 ( 取 32 位 = 4B ).</li>
<li>FAT 表大小 <span class="math inline">\(= 2^{28} \times 4B =
1GB\)</span>. ( <strong>占用内存过大</strong> ).</li>
</ul></li>
<li><strong>文件最大长度</strong> :
<ul>
<li>受 <strong>FAT 表项位数</strong> ( 决定最大簇数 ) 和
<strong>簇大小</strong> 限制.</li>
<li><strong>公式</strong> : <span
class="math inline">\(\text{MaxFileSize} = 2^K \times
\text{ClusterSize}\)</span>. ( <span class="math inline">\(K\)</span> 为
FAT 位数, 如 FAT32, <span class="math inline">\(K \approx 28 \sim
32\)</span> ).</li>
<li>( 例如: FAT32, 簇大小 4KB, 理论上限 <span
class="math inline">\(2^{32} \times 4KB = 16TB\)</span>. <em>注: 实际
FAT32 实现通常限制单文件 4GB</em> ).</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef fcb fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef fat fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef disk fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    FCB[&quot;FCB ( Start:2 )&quot;]:::fcb --&gt; FAT2
    
    subgraph FAT[&quot;文件分配表 ( FAT )&quot;]
        direction TB
        FAT0[&quot;0: Free&quot;]:::fat
        FAT1[&quot;1: 5 (next)&quot;]:::fat
        FAT2[&quot;2: 1 (next)&quot;]:::fat
        FAT5[&quot;5: EOF (end)&quot;]:::fat
        FAT6[&quot;...&quot;]:::fat
    end

    subgraph Disk[&quot;磁盘数据块&quot;]
        direction TB
        B2[&quot;块 2&quot;]:::disk -.-&gt; B1[&quot;块 1&quot;]:::disk -.-&gt; B5[&quot;块 5&quot;]:::disk
    end

    FAT2 -.-&gt; B2
    
    class FAT,Disk container
  </pre></div></li>
<li><strong>优点</strong> : 支持 <strong>随机访问</strong> ( 查内存 FAT
表即可 ); 无外部碎片; 方便文件扩展.</li>
<li><strong>缺点</strong> : FAT 表占用较大的
<strong>内存空间</strong>.</li>
</ul></li>
</ul>
<h4 id="索引分配-indexed-allocation">3. 索引分配 ( Indexed Allocation
)</h4>
<ul>
<li><p><strong>定义</strong> : 系统为每个文件建立一张 <strong>索引表 (
Index Table )</strong>, 记录逻辑块号到物理块号的映射.
索引表存放的磁盘块称为 <strong>索引块</strong>.</p></li>
<li><p><strong>特点</strong> :</p>
<ul>
<li>索引表可以直接映射 ( <span class="math inline">\(i \to
\text{Physical Block}\)</span> ), 支持 <strong>随机访问</strong>.</li>
<li>索引块通常存在 <strong>磁盘</strong> 上 ( 访问文件需先读索引块
).</li>
</ul></li>
<li><p><strong>磁盘 I/O 次数 ( 单级索引 )</strong> :</p>
<ul>
<li><strong>访问第 <span class="math inline">\(i\)</span> 块</strong> :
需 <strong>2 次</strong> I/O ( 1次读索引块 + 1次读数据块 ). (
若索引块已调入内存, 则只需 1 次 ).</li>
<li><strong>插入</strong> : 读索引块 ( 1 I/O ) + 修改内存索引 +
写回索引块 ( 1 I/O ) + 写新数据块 ( 1 I/O ). 总 I/O <span
class="math inline">\(= 3\)</span>.</li>
<li><strong>删除</strong> : 读索引块 ( 1 I/O ) + 修改内存索引 +
写回索引块 ( 1 I/O ). 总 I/O <span class="math inline">\(=
2\)</span>.</li>
<li><strong>修改</strong> : 读索引块 ( 1 I/O ) + 读数据 ( 1 I/O ) +
写数据 ( 1 I/O ). 总 I/O <span class="math inline">\(= 3\)</span>.</li>
</ul></li>
<li><p><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef fcb fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef index fill:#F3E8FF,stroke:#9333EA,stroke-width:2px,color:#6B21A8,rx:5,ry:5,font-weight:bold;
    classDef disk fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    FCB[&quot;FCB ( IndexBlock: 8 )&quot;]:::fcb --&gt; IB
    
    subgraph Disk[&quot;磁盘&quot;]
        direction TB
        IB[&quot;块 8 ( 索引块 )&quot;]:::index
        B1[&quot;块 2&quot;]:::disk
        B2[&quot;块 5&quot;]:::disk
        B3[&quot;块 12&quot;]:::disk
    end
    
    IB --&quot;0&quot;--&gt; B1
    IB --&quot;1&quot;--&gt; B2
    IB --&quot;2&quot;--&gt; B3
    
    class Disk container
  </pre></div></p></li>
<li><p><strong>解决索引块不够用的方案</strong> :</p>
<ol type="1">
<li><strong>链接索引 ( Linked Indexing )</strong> :
<ul>
<li>将多个索引块链接起来.</li>
<li><strong>缺点</strong> : 若文件很大, 需顺序查找索引块,
无法直接定位.</li>
</ul></li>
<li><strong>多级索引 ( Multi-Level Indexing )</strong> :
<ul>
<li>建立索引的索引 ( 类似多级页表 ).</li>
<li><strong>二级索引</strong> : 顶级索引块 <span
class="math inline">\(\to\)</span> 二级索引块 <span
class="math inline">\(\to\)</span> 数据块.</li>
<li><strong>访问次数</strong> : <span class="math inline">\(K\)</span>
级索引需 <span class="math inline">\(K+1\)</span> 次磁盘 I/O (
假设索引未缓存 ).</li>
<li><strong>容量计算</strong> : 若块大小 4KB, 指针 4B. 一个块存 <span
class="math inline">\(1024\)</span> 个指针.
<ul>
<li>二级索引最大文件 : <span class="math inline">\(1024 \times 1024
\times 4KB = 4GB\)</span>.</li>
</ul></li>
</ul></li>
<li><strong>混合索引 ( Hybrid Indexing ) - UNIX/Linux 常用</strong> :
<ul>
<li><strong>结构</strong> : Inode 中包含 <strong>直接地址指针</strong> +
<strong>一级间接</strong> + <strong>二级间接</strong> +
<strong>三级间接</strong>.</li>
<li><strong>优势</strong> : 兼顾了小文件 ( 绝大多数 )
的访问速度和大文件的容量.</li>
<li><strong>举例 ( 假设 10个直接, 1个一级, 1个二级, 1个三级 )</strong> :
<ul>
<li><strong>小文件</strong> ( <span class="math inline">\(\le
10\)</span> 块 ) : 直接访问, 0 次额外 I/O.</li>
<li><strong>中文件</strong> : 用一级间接.</li>
<li><strong>大文件</strong> : 用二/三级间接.</li>
</ul></li>
<li><strong>文件最大长度</strong> :
<ul>
<li><strong>公式</strong> : <span class="math inline">\(\text{Max} =
(N_{direct} + N_1 \times M + N_2 \times M^2 + N_3 \times M^3) \times
\text{BlockSize}\)</span>.</li>
<li>( 其中 <span class="math inline">\(M =
\text{BlockSize}/\text{PtrSize}\)</span>, <span
class="math inline">\(N\)</span> 为各级指针数量 ).</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef inode fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef ptr fill:#F1F5F9,stroke:#64748B,stroke-width:1px,color:#334155,rx:5,ry:5;
    classDef index fill:#F3E8FF,stroke:#9333EA,stroke-width:2px,color:#6B21A8,rx:5,ry:5,font-weight:bold;
    classDef data fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    subgraph InodeStruct[&quot;索引节点 ( Inode )&quot;]
        direction TB
        D0[&quot;直接指针 0&quot;]:::ptr
        D1[&quot;...&quot;]:::ptr
        D9[&quot;直接指针 9&quot;]:::ptr
        S1[&quot;一级间接指针&quot;]:::ptr
        S2[&quot;二级间接指针&quot;]:::ptr
        S3[&quot;三级间接指针&quot;]:::ptr
    end

    subgraph Level1[&quot;一级索引&quot;]
        I1[&quot;索引块&quot;]:::index
    end
    
    subgraph Level2[&quot;二级索引&quot;]
        direction LR
        I2A[&quot;一级索引块&quot;]:::index --&gt; I2B[&quot;二级索引块&quot;]:::index
    end

    D0 --&gt; Data0[&quot;数据块&quot;]:::data
    S1 --&gt; I1
    I1 --&gt; Data1[&quot;数据块&quot;]:::data
    
    S2 --&gt; I2A
    I2B --&gt; Data2[&quot;数据块&quot;]:::data

    class InodeStruct,Level1,Level2 container
  </pre></div></li>
</ol></li>
<li><p><strong>优点</strong> : 支持 <strong>随机访问</strong>;
易于文件扩展 ( 只需分配新块并更新索引 ).</p></li>
<li><p><strong>缺点</strong> : 索引表需占用额外的存储空间 (
对极小文件而言开销比例大 ).</p></li>
</ul>
<p><strong>总结对比</strong> :</p>
<table>
<thead>
<tr>
<th style="text-align: left;">分配方式</th>
<th style="text-align: left;">访问支持</th>
<th style="text-align: left;">无外部碎片</th>
<th style="text-align: left;">扩展性</th>
<th style="text-align: left;">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>连续分配</strong></td>
<td style="text-align: left;">顺序+随机 (最快)</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">差</td>
<td style="text-align: left;">外部碎片, 扩展需移动</td>
</tr>
<tr>
<td style="text-align: left;"><strong>隐式链接</strong></td>
<td style="text-align: left;">仅顺序</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">好</td>
<td style="text-align: left;">无法随机访问, 可靠性低</td>
</tr>
<tr>
<td style="text-align: left;"><strong>显式链接 ( FAT )</strong></td>
<td style="text-align: left;">顺序+随机</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">好</td>
<td style="text-align: left;">FAT 占内存</td>
</tr>
<tr>
<td style="text-align: left;"><strong>索引分配</strong></td>
<td style="text-align: left;">顺序+随机</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">好</td>
<td style="text-align: left;">索引块占磁盘</td>
</tr>
</tbody>
</table>
<h3 id="文件保护">4.1.6 文件保护</h3>
<p>为了防止文件被物理损坏 ( 备份机制 ) 和逻辑损坏 ( 访问控制 ).
本节主要讨论 <strong>逻辑上的访问控制</strong>.</p>
<h4 id="口令保护-password-protection">1. 口令保护 ( Password Protection
)</h4>
<ul>
<li><strong>机制</strong> : 用户在建立文件时设置一个口令,
系统将口令附在文件的 FCB / Inode 中.</li>
<li><strong>访问</strong> : 用户请求访问时需提供口令,
验证通过后方可访问.</li>
<li><strong>优点</strong> :
<ul>
<li><strong>开销小</strong> : 验证速度快.</li>
<li><strong>存储少</strong> : 仅需存储一个口令字段.</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>安全性差</strong> : 口令直接存于系统内部 ( FCB ),
若系统管理员或黑客读取了 FCB, 口令即泄露. ( 改进: 存储口令的哈希值
).</li>
<li><strong>不够灵活</strong> : 只要知道口令,
任何用户都能拥有完全权限.</li>
</ul></li>
</ul>
<h4 id="加密保护-cryptography-protection">2. 加密保护 ( Cryptography
Protection )</h4>
<ul>
<li><strong>机制</strong> : 使用 <strong>密码算法</strong> ( 如 DES, AES
) 对文件内容进行加密.</li>
<li><strong>访问</strong> : 只有持有正确 <strong>密钥</strong>
的用户才能将文件解密并读取.</li>
<li><strong>优点</strong> :
<ul>
<li><strong>保密性极强</strong> : 即使文件被拷贝或物理窃取,
没有密钥也无法获取内容.</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>效率低</strong> : 加密/解密需要消耗大量的 CPU 时间.</li>
</ul></li>
</ul>
<h4 id="访问控制-access-control">3. 访问控制 ( Access Control )</h4>
<p>最常用的保护机制. 定义 <strong>谁 ( Subject )</strong> 对
<strong>什么 ( Object )</strong> 可以进行 <strong>何种操作 ( Access
Right )</strong>.</p>
<ul>
<li><strong>访问控制矩阵 ( Access Control Matrix )</strong> :
<ul>
<li>二维矩阵. <strong>行</strong> 代表用户 ( 进程 ), <strong>列</strong>
代表文件. 矩阵项 <span class="math inline">\(A[i, j]\)</span> 表示用户
<span class="math inline">\(i\)</span> 对文件 <span
class="math inline">\(j\)</span> 的权限.</li>
<li><strong>缺点</strong> : 矩阵非常稀疏, 浪费存储空间.</li>
</ul></li>
<li><strong>实现方式 1 : 访问控制列表 ( ACL - Access Control List
)</strong> :
<ul>
<li><strong>基于列 ( 文件 )</strong> 的划分.</li>
<li><strong>机制</strong> : 为每个文件设置一张表, 记录
<strong>哪些用户</strong> 对该文件有什么权限.</li>
<li><strong>示例</strong> :
<code>File1: (UserA, RW), (UserB, R)</code>.</li>
<li><strong>优点</strong> : 方便查看某个文件的权限情况.</li>
</ul></li>
<li><strong>实现方式 2 : 用户权限表 ( Capability List )</strong> :
<ul>
<li><strong>基于行 ( 用户 )</strong> 的划分.</li>
<li><strong>机制</strong> : 为每个用户设置一张表, 记录该用户对
<strong>哪些文件</strong> 有什么权限.</li>
<li><strong>示例</strong> :
<code>UserA: (File1, RW), (File2, R)</code>.</li>
<li><strong>优点</strong> : 方便查看某个用户的权限集合.</li>
</ul></li>
<li><strong>实现方式 3 : 精简的访问列表 ( UNIX/Linux 模式 )</strong> :
<ul>
<li>将用户分为三类, 并用 <strong>9个二进制位</strong> 记录权限.</li>
<li><strong>用户分类</strong> :
<ul>
<li><strong>拥有者 ( Owner )</strong> : 创建文件的用户.</li>
<li><strong>同组用户 ( Group )</strong> : 与拥有者在同一组的用户.</li>
<li><strong>其他用户 ( Other )</strong> : 系统内的其他用户.</li>
</ul></li>
<li><strong>权限位</strong> : <strong>r ( 读 )</strong>, <strong>w ( 写
)</strong>, <strong>x ( 执行 )</strong>.</li>
<li><strong>示例</strong> : <code>-rwxr-xr--</code> ( 754 ) <span
class="math inline">\(\to\)</span> Owner( RWX ), Group( R-X ), Other( R–
).</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef item fill:#F1F5F9,stroke:#64748B,stroke-width:1px,color:#334155,rx:5,ry:5;
    classDef acl fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef cl fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef unix fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    subgraph Matrix[&quot;访问控制矩阵 ( ACM )&quot;]
        direction TB
        M_Row[&quot;行 : 用户 &#x2F; 进程&quot;]:::item
        M_Col[&quot;列 : 文件 &#x2F; 对象&quot;]:::item
        M_Cell[&quot;值 : 访问权限&quot;]:::item
    end

    subgraph Impl[&quot;实现方式&quot;]
        direction TB
        ACL[&quot;ACL ( 基于文件 )&lt;br&#x2F;&gt;File1: (UserA, R)&quot;]:::acl
        CL[&quot;Capability List ( 基于用户 )&lt;br&#x2F;&gt;UserA: (File1, R)&quot;]:::cl
        UNIX[&quot;UNIX 模式 ( 精简 )&lt;br&#x2F;&gt;Owner &#x2F; Group &#x2F; Other&quot;]:::unix
    end

    Matrix --&gt;|&quot;按列拆分&quot;| ACL
    Matrix --&gt;|&quot;按行拆分&quot;| CL
    Matrix -.-&gt;|&quot;简化&quot;| UNIX
    
    class Matrix,Impl container
  </pre></div>
<h2 id="目录">4.2 目录</h2>
<h3 id="目录的基本概念">4.2.1 目录的基本概念</h3>
<h4 id="目录的定义">1. 目录的定义</h4>
<ul>
<li><strong>目录 ( Directory )</strong> : 是一种特殊的
<strong>文件</strong> ( 目录文件 ).</li>
<li><strong>内容</strong> : 由若干 <strong>目录项 ( Directory Entry
)</strong> 组成.</li>
<li><strong>目录项</strong> :
<ul>
<li><strong>FCB</strong> : 在传统文件系统中, 目录项就是 FCB.</li>
<li><strong>文件名 + Inode 号</strong> : 在现代文件系统 ( 如 UNIX ) 中,
目录项仅包含文件名和索引节点号.</li>
</ul></li>
</ul>
<h4 id="目录管理的要求-目标">2. 目录管理的要求 ( 目标 )</h4>
<ol type="1">
<li><strong>实现”按名存取”</strong> : 用户只需提供文件名,
系统即可找到对应文件. ( 最基本功能 ).</li>
<li><strong>提高检索速度</strong> : 合理组织目录结构 ( 如 树形结构, Hash
), 减少磁盘 I/O 次数.</li>
<li><strong>提供访问控制</strong> : 目录也需要保护,
不同用户对不同目录有不同的权限.</li>
<li><strong>允许文件重名</strong> : 允许不同用户 ( 或不同目录下 )
使用相同的文件名.</li>
<li><strong>实现文件共享</strong> : 允许多个用户共享同一个文件.</li>
</ol>
<h3 id="目录的操作">4.2.2 目录的操作</h3>
<ol type="1">
<li><strong>搜索 ( Search )</strong> : 当用户使用一个文件时,
需要根据文件名搜索目录, 找到该文件对应的目录项.</li>
<li><strong>创建文件 ( Create File )</strong> : 当创建一个新文件时,
需要在目录中增加一个目录项.</li>
<li><strong>删除文件 ( Delete File )</strong> : 当删除一个文件时,
需要在目录中删除相应的目录项.</li>
<li><strong>创建目录 ( Create Directory )</strong> :
在当前目录中创建一个新的空目录. ( 如 <code>mkdir</code> ).</li>
<li><strong>删除目录 ( Delete Directory )</strong> :
删除一个已存在的目录. ( 如 <code>rmdir</code> ). 若目录不为空,
可能需要递归删除.</li>
<li><strong>显示目录 ( Show / List Directory )</strong> :
列出目录中的所有文件项和子目录. ( 如 <code>ls</code>, <code>dir</code>
).</li>
<li><strong>修改目录 ( Modify Directory )</strong> : 修改目录的属性 (
如文件名, 访问权限等 ). ( 重命名通常看作是修改的一种 ).</li>
<li><strong>移动目录 ( Move Directory )</strong> : 将目录 ( 及其内容 )
从一个位置移动到另一个位置. ( 如 <code>mv</code> ).</li>
<li><strong>改变当前目录 ( Change Directory )</strong> :
改变进程的当前工作目录. ( 如 <code>cd</code> ).</li>
<li><strong>遍历文件系统 ( Traverse )</strong> : 从根目录出发,
访问文件系统中的每一个目录和文件. ( 常用于文件备份 ).</li>
</ol>
<h3 id="目录结构">4.2.3 目录结构</h3>
<p>目录结构的组织方式直接影响文件存取的效率和文件共享的灵活性.</p>
<h4 id="单级目录结构-single-level-directory">1. 单级目录结构 (
Single-Level Directory )</h4>
<ul>
<li><strong>定义</strong> : 整个文件系统只建立 <strong>一张</strong>
目录表, 每个文件占一个目录项.</li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef root fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef file fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;

    Root[根目录]:::root --&gt; F1[文件 A]:::file
    Root --&gt; F2[文件 B]:::file
    Root --&gt; F3[文件 C]:::file
  </pre></div></li>
<li><strong>特点</strong> :
<ul>
<li><strong>线性结构</strong> : 所有文件都在同一层级.</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>命名冲突</strong> : 不同用户不能使用相同文件名.</li>
<li><strong>限制多</strong> : 文件多时查找速度慢; 不便于文件分类.</li>
</ul></li>
</ul>
<h4 id="两级目录结构-two-level-directory">2. 两级目录结构 ( Two-Level
Directory )</h4>
<ul>
<li><strong>定义</strong> : 将目录分为 <strong>主文件目录 ( MFD
)</strong> 和 <strong>用户文件目录 ( UFD )</strong>.</li>
<li><strong>结构</strong> :
<ul>
<li><strong>MFD ( Master File Directory )</strong> :
记录用户名及指向该用户 UFD 的指针.</li>
<li><strong>UFD ( User File Directory )</strong> : 记录该用户所有文件的
FCB.</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef root fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef user fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef file fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    MFD[主文件目录 MFD]:::root --&gt; U1[用户 A]:::user
    MFD --&gt; U2[用户 B]:::user
    
    subgraph UFD_A[用户目录 A]
        direction TB
        U1 --&gt; F1[文件 A1]:::file
        U1 --&gt; F2[文件 A2]:::file
    end
    
    subgraph UFD_B[用户目录 B]
        direction TB
        U2 --&gt; F3[文件 B1]:::file
    end
    
    class UFD_A,UFD_B container
  </pre></div></li>
<li><strong>优点</strong> :
<ul>
<li><strong>解决重名</strong> : 不同用户可使用相同文件名 ( 隔离 ).</li>
<li><strong>访问控制</strong> : 易于实现访问限制.</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>缺乏灵活</strong> : 用户不能对自己文件再分类 ( 无子目录
).</li>
</ul></li>
</ul>
<h4 id="多级目录结构-树形目录-tree-structured-directory">3. 多级目录结构
( 树形目录 / Tree-Structured Directory )</h4>
<ul>
<li><strong>定义</strong> : 允许目录中包含子目录, 形成树状结构. ( 现代
OS 通用 ).</li>
<li><strong>路径 ( Path )</strong> :
<ul>
<li><strong>绝对路径</strong> : 从 <strong>根目录 ( / )</strong> 出发. (
如 <code>/usr/bin/gcc</code> ).</li>
<li><strong>相对路径</strong> : 从 <strong>当前目录 ( . )</strong> 出发.
( 如 <code>./gcc</code> ).</li>
<li><strong>当前目录 ( Current Directory )</strong> :
为每个进程设置一个”当前工作目录”, 减少路径检索长度.</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef root fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef dir fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef file fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;

    Root[Root &#x2F;]:::root --&gt; Home[home]:::dir
    Root --&gt; Bin[bin]:::dir
    
    Home --&gt; User1[User1]:::dir
    Home --&gt; User2[User2]:::dir
    
    User1 --&gt; Doc[Docs]:::dir
    User1 --&gt; Pic[Pics]:::dir
    
    Doc --&gt; F1[file.txt]:::file
  </pre></div></li>
<li><strong>优点</strong> : 层次清晰, 解决重名, 便于分类.</li>
<li><strong>缺点</strong> : 查找文件需逐级访问磁盘 ( I/O
次数随着层级增加 ).</li>
</ul>
<h4 id="无环图目录结构-acyclic-graph-directory">4. 无环图目录结构 (
Acyclic-Graph Directory )</h4>
<ul>
<li><strong>定义</strong> : 在树形结构基础上,
允许目录项指向已存在的文件/目录. ( 实现 <strong>文件共享</strong>
).</li>
<li><strong>特点</strong> : 允许一个文件有多个父目录.</li>
<li><strong>共享方式</strong> :
<ul>
<li><strong>硬链接</strong> : 多个目录项指向同一个 Inode.</li>
<li><strong>软链接 ( 符号链接 )</strong> : 创建新文件记录目标路径.</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef root fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
    classDef user fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef file fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
    classDef shared fill:#F3E8FF,stroke:#9333EA,stroke-width:2px,color:#6B21A8,rx:5,ry:5,font-weight:bold;

    Root[Root]:::root --&gt; U1[用户 A]:::user
    Root --&gt; U2[用户 B]:::user
    
    U1 --&gt; F1[Shared File]:::shared
    U2 --&gt; F1
  </pre></div></li>
<li><strong>删除问题</strong> :
<ul>
<li>需维护 <strong>引用计数</strong>. 只有当所有用户都删除引用 ( count=0
) 时, 才真正删除文件.</li>
</ul></li>
</ul>
<h4 id="通用图目录结构-general-graph-directory">5. 通用图目录结构 (
General Graph Directory )</h4>
<ul>
<li><strong>定义</strong> : 允许图中出现 <strong>环路</strong>.</li>
<li><strong>问题</strong> : 搜索时可能产生无限循环;
删除时引用计数可能无法归零 ( 孤岛 ).</li>
<li><strong>解决</strong> : 需垃圾回收机制 ( Garbage Collection ),
开销大. 一般 OS 不采用.</li>
</ul>
<h4 id="目录结构检索效率对比">6. 目录结构检索效率对比</h4>
<p>不同目录结构在查找文件时的磁盘 I/O 开销对比. ( 假设目录已在磁盘,
需逐级读取 ).</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">目录结构</th>
<th style="text-align: left;">检索路径</th>
<th style="text-align: left;">命名冲突</th>
<th style="text-align: left;">共享支持</th>
<th style="text-align: left;">检索效率 ( 磁盘 I/O )</th>
<th style="text-align: left;">平均检索 I/O 公式 ( N=文件总数 )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>单级目录</strong></td>
<td style="text-align: left;">仅文件名</td>
<td style="text-align: left;"><strong>严重</strong> ( 全系统唯一 )</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;"><strong>慢</strong> ( 线性扫描整个目录表
)</td>
<td style="text-align: left;"><span
class="math inline">\(N/2\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>两级目录</strong></td>
<td style="text-align: left;">用户名 + 文件名</td>
<td style="text-align: left;"><strong>解决</strong> ( 用户间隔离 )</td>
<td style="text-align: left;">难</td>
<td style="text-align: left;"><strong>中</strong> ( 扫描 MFD <span
class="math inline">\(\to\)</span> 扫描 UFD )</td>
<td style="text-align: left;"><span class="math inline">\(N/2K\)</span>
( <span class="math inline">\(K\)</span>为用户数 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>树形目录</strong></td>
<td style="text-align: left;">逐级路径 ( /usr/bin/.. )</td>
<td style="text-align: left;"><strong>解决</strong> ( 层次化 )</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;"><strong>较慢</strong> ( 随树深度增加而增加
)</td>
<td style="text-align: left;"><span class="math inline">\(H \times
(\text{每级平均I/O})\)</span> ( <span
class="math inline">\(H\)</span>为树高 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>无环图目录</strong></td>
<td style="text-align: left;">逐级路径</td>
<td style="text-align: left;"><strong>解决</strong></td>
<td style="text-align: left;"><strong>支持</strong></td>
<td style="text-align: left;"><strong>较慢</strong> ( 同树形,
但增加了别名 )</td>
<td style="text-align: left;">同树形目录</td>
</tr>
<tr>
<td style="text-align: left;"><strong>哈希目录</strong></td>
<td style="text-align: left;">哈希值</td>
<td style="text-align: left;"><strong>解决</strong></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><strong>极快</strong> ( <span
class="math inline">\(O(1)\)</span> 直接定位 )</td>
<td style="text-align: left;"><span class="math inline">\(O(1)\)</span>
( 忽略冲突 )</td>
</tr>
</tbody>
</table>
<h3 id="目录实现">4.2.4 目录实现</h3>
<p>目录的实现方式主要有 <strong>线性列表</strong> 和
<strong>哈希表</strong> 两种, 决定了目录检索的效率.</p>
<h4 id="线性列表-linear-list">1. 线性列表 ( Linear List )</h4>
<ul>
<li><strong>定义</strong> : 将目录项 ( 文件名 + FCB/Inode号 )
按顺序排列, 形成一个线性表.</li>
<li><strong>实现</strong> : 可以使用数组或链表.</li>
<li><strong>操作</strong> :
<ul>
<li><strong>查找</strong> : 顺序遍历目录项, 匹配文件名.</li>
<li><strong>创建</strong> : 扫描列表检查重名 -&gt; 寻找空闲项 -&gt;
插入.</li>
<li><strong>删除</strong> : 扫描列表找到目标 -&gt; 释放 -&gt; ( 可选:
移动最后一种覆盖 或 标记为无效 ).</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef dir fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef entry fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
    classDef dots fill:none,stroke:none,color:#64748b,font-weight:bold;

    D1[Directory File]:::dir --&gt; E1[&quot;Entry 1&lt;br&#x2F;&gt;( file.txt, 102 )&quot;]:::entry
    E1 --&gt; E2[&quot;Entry 2&lt;br&#x2F;&gt;( pic.jpg, 205 )&quot;]:::entry
    E2 --&gt; E3[&quot;Entry 3&lt;br&#x2F;&gt;( prog.c, 301 )&quot;]:::entry
    E3 --&gt; E4[&quot;...&quot;]:::dots
  </pre></div></li>
<li><strong>优点</strong> :
<ul>
<li><strong>实现简单</strong> : 逻辑清晰, 易于编程.</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>检索慢</strong> : 线性查找时间复杂度为 <span
class="math inline">\(O(N)\)</span>. 当目录中文件很多时,
效率显著下降.</li>
</ul></li>
<li><strong>优化</strong> :
<ul>
<li><strong>排序</strong> : 将目录项按文件名排序, 可使用
<strong>二分查找</strong> ( <span class="math inline">\(O(\log
N)\)</span> ). 但插入/删除时维护顺序开销大.</li>
<li><strong>B+树</strong> : 现代文件系统 ( 如 NTFS, XFS ) 常使用 B+
树来管理目录, 大幅提高大规模目录的检索速度.</li>
</ul></li>
</ul>
<h4 id="哈希表-hash-table">2. 哈希表 ( Hash Table )</h4>
<ul>
<li><strong>定义</strong> : 根据文件名, 通过 <strong>哈希函数 ( Hash
Function )</strong> 计算出目录项在表中的位置 ( 桶/Bucket ).</li>
<li><strong>实现</strong> :
<ul>
<li><strong>Hash(文件名) <span class="math inline">\(\to\)</span>
索引值</strong>.</li>
<li>哈希表中的每一项指向一个线性列表 ( 解决冲突 ).</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart LR
    %% 样式定义
    classDef input fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
    classDef process fill:#FFEDD5,stroke:#F97316,stroke-width:2px,color:#C2410C,rx:50,ry:50,font-weight:bold;
    classDef index fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;
    classDef bucket fill:#F1F5F9,stroke:#94A3B8,stroke-width:2px,color:#475569,rx:0,ry:0;
    classDef entry fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    Name[&quot;文件名&lt;br&#x2F;&gt;&#39;game.exe&#39;&quot;]:::input --&gt; Hash((Hash)):::process
    Hash --&gt; Index[&quot;索引 ( 5 )&quot;]:::index
    Index --&gt; B5
    
    subgraph Table[&quot;哈希表 ( Bucket )&quot;]
        direction TB
        B0[&quot;0: null&quot;]:::bucket
        B1[&quot;...&quot;]:::bucket
        B5[&quot;5: Ptr&quot;]:::bucket
        B9[&quot;9: null&quot;]:::bucket
    end
    
    B5 --&gt; Entry1[&quot;Entry&lt;br&#x2F;&gt;game.exe&quot;]:::entry
    Entry1 --&gt; Entry2[&quot;Entry&lt;br&#x2F;&gt;game.conf&lt;br&#x2F;&gt;( 冲突链 )&quot;]:::entry
    
    class Table container
  </pre></div></li>
<li><strong>优点</strong> :
<ul>
<li><strong>检索快</strong> : 平均查找时间为 <span
class="math inline">\(O(1)\)</span>.</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>哈希冲突</strong> : 需要机制解决冲突 ( 如链地址法 ).</li>
<li><strong>定长限制</strong> : 哈希表大小通常固定, 扩展需重哈希 (
Rehash ).</li>
<li><strong>管理复杂</strong> : 需设计良好的哈希函数.</li>
</ul></li>
</ul>
<h4 id="对比总结">3. 对比总结</h4>
<table>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">线性列表</th>
<th style="text-align: left;">哈希表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>查找速度</strong></td>
<td style="text-align: left;">慢 <span
class="math inline">\(O(N)\)</span> (未排序)</td>
<td style="text-align: left;">快 <span
class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>实现难度</strong></td>
<td style="text-align: left;">简单</td>
<td style="text-align: left;">较复杂 (需处理冲突)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>空间开销</strong></td>
<td style="text-align: left;">紧凑</td>
<td style="text-align: left;">需预分配哈希桶</td>
</tr>
<tr>
<td style="text-align: left;"><strong>适用场景</strong></td>
<td style="text-align: left;">小规模目录</td>
<td style="text-align: left;">大规模目录</td>
</tr>
</tbody>
</table>
<h3 id="文件共享">4.2.5 文件共享</h3>
<p>文件共享允许不同用户通过不同的文件名访问同一个文件, 既节省存储空间,
又便于协同工作. 主要有 <strong>硬链接 ( Hard Link )</strong> 和
<strong>软链接 ( Soft Link / Symbolic Link )</strong> 两种方式.</p>
<h4 id="基于索引节点的共享-硬链接-hard-link">1. 基于索引节点的共享 (
硬链接 / Hard Link )</h4>
<ul>
<li><strong>定义</strong> : 在目录中创建一个新的目录项,
直接指向目标文件的 <strong>索引节点 ( Inode )</strong>.</li>
<li><strong>原理</strong> :
<ul>
<li>两个目录项 ( 文件名不同 ) 指向 <strong>同一个 Inode</strong>.</li>
<li>Inode 中维护一个 <strong>链接计数 ( nlink / count )</strong>.</li>
</ul></li>
<li><strong>操作</strong> :
<ul>
<li><strong>创建 ( Link )</strong> :
<code>link(old_path, new_path)</code>. 增加目录项, Inode
<code>count++</code>.</li>
<li><strong>删除 ( Unlink )</strong> : <code>unlink(path)</code>.
删除目录项, Inode <code>count--</code>.</li>
<li><strong>真正删除</strong> : 当且仅当 <code>count == 0</code> 时,
才释放 Inode 和 数据块.</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef file fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
    classDef inode fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:50,ry:50,font-weight:bold;
    classDef data fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    subgraph UserA[&quot;用户目录 A&quot;]
        direction TB
        DA[&quot;File 1&quot;]:::file
    end
    
    subgraph UserB[&quot;用户目录 B&quot;]
        direction TB
        DB[&quot;File 2 (硬链接)&quot;]:::file
    end
    
    Inode((Inode&lt;br&#x2F;&gt;count&#x3D;2)):::inode
    Data[数据块]:::data
    
    DA --&gt;|&quot;指向&quot;| Inode
    DB --&gt;|&quot;指向&quot;| Inode
    Inode --&gt; Data
    
    class UserA,UserB container
  </pre></div></li>
<li><strong>优点</strong> :
<ul>
<li><strong>速度快</strong> : 直接访问 Inode, 无额外开销.</li>
<li><strong>同步</strong> : 修改其中一个, 另一个立即可见 (
实际是同一文件 ).</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>不可跨文件系统</strong> : Inode 编号仅在当前分区唯一.</li>
<li><strong>不可链接目录</strong> : 防止形成环路 ( 导致文件遍历死循环
).</li>
</ul></li>
</ul>
<h4 id="基于符号链的共享-软链接-symbolic-link">2. 基于符号链的共享 (
软链接 / Symbolic Link )</h4>
<ul>
<li><strong>定义</strong> : 创建一个特殊的 <strong>LINK 类型</strong>
文件, 其内容是目标文件的 <strong>完整路径名</strong>. ( 类似 Windows
的快捷方式 ).</li>
<li><strong>原理</strong> :
<ul>
<li>系统访问软链接时, 发现是 LINK 类型, 读取其内容 ( 路径 ),
然后根据路径重新查找文件.</li>
</ul></li>
<li><strong>示意图</strong> : <div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
flowchart TB
    %% 样式定义
    classDef file fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
    classDef link fill:#FFEDD5,stroke:#F97316,stroke-width:2px,color:#C2410C,rx:5,ry:5;
    classDef inode fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:50,ry:50,font-weight:bold;
    classDef data fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;
    classDef container fill:#F8FAFC,stroke:#CBD5E1,stroke-width:1px,stroke-dasharray: 5 5,color:#475569,rx:10,ry:10;

    subgraph UserA[&quot;用户目录 A&quot;]
        direction TB
        DA[&quot;File 1 (原文件)&quot;]:::file
    end
    
    subgraph UserB[&quot;用户目录 B&quot;]
        direction TB
        DB[&quot;Link 1 (软链接)&quot;]:::link
    end
    
    InodeA((Inode A)):::inode
    InodeB((Inode B&lt;br&#x2F;&gt;Type&#x3D;LINK)):::inode
    
    DataA[数据块 A]:::data
    DataB[&quot;数据块 B&lt;br&#x2F;&gt;内容: &#x2F;UserA&#x2F;File1&quot;]:::data
    
    DA --&gt; InodeA --&gt; DataA
    DB --&gt; InodeB --&gt; DataB
    DataB -.-&gt;|&quot;解析路径&quot;| DA
    
    class UserA,UserB container
  </pre></div></li>
<li><strong>优点</strong> :
<ul>
<li><strong>跨文件系统</strong> : 可以链接网络文件系统 ( NFS )
或其他分区的文件.</li>
<li><strong>可链接目录</strong> : 不会造成死循环 ( 系统可检测层级
).</li>
</ul></li>
<li><strong>缺点</strong> :
<ul>
<li><strong>访问慢</strong> : 需要多次读盘 ( 读软链接 -&gt; 解析路径
-&gt; 读原文件 ).</li>
<li><strong>空间开销</strong> : 需要额外的 Inode 和数据块存储路径.</li>
<li><strong>悬空指针</strong> : 若原文件被删除/移动, 软链接失效 (
找不到目标 ).</li>
</ul></li>
</ul>
<h4 id="硬链接-vs-软链接-对比">3. 硬链接 vs 软链接 对比</h4>
<table>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">硬链接 ( Hard Link )</th>
<th style="text-align: left;">软链接 ( Soft Link )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>实现机制</strong></td>
<td style="text-align: left;">指向同一 Inode</td>
<td style="text-align: left;">存储目标路径</td>
</tr>
<tr>
<td style="text-align: left;"><strong>跨文件系统</strong></td>
<td style="text-align: left;"><strong>不可</strong></td>
<td style="text-align: left;"><strong>可以</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>链接目录</strong></td>
<td style="text-align: left;"><strong>不可</strong></td>
<td style="text-align: left;"><strong>可以</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>删除原文件</strong></td>
<td style="text-align: left;">仍可访问 ( 只要 count&gt;0 )</td>
<td style="text-align: left;"><strong>失效</strong> ( 悬空 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>访问速度</strong></td>
<td style="text-align: left;">快</td>
<td style="text-align: left;">较慢 ( 需解析路径 )</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Inode 数量</strong></td>
<td style="text-align: left;">不增加 ( 共用 )</td>
<td style="text-align: left;">增加 ( 新文件 )</td>
</tr>
</tbody>
</table>
<h3 id="本节小结">4.2.6 本节小结</h3>
<ul>
<li>树形目录结构是现代 OS 的主流.</li>
<li><strong>硬链接</strong> 就像 “别名”, <strong>软链接</strong> 就像
“快捷方式”.</li>
<li>注意 <strong>删除</strong> 操作对两种链接的不同影响.</li>
</ul>
<h2 id="文件系统">4.3 文件系统</h2>
<h3 id="文件系统结构">4.3.1 文件系统结构</h3>
<p>从上到下层次结构 :</p>
<ol type="1">
<li><strong>用户接口</strong> : 命令/系统调用.</li>
<li><strong>文件目录系统</strong> : 目录管理与检索.</li>
<li><strong>存取控制与保护</strong> : 权限与访问控制.</li>
<li><strong>逻辑文件系统与文件信息缓冲区</strong> :
逻辑记录到逻辑块.</li>
<li><strong>物理文件系统</strong> : 逻辑块到物理块.</li>
<li><strong>I/O 子系统</strong> : 设备管理与调度.</li>
<li><strong>设备驱动程序</strong> : 与硬件交互.</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef layer fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,rx:8,ry:8,color:#0369A1,font-weight:bold;
        classDef title fill:#F1F5F9,stroke:#64748B,stroke-width:2px,rx:10,ry:10,color:#334155,font-weight:bold;

        T[&quot;文件系统七层结构&quot;]:::title
        UI[&quot;1 用户接口&quot;]:::layer
        DIR[&quot;2 文件目录系统&quot;]:::layer
        AC[&quot;3 存取控制与保护&quot;]:::layer
        LFS[&quot;4 逻辑文件系统&lt;br&#x2F;&gt;文件信息缓冲区&quot;]:::layer
        PFS[&quot;5 物理文件系统&quot;]:::layer
        IO[&quot;6 I&#x2F;O 子系统&quot;]:::layer
        DRV[&quot;7 设备驱动程序&quot;]:::layer

        T --- UI
        UI --&gt; DIR --&gt; AC --&gt; LFS --&gt; PFS --&gt; IO --&gt; DRV
  </pre></div>
<h4 id="分层要点与示例">分层要点与示例</h4>
<ul>
<li>用户接口 : 命令/系统调用 ( open / read / write / close
)，提供面向用户/程序的入口.</li>
<li>文件目录系统 : 组织目录与目录项，支持路径检索与重名处理，维护
FCB/Inode 关联.</li>
<li>存取控制与保护 : 口令、加密、访问控制矩阵；UNIX 权限位 ( rwx ) 与
ACL，文件锁.</li>
<li>逻辑文件系统与文件信息缓冲区 :
逻辑记录到逻辑块的转换，缓冲区管理与一致性维护.</li>
<li>物理文件系统 : 块分配与回收，连续/链接/索引分配；空闲空间管理 (
位示图、链表、成组链接 ).</li>
<li>I/O 子系统 : 缓存/预读/写回；调度算法 FCFS / SSTF / SCAN / C‑SCAN /
LOOK；减少寻道与旋转延迟.</li>
<li>设备驱动程序 : 中断/DMA/队列，与硬件协议交互.</li>
</ul>
<h4 id="层次速记表">层次速记表</h4>
<table>
<thead>
<tr>
<th style="text-align: left;">层次</th>
<th style="text-align: left;">职责</th>
<th style="text-align: left;">关键词</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">用户接口</td>
<td style="text-align: left;">命令/系统调用</td>
<td style="text-align: left;">open/read/write/close</td>
</tr>
<tr>
<td style="text-align: left;">文件目录系统</td>
<td style="text-align: left;">目录项检索与管理</td>
<td style="text-align: left;">路径、FCB、Inode</td>
</tr>
<tr>
<td style="text-align: left;">存取控制与保护</td>
<td style="text-align: left;">权限与访问控制</td>
<td style="text-align: left;">rwx、ACL、加密、锁</td>
</tr>
<tr>
<td style="text-align: left;">逻辑文件系统与缓冲区</td>
<td style="text-align: left;">记录→逻辑块、缓冲</td>
<td style="text-align: left;">一致性、缓存</td>
</tr>
<tr>
<td style="text-align: left;">物理文件系统</td>
<td style="text-align: left;">逻辑块→物理块</td>
<td style="text-align: left;">分配、位示图、成组链接</td>
</tr>
<tr>
<td style="text-align: left;">I/O 子系统</td>
<td style="text-align: left;">调度与缓存</td>
<td style="text-align: left;">FCFS/SSTF/SCAN</td>
</tr>
<tr>
<td style="text-align: left;">设备驱动程序</td>
<td style="text-align: left;">硬件交互</td>
<td style="text-align: left;">中断、DMA</td>
</tr>
</tbody>
</table>
<h4 id="关键对象与职责">关键对象与职责</h4>
<ul>
<li>superblock : 记录文件系统整体元信息 ( 总块数、空闲块数、Inode
数、挂载信息 ).</li>
<li>inode : 记录单个文件的元数据 ( 权限、时间戳、大小、块地址 ).</li>
<li>dentry : 目录项缓存，维护名称到 inode 的映射，加速路径解析.</li>
<li>file : 打开文件的会话对象，维护读写偏移、访问模式、指向 inode
的引用.</li>
</ul>
<h4 id="路径解析与权限检查">路径解析与权限检查</h4>
<ul>
<li>路径分解为组件 ( /usr/bin/gcc )，逐级在 dentry
缓存中查找；未命中则访问底层文件系统并回填缓存.</li>
<li>每级目录进行权限检查 ( 读/执行 X 权限决定是否可穿越目录
)；目标文件检查读写权限与锁状态.</li>
<li>遇到挂载点时切换到挂载的 superblock
继续解析；遇到软链接可选择原子解析或逐段解析.</li>
</ul>
<h4 id="缓存机制-读写加速">缓存机制 ( 读写加速 )</h4>
<ul>
<li>Page Cache :
以页为单位缓存文件数据，支撑内存映射与顺序读写预取.</li>
<li>Buffer Cache : 缓冲块设备的元数据与小块 I/O，减少实际磁盘访问.</li>
<li>Dentry / Inode Cache : 减少目录项与 inode 的重复读盘.</li>
</ul>
<h4 id="日志文件系统-journaling">日志文件系统 ( Journaling )</h4>
<ul>
<li>写前日志记录元数据变更，崩溃后回放保证一致性.</li>
<li>模式示例 : Metadata-only、Ordered ( EXT4 默认 )、Data journaling (
最强一致性，代价最大 ).</li>
</ul>
<h3 id="文件系统布局">4.3.2 文件系统布局</h3>
<h4 id="磁盘分区-partition">1. 磁盘分区 ( Partition ) :</h4>
<ul>
<li><strong>引导块 ( Boot Block )</strong> : 存放操作系统引导程序.</li>
<li><strong>超级块 ( Super Block )</strong> : 记录文件系统的整体信息
(空闲块数、Inode 数等).</li>
<li><strong>空闲空间管理信息</strong> : 位示图或空闲链表.</li>
<li><strong>Inode 区域</strong> : 存放所有的 Inode.</li>
<li><strong>数据区域</strong> : 存放文件数据.</li>
<li><strong>主引导记录 ( MBR )</strong> : 位于磁盘 LBA0 ( 第 0 扇区 ),
包含 <strong>引导代码 446B</strong> + <strong>分区表 64B</strong> ( 4 项
× 16B ) + <strong>签名 2B ( 0x55AA )</strong>. 支持 <strong>最多 4
个主分区</strong>，通过 <strong>扩展分区 + EBR 链</strong>
组织多个逻辑分区.</li>
<li><strong>GUID 分区表 ( GPT )</strong> : 现代分区方案. 包含
<strong>保护性 MBR ( LBA0 )</strong>、<strong>GPT 头 ( LBA1
)</strong>、<strong>分区项表 ( LBA2 起 )</strong>. 分区项通常
<strong>128B</strong>，默认可记录 <strong>128
项</strong>；支持分区冗余与更强的一致性.</li>
<li><strong>卷引导记录 ( VBR / Boot Sector )</strong> :
位于分区内的文件系统引导区 ( FAT/NTFS/EXT 等 ). 与 <strong>MBR
属于磁盘级</strong> 不同，<strong>VBR 属于分区/卷级</strong>.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef mbr fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef part fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
        classDef boot fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;

        D[&quot;磁盘&quot;]:::mbr --&gt; M[&quot;MBR ( LBA0 )&quot;]:::mbr
        M --&gt; P1[&quot;主分区 1&quot;]:::part --&gt; V1[&quot;VBR&#x2F;Boot&quot;]:::boot
        M --&gt; P2[&quot;主分区 2&quot;]:::part --&gt; V2[&quot;VBR&#x2F;Boot&quot;]:::boot
        M --&gt; EXT[&quot;扩展分区&quot;]:::part --&gt; E1[&quot;EBR #1&quot;]:::mbr --&gt; L1[&quot;逻辑分区 1&quot;]:::part
        E1 --&gt; E2[&quot;EBR #2&quot;]:::mbr --&gt; L2[&quot;逻辑分区 2&quot;]:::part
  </pre></div>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef meta fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef entries fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
        classDef data fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;

        PM[&quot;Protective MBR ( LBA0 )&quot;]:::meta --&gt; GH[&quot;GPT Header ( LBA1 )&quot;]:::meta --&gt; GE[&quot;Partition Entries ( LBA2... )&quot;]:::entries --&gt; Regions[&quot;数据与分区区域&quot;]:::data
  </pre></div>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef boot fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef meta fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
        classDef data fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;
        classDef journal fill:#FFEDD5,stroke:#F97316,stroke-width:2px,color:#C2410C,rx:5,ry:5;

        Boot[&quot;引导块 ( Boot )&quot;]:::boot --&gt; SB[&quot;超级块 ( Super Block )&quot;]:::meta --&gt; GD[&quot;组描述符&#x2F;控制信息&quot;]:::meta --&gt; BM[&quot;位示图&#x2F;空闲链表&quot;]:::meta --&gt; IT[&quot;Inode 表&quot;]:::meta --&gt; DB[&quot;数据区 ( Data Blocks )&quot;]:::data --&gt; J[&quot;日志区 ( Journal )&quot;]:::journal
  </pre></div>
<h4 id="重要字段举例-以类-unix-为例">2. 重要字段举例 ( 以类 UNIX 为例
)</h4>
<ul>
<li>Super Block :
block_size、blocks_count、free_blocks、inodes_count、mount_time、state.</li>
<li>Inode : mode、uid/gid、size、timestamps ( atime/mtime/ctime
)、blocks、直接/间接索引指针.</li>
<li>目录项 ( Directory Entry ) : name、inode_number、类型 (
普通/目录/链接 ).</li>
</ul>
<h4 id="常见文件系统布局示例">3. 常见文件系统布局示例</h4>
<ul>
<li>FAT32 : 由引导扇区、两份 FAT 表、根目录区 ( FAT12/16 固定，FAT32
位于数据区 )、数据区组成；以簇为最小分配单位.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef boot fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef fat fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
        classDef data fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;

        BootF[&quot;Boot Sector&quot;]:::boot --&gt; FAT1[&quot;FAT #1&quot;]:::fat --&gt; FAT2[&quot;FAT #2 ( 副本 )&quot;]:::fat --&gt; Root[&quot;Root Dir&quot;]:::fat --&gt; Data[&quot;Data Area ( Clusters )&quot;]:::data
  </pre></div>
<ul>
<li>EXT4 : 采用分组 ( Block Group ) 布局，每组包含位示图、Inode
表与数据块；超级块与组描述符在磁盘开头，并有稀疏备份.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef super fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
        classDef group fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5;

        SB[&quot;Super Block + &lt;br&#x2F;&gt;Group Descriptors&quot;]:::super
        SB --&gt; G0[&quot;Group 0&lt;br&#x2F;&gt;Block&#x2F;Inode Bitmap&lt;br&#x2F;&gt;Inode Table&lt;br&#x2F;&gt;Data Blocks&quot;]:::group
        SB --&gt; G1[&quot;Group 1&lt;br&#x2F;&gt;Block&#x2F;Inode Bitmap&lt;br&#x2F;&gt;Inode Table&lt;br&#x2F;&gt;Data Blocks&quot;]:::group
        SB --&gt; G2[&quot;Group 2&lt;br&#x2F;&gt;...&quot;]:::group
  </pre></div>
<ul>
<li>NTFS : 一切皆文件，以 MFT ( 主文件表 ) 为核心；包含 LogFile ( 日志
)、Bitmap ( 空闲位图 )、MFTMirr ( 镜像 ) 等.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef boot fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef meta fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;
        classDef data fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;

        BootN[&quot;Boot Sector&quot;]:::boot --&gt; MFT[&quot;MFT ( 主文件表 )&quot;]:::meta --&gt; Log[&quot;LogFile ( 日志 )&quot;]:::meta --&gt; Bmp[&quot;Bitmap ( 空闲位图 )&quot;]:::meta --&gt; Mirr[&quot;MFTMirr ( 镜像 )&quot;]:::meta --&gt; DataN[&quot;数据区&quot;]:::data
  </pre></div>
<h4 id="内存结构">4. 内存结构 :</h4>
<ul>
<li><strong>系统打开文件表</strong> :
整个系统一张，记录所有打开文件的信息 ( 引用计数 ).</li>
<li><strong>进程打开文件表</strong> : 每个进程一张，记录该进程打开的文件
( 指向系统表的指针 ).</li>
</ul>
<h4 id="计算与实践要点">5. 计算与实践要点</h4>
<ul>
<li>位示图大小 ( 字节 ) = 盘块总数 / 8.</li>
<li>Inode 表大小 = Inode 数 × Inode 结构大小.</li>
<li>单分组 ( Block Group )
设计有利于局部性：在同组内尽量让目录、inode、数据块相邻，降低寻道与读盘次数.</li>
<li>FAT 双表冗余用于容错；NTFS 通过 MFTMirr 与日志保证一致性；EXT
系列支持稀疏超级块与日志模式选择.</li>
<li>MBR 分区表最多 <strong>4 项</strong>；扩展分区通过 <strong>EBR
链</strong>组织多个逻辑分区.</li>
<li>GPT 分区项大小通常 <strong>128B</strong>；分区项表大小 = 分区项数量
× 128B；具备 <strong>保护性 MBR</strong> 与
<strong>冗余备份</strong>.</li>
</ul>
<h3 id="文件存储空间管理">4.3.3 文件存储空间管理</h3>
<p>管理磁盘上的<strong>空闲块</strong>.</p>
<h4 id="空闲表法">1. 空闲表法 :</h4>
<ul>
<li>记录所有空闲区的起始块号和长度.</li>
<li>适用于连续分配.</li>
<li>表项形式 : ( 起始块号, 长度 ).</li>
<li>常见策略 :
<ul>
<li>首次适应 ( First-Fit ) : 从头扫描，遇到第一个长度 ≥
需求即分配，简单高效.</li>
<li>最佳适应 ( Best-Fit ) :
从所有空闲区中选长度最接近的，减少碎片但查找成本高.</li>
<li>最坏适应 ( Worst-Fit ) :
从最大空闲区分配，保留大块，适用性有限.</li>
</ul></li>
<li>回收与合并 :
回收时按块号插入，尝试与前后相邻空闲区合并，降低外部碎片.</li>
<li>适用场景 : 需要较多连续空间时 ( 大文件/顺序 I/O ) 效果好.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef table fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef entry fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;

        F[&quot;空闲表&quot;]:::table --&gt; E1[&quot;start&#x3D;100&lt;br&#x2F;&gt;len&#x3D;50&quot;]:::entry --&gt; E2[&quot;start&#x3D;300&lt;br&#x2F;&gt;len&#x3D;20&quot;]:::entry --&gt; E3[&quot;start&#x3D;500&lt;br&#x2F;&gt;len&#x3D;200&quot;]:::entry
  </pre></div>
<h4 id="空闲链表法">2. 空闲链表法 :</h4>
<ul>
<li><strong>空闲盘块链</strong> : 以盘块为单位链接.</li>
<li><strong>空闲盘区链</strong> : 以盘区为单位链接.</li>
<li>分配 :
盘块链支持按块逐个取用；盘区链支持一次取连续区，常配合首次/最佳适应.</li>
<li>回收 : 插入链表并尝试与相邻合并 ( 盘区链
)；盘块链直接挂接，简单但连续性差.</li>
<li>适用场景 : 文件增长为小步多次 ( 追加写 )，链表易维护.</li>
</ul>
<h4 id="结构定义">结构定义</h4>
<ul>
<li>盘块链节点 : next 指向下一个空闲块的块号.</li>
<li>盘区链节点 : ( start, length, next ) 表示连续空闲区.</li>
</ul>
<h4 id="分配流程">分配流程</h4>
<ul>
<li>盘块链 ( 分配 k 个块 ) : 从链表头按需取 k 次, 更新链表头;
不保证连续性.</li>
<li>盘区链 ( 分配 k 个连续块 ) : 顺序查找第一个 length ≥ k 的节点;
<ul>
<li>若 length = k : 直接摘除该节点;</li>
<li>若 length &gt; k : start += k, length -= k; 保持链有序.</li>
</ul></li>
</ul>
<h4 id="回收与合并">回收与合并</h4>
<ul>
<li>盘块链 : 将释放块以头插/尾插方式接回链表.</li>
<li>盘区链 : 按 start 有序插入; 若与前后相邻区满足 ( prev.start +
prev.length = cur.start ) 或 ( cur.start + cur.length = next.start ),
则合并; 两侧相邻时三段归并, 降低外部碎片.</li>
</ul>
<h4 id="维护策略">维护策略</h4>
<ul>
<li>有序链 : 盘区链按 start 有序利于合并; 按 length 有序利于最佳适应,
但插入维护成本高.</li>
<li>分级空闲链 ( Segregated Lists ) : 依据区段大小分桶维护多条链,
快速定位近似大小区段, 减少线性扫描.</li>
<li>循环/双向链 : 提升插入与合并时前驱/后继访问效率.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef block fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5,font-weight:bold;
        B1[&quot;Free Block 12&quot;]:::block --&gt; B2[&quot;Free Block 45&quot;]:::block --&gt; B3[&quot;Free Block 78&quot;]:::block --&gt; B4[&quot;...&quot;]:::block
  </pre></div>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef ext fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        E1[&quot;start&#x3D;100&lt;br&#x2F;&gt;len&#x3D;50&quot;]:::ext
        E2[&quot;start&#x3D;300&lt;br&#x2F;&gt;len&#x3D;20&quot;]:::ext
        E3[&quot;start&#x3D;500&lt;br&#x2F;&gt;len&#x3D;200&quot;]:::ext

        E1 --&gt; E2 --&gt; E3
  </pre></div>
<h4 id="位示图法-bitmap">3. 位示图法 ( Bitmap ) :</h4>
<ul>
<li>用二进制位表示盘块的使用情况 ( 0为空闲，1为占用 ).</li>
<li><strong>优点</strong> :
容易找到连续空闲块；位示图小，可常驻内存.</li>
<li><strong>盘块号与行列号转换</strong> :
<ul>
<li><span class="math inline">\(b = n(i-1) + j\)</span> ( 字长 <span
class="math inline">\(n\)</span>，行号 <span
class="math inline">\(i\)</span>，列号 <span
class="math inline">\(j\)</span> )</li>
</ul></li>
<li>常用计算 :
<ul>
<li>位示图大小 ( 字节 ) = 盘块总数 / 8.</li>
<li>例: 1TB, 4KB 块 → 块数 <span class="math inline">\(= 2^{28}\)</span>
→ 位示图大小 <span class="math inline">\(= 2^{28}/8 = 2^{25} =
32\)</span>MB.</li>
</ul></li>
<li>操作 : 扫描连续 0
的区段实现连续分配；支持快速定位与批量设置/清零.</li>
<li>适用场景 : 需要高效定位与可常驻内存的系统 ( EXT, NTFS
亦使用位图管理空闲 ).</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef bit fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-family:monospace;
        Row1[&quot;0011110010&quot;]:::bit
        Row2[&quot;0000011111&quot;]:::bit
        Row3[&quot;1111100000&quot;]:::bit
  </pre></div>
<h4 id="成组链接法">4. 成组链接法 :</h4>
<ul>
<li>UNIX 系统采用.</li>
<li>将空闲块分组，每组的第一个块记录下一组的空闲块号.</li>
<li><strong>优点</strong> : 适合大型文件系统.</li>
<li>结构与操作 :
每组保存若干可用块号；当当前组耗尽时，使用组头信息加载下一组，减少磁盘访问次数.</li>
<li>适用场景 : 超大磁盘/高并发环境，降低维护与读盘开销.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef group fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        G0[&quot;Group #0&lt;br&#x2F;&gt;[12, 18, 25] Next&#x3D;G1&quot;]:::group --&gt; G1[&quot;Group #1&lt;br&#x2F;&gt;[40, 41, 42] Next&#x3D;G2&quot;]:::group --&gt; G2[&quot;Group #2&lt;br&#x2F;&gt;[...]&quot;]:::group
  </pre></div>
<h4 id="盘块-vs-盘区-对比表">盘块 vs 盘区 对比表</h4>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">项目</th>
<th style="text-align: left;">盘块 ( Block )</th>
<th style="text-align: left;">盘区 ( Extent/盘区 )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">定义</td>
<td style="text-align: left;">固定大小的最小分配/传输单位</td>
<td style="text-align: left;">由连续多个盘块组成的变长区域</td>
</tr>
<tr>
<td style="text-align: left;">大小</td>
<td style="text-align: left;">固定 ( 如 4KB/8KB/簇 )</td>
<td style="text-align: left;">变长 ( 若干块组成 )</td>
</tr>
<tr>
<td style="text-align: left;">连续性</td>
<td style="text-align: left;">不保证 ( 可离散分配 )</td>
<td style="text-align: left;">保证连续 ( 一次分配一段 )</td>
</tr>
<tr>
<td style="text-align: left;">分配粒度</td>
<td style="text-align: left;">按块逐个分配/回收</td>
<td style="text-align: left;">按区成段分配/回收</td>
</tr>
<tr>
<td style="text-align: left;">管理结构</td>
<td style="text-align: left;">位示图、FAT、盘块链</td>
<td style="text-align: left;">空闲表、盘区链、区段树 ( Extent Tree
)</td>
</tr>
<tr>
<td style="text-align: left;">碎片特性</td>
<td style="text-align: left;">外部碎片少；随机访问跳跃多</td>
<td style="text-align: left;">易产生外部碎片；顺序访问性能好</td>
</tr>
<tr>
<td style="text-align: left;">适用场景</td>
<td style="text-align: left;">小文件、频繁追加、小步增长</td>
<td style="text-align: left;">大文件、顺序 I/O、需连续空间</td>
</tr>
<tr>
<td style="text-align: left;">检索效率</td>
<td style="text-align: left;">随机访问友好 ( 映射简单 )</td>
<td style="text-align: left;">顺序访问友好 ( 寻道/旋转延迟小 )</td>
</tr>
<tr>
<td style="text-align: left;">典型实现</td>
<td style="text-align: left;">FAT/位图块分配</td>
<td style="text-align: left;">EXT4 Extent、NTFS Runlist</td>
</tr>
</tbody>
</table>
<h4 id="方法对比">方法对比</h4>
<table>
<thead>
<tr>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">连续空间找到效率</th>
<th style="text-align: left;">维护开销</th>
<th style="text-align: left;">内存占用</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">空闲表</td>
<td style="text-align: left;">高 ( 依策略 )</td>
<td style="text-align: left;">中 ( 合并/分裂 )</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">需连续空间的大文件</td>
</tr>
<tr>
<td style="text-align: left;">盘块链</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">小步追加，简单维护</td>
</tr>
<tr>
<td style="text-align: left;">盘区链</td>
<td style="text-align: left;">中</td>
<td style="text-align: left;">中</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">连续区与合并需求</td>
</tr>
<tr>
<td style="text-align: left;">位示图</td>
<td style="text-align: left;">高</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">中 ( 但可常驻 )</td>
<td style="text-align: left;">快速定位/批量操作</td>
</tr>
<tr>
<td style="text-align: left;">成组链接</td>
<td style="text-align: left;">中</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">超大规模/并发</td>
</tr>
</tbody>
</table>
<h4 id="典型计算题">典型计算题</h4>
<ul>
<li>位示图大小：已给出公式与示例 ( 1TB/4KB → 32MB ).</li>
<li>连续区分配：空闲表/盘区链用首次适应，记录分配区并更新剩余长度，必要时合并相邻空闲区.</li>
<li>碎片评估：空闲表能更好地维持连续区；盘块链碎片多；位示图可快速合并与检测连续段.</li>
</ul>
<h3 id="虚拟文件系统">4.3.4 虚拟文件系统</h3>
<ul>
<li><strong>VFS ( Virtual File System )</strong> :
<ul>
<li>OS 内核的一层抽象层，位于用户程序和具体文件系统之间.</li>
<li><strong>作用</strong> : 屏蔽底层具体文件系统 (FAT, NTFS, EXT4)
的差异，提供统一的接口 ( open, read, write ).</li>
<li><strong>实现</strong> : 定义了一组对象 ( superblock, inode, dentry,
file ) 和操作函数指针.</li>
</ul></li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart TB
        classDef vfs fill:#F3E8FF,stroke:#9333EA,stroke-width:2px,color:#6B21A8,rx:5,ry:5,font-weight:bold;
        classDef obj fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5,font-weight:bold;
        classDef cache fill:#DCFCE7,stroke:#16A34A,stroke-width:2px,color:#15803D,rx:5,ry:5;

        SB[&quot;superblock&quot;]:::obj --&gt; IN[&quot;inode&quot;]:::obj --&gt; DE[&quot;dentry&quot;]:::obj --&gt; FI[&quot;file&quot;]:::obj
        C1[&quot;Dentry Cache&quot;]:::cache --- DE
        C2[&quot;Inode Cache&quot;]:::cache --- IN
        C3[&quot;Page&#x2F;Buffer Cache&quot;]:::cache --- FI
  </pre></div>
<h4 id="路径解析流程-path-walk">路径解析流程 ( Path Walk )</h4>
<ul>
<li>拆分路径 -&gt; 命中 dentry
缓存则直接返回；未命中则查询底层文件系统并创建新的 dentry.</li>
<li>目录与文件的权限在每一步校验；考虑挂载点与跨文件系统边界的切换.</li>
<li>打开文件后生成 file 对象，维护读写偏移与访问模式，并与 inode
关联.</li>
</ul>
<h4 id="对象与操作表">对象与操作表</h4>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">对象</th>
<th style="text-align: left;">关键字段</th>
<th style="text-align: left;">典型操作集</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">superblock</td>
<td style="text-align: left;">块大小、总块数、挂载信息</td>
<td style="text-align: left;">sync_fs, statfs, put_super</td>
</tr>
<tr>
<td style="text-align: left;">inode</td>
<td style="text-align: left;">模式/权限、大小、时间戳、块地址</td>
<td style="text-align: left;">create, lookup, link, unlink, mkdir,
rmdir, rename, setattr, permission</td>
</tr>
<tr>
<td style="text-align: left;">dentry</td>
<td style="text-align: left;">名称、父子层级、缓存标记</td>
<td style="text-align: left;">d_revalidate, d_hash, d_compare</td>
</tr>
<tr>
<td style="text-align: left;">file</td>
<td style="text-align: left;">读写偏移、访问模式、f_op 指针</td>
<td style="text-align: left;">read_iter, write_iter, llseek, mmap,
fsync, ioctl</td>
</tr>
</tbody>
</table>
<h4 id="名称缓存与负-dentry">名称缓存与负 dentry</h4>
<ul>
<li>负 dentry :
名称存在于父目录但目标不存在的缓存项，避免重复磁盘查找.</li>
<li>重新验证 ( revalidate ) :
某些文件系统或目录项在缓存命中时仍需二次校验 ( 网络/远程/可变大小目录
).</li>
<li>大小写敏感性由底层 FS 决定 ( 例: EXT4 敏感，VFAT/NTFS 可不敏感
).</li>
</ul>
<h4 id="打开读写流程-简版">打开/读写流程 ( 简版 )</h4>
<ul>
<li>open : 路径解析 -&gt; 权限检查 -&gt; 创建/查找 dentry 与 inode -&gt;
生成 file 对象并绑定 file_operations.</li>
<li>read : 命中 Page Cache
则直接拷贝；未命中从块设备读入页并回填缓存；更新读写偏移.</li>
<li>write :
写入页缓存并标记脏页；依据策略触发写回与日志记录；更新大小与时间戳.</li>
<li>直写/直接 I/O : 绕过缓存直接与块层交互，用于数据库/大文件顺序
I/O.</li>
</ul>
<h4 id="挂载与命名空间">挂载与命名空间</h4>
<ul>
<li>挂载点切换 superblock，路径解析可跨文件系统继续进行.</li>
<li>绑定挂载用于同目录多视图；命名空间使不同进程拥有独立的挂载树 (
容器场景 ).</li>
</ul>
<h4 id="易错点">易错点</h4>
<ul>
<li>VFS
是抽象层，不等同于具体文件系统；对象/操作集通过函数指针桥接具体实现.</li>
<li>dentry 是名称缓存项，不等同于磁盘上的目录文件；负 dentry
可加速“未找到”场景.</li>
<li>打开后系统用 fd
引用，不再用文件名；硬链接与软链接的解析与缓存行为不同.</li>
</ul>
<h3 id="文件系统挂载">4.3.5 文件系统挂载</h3>
<ul>
<li><strong>Mount</strong> : 将一个文件系统安装到目录树的某个节点 (
挂载点 ) 上.</li>
<li>挂载后，该节点成为新文件系统的根目录.</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  %%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;lineColor&#39;: &#39;#64748b&#39;, &#39;fontFamily&#39;: &#39;arial&#39;, &#39;fontSize&#39;: &#39;16px&#39; }}}%%
    flowchart LR
        classDef dir fill:#E0F2FE,stroke:#0284C7,stroke-width:2px,color:#0369A1,rx:5,ry:5,font-weight:bold;
        classDef fs fill:#FEF9C3,stroke:#CA8A04,stroke-width:2px,color:#854D0E,rx:5,ry:5;

        Root[&quot;根目录 &#x2F;&quot;]:::dir --&gt; Mnt[&quot;&#x2F;mnt&#x2F;data&quot;]:::dir
        Mnt --&gt; FS1[&quot;EXT4 分区&quot;]:::fs
        Root --&gt; Home[&quot;&#x2F;home&quot;]:::dir --&gt; FS2[&quot;XFS 分区&quot;]:::fs
  </pre></div>
<h4 id="常用操作说明">常用操作说明</h4>
<ul>
<li>mount : 指定设备、类型、挂载点与选项 ( 只读、noatime、data=ordered
等 ).</li>
<li>umount : 卸载挂载点，需保证不存在打开引用与活动工作目录.</li>
<li>绑定挂载 ( bind ) : 将目录在多个位置呈现，便于隔离与容器场景.</li>
</ul>
<h3 id="文件系统类型速览">4.3.7 文件系统类型速览</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">类型</th>
<th style="text-align: left;">日志支持</th>
<th style="text-align: left;">目录索引</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">FAT32</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">否</td>
<td style="text-align: left;">兼容性好，移动介质</td>
</tr>
<tr>
<td style="text-align: left;">NTFS</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">Windows 桌面/服务器</td>
</tr>
<tr>
<td style="text-align: left;">EXT4</td>
<td style="text-align: left;">是 ( Ordered/Journal )</td>
<td style="text-align: left;">是 ( HTree )</td>
<td style="text-align: left;">Linux 桌面/服务器</td>
</tr>
<tr>
<td style="text-align: left;">XFS</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">是</td>
<td style="text-align: left;">大文件/并发优先</td>
</tr>
</tbody>
</table>
<h2 id="本章疑难点">4.4 本章疑难点</h2>
<h4 id="打开文件-open-到底做了什么">1. 打开文件 ( Open )
到底做了什么？</h4>
<ul>
<li>主要工作是将文件的控制信息 ( FCB/Inode )
从磁盘读入内存，建立系统打开文件表项和进程打开文件表项，并返回索引号 (
fd ).之后的操作直接利用内存中的信息，避免重复查目录.</li>
</ul>
<h4 id="硬链接和软链接的区别">2. 硬链接和软链接的区别</h4>
<ul>
<li>硬链接 : 指向 Inode，不能跨文件系统，不能链接目录.</li>
<li>软链接 : 指向路径，可以跨文件系统，可以链接目录，效率稍低.</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">sparkle520</div><div class="post-copyright__author_desc">我一直都在寻找着什么</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/')">408-操作系统-4-文件管理</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=408-操作系统-4-文件管理&amp;url=http://example.com/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/&amp;pic=https://pic1.imgdb.cn/item/6951243ca0c391c56de5e622.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SPARKLE</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>操作系统<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/408/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>408<span class="tagsPageCount">10</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/6996f0a1d2628f800ee0f993.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492cd6c154427986d9b19e.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">408-操作系统-3-内存管理</div></div></a></div><div class="next-post pull-right"><a href="/2025/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492e4cc154427986d9be8f.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">408-操作系统-5-输入/输出管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/" title="408-操作系统-1-计算机系统概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492a76c154427986d991c5.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-22</div><div class="title">408-操作系统-1-计算机系统概述</div></div></a></div><div><a href="/2025/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/" title="408-操作系统-3-内存管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492cd6c154427986d9b19e.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-25</div><div class="title">408-操作系统-3-内存管理</div></div></a></div><div><a href="/2025/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/" title="408-操作系统-2-进程与线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492ebfc154427986d9c262.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-23</div><div class="title">408-操作系统-2-进程与线程</div></div></a></div><div><a href="/2025/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/" title="408-操作系统-5-输入&#x2F;输出管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69492e4cc154427986d9be8f.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-26</div><div class="title">408-操作系统-5-输入&#x2F;输出管理</div></div></a></div><div><a href="/2025/12/31/%E8%AE%A1%E7%BB%841/" title="408-计算机组成原理-1-计算机系统概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6954ea8a8801094e3ab4fd8b.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-31</div><div class="title">408-计算机组成原理-1-计算机系统概述</div></div></a></div><div><a href="/2026/01/26/%E8%AE%A1%E7%BB%845/" title="408-计算机组成原理-5-中央处理器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69872af342b1cbeca1f88f3d.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2026-01-26</div><div class="title">408-计算机组成原理-5-中央处理器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/65b6b29c871b83018af70c9a.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/671cfe2fd29ded1a8c5ffb0b.png" alt="status"/></div></div><div class="author-info__description">不管你在<strong style="color:white">这个世界</strong>的哪个地方，我一定<strong style="color:white">会</strong>，再次去<strong style="color:white">见</strong>你的!</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">sparkle520</h1><div class="author-info__desc">我一直都在寻找着什么</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/sparkle520" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/34882250" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">Hello World! 欢迎来到我的博客~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://pic.imgdb.cn/item/66c487f1d9c307b7e9ba5c7a.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://pic.imgdb.cn/item/66c487ebd9c307b7e9ba5725.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">第4章 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 文件系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">4.1.1 文件的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1. 文件的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2. 文件的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3. 文件的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">4. 文件的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">4.1.2 文件控制块和索引节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97-fcb"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1. 文件控制块 ( FCB )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9-inode"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2. 索引节点 ( Inode )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9-vs-%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3. 磁盘索引节点 vs
内存索引节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">4. 示例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">4.1.3 文件的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6-create"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. 创建文件 ( Create )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6-delete"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 删除文件 ( Delete )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6-open"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3. 打开文件 ( Open )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6-close"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">4. 关闭文件 ( Close )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6-readwrite"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">5. 读&#x2F;写文件 ( Read&#x2F;Write )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E4%BD%8D-seek"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">6. 文件重定位 ( Seek )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.1.4 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6-%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1. 无结构文件 ( 流式文件 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6-%E8%AE%B0%E5%BD%95%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2. 有结构文件 ( 记录式文件 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%A4%B4%E7%BB%93%E6%9E%84-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">组头结构 ( 示例 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B-%E5%8D%95%E5%9D%97%E5%A4%9A%E5%9D%97"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">分配流程 ( 单块&#x2F;多块 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">回收流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E-io-%E4%BC%B0%E7%AE%97"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">复杂度与 I&#x2F;O 估算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%A4%A7%E5%B0%8F%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">组大小选择建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E4%BD%8D%E7%A4%BA%E5%9B%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94%E8%A6%81%E7%82%B9"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">与位示图&#x2F;链表的对比要点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6-sequential-file"><span class="toc-number">1.1.4.8.1.</span> <span class="toc-text">1. 顺序文件 ( Sequential File )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6-indexed-file"><span class="toc-number">1.1.4.8.2.</span> <span class="toc-text">2. 索引文件 ( Indexed File )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6-indexed-sequential-file"><span class="toc-number">1.1.4.8.3.</span> <span class="toc-text">3. 索引顺序文件 ( Indexed
Sequential File )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6-direct-file-%E6%95%A3%E5%88%97%E6%96%87%E4%BB%B6-hash-file"><span class="toc-number">1.1.4.8.4.</span> <span class="toc-text">4. 直接文件 ( Direct
File ) &#x2F; 散列文件 ( Hash File )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">4.1.5 文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D-continuous-allocation"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 连续分配 ( Continuous
Allocation )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D-linked-allocation"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2. 链接分配 ( Linked Allocation
)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D-indexed-allocation"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3. 索引分配 ( Indexed Allocation
)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.6.</span> <span class="toc-text">4.1.6 文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4-password-protection"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">1. 口令保护 ( Password Protection
)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4-cryptography-protection"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">2. 加密保护 ( Cryptography
Protection )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-access-control"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">3. 访问控制 ( Access Control )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">4.2.1 目录的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1. 目录的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E7%9A%84%E8%A6%81%E6%B1%82-%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2. 目录管理的要求 ( 目标 )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">4.2.2 目录的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">4.2.3 目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-single-level-directory"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 单级目录结构 (
Single-Level Directory )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-two-level-directory"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. 两级目录结构 ( Two-Level
Directory )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95-tree-structured-directory"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3. 多级目录结构
( 树形目录 &#x2F; Tree-Structured Directory )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-acyclic-graph-directory"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4. 无环图目录结构 (
Acyclic-Graph Directory )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-general-graph-directory"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">5. 通用图目录结构 (
General Graph Directory )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A3%80%E7%B4%A2%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">6. 目录结构检索效率对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.2.4 目录实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%88%97%E8%A1%A8-linear-list"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1. 线性列表 ( Linear List )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-hash-table"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2. 哈希表 ( Hash Table )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3. 对比总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.5.</span> <span class="toc-text">4.2.5 文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB-%E7%A1%AC%E9%93%BE%E6%8E%A5-hard-link"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. 基于索引节点的共享 (
硬链接 &#x2F; Hard Link )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E7%9A%84%E5%85%B1%E4%BA%AB-%E8%BD%AF%E9%93%BE%E6%8E%A5-symbolic-link"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. 基于符号链的共享 (
软链接 &#x2F; Symbolic Link )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5-vs-%E8%BD%AF%E9%93%BE%E6%8E%A5-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3. 硬链接 vs 软链接 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E8%8A%82%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.6.</span> <span class="toc-text">4.2.6 本节小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.3.1 文件系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E8%A6%81%E7%82%B9%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">分层要点与示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%80%9F%E8%AE%B0%E8%A1%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">层次速记表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">关键对象与职责</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">路径解析与权限检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E8%AF%BB%E5%86%99%E5%8A%A0%E9%80%9F"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">缓存机制 ( 读写加速 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-journaling"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">日志文件系统 ( Journaling )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.3.2 文件系统布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA-partition"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1. 磁盘分区 ( Partition ) :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5%E4%B8%BE%E4%BE%8B-%E4%BB%A5%E7%B1%BB-unix-%E4%B8%BA%E4%BE%8B"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2. 重要字段举例 ( 以类 UNIX 为例
)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3. 常见文件系统布局示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">4. 内存结构 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%A6%81%E7%82%B9"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">5. 计算与实践要点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3.3 文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1. 空闲表法 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2. 空闲链表法 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">分配流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">回收与合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">维护策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95-bitmap"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">3. 位示图法 ( Bitmap ) :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">4. 成组链接法 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%98%E5%9D%97-vs-%E7%9B%98%E5%8C%BA-%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">1.3.3.9.</span> <span class="toc-text">盘块 vs 盘区 对比表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.3.10.</span> <span class="toc-text">方法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E8%AE%A1%E7%AE%97%E9%A2%98"><span class="toc-number">1.3.3.11.</span> <span class="toc-text">典型计算题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.3.4 虚拟文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B-path-walk"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">路径解析流程 ( Path Walk )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%93%8D%E4%BD%9C%E8%A1%A8"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">对象与操作表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E8%B4%9F-dentry"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">名称缓存与负 dentry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B-%E7%AE%80%E7%89%88"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">打开&#x2F;读写流程 ( 简版 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">挂载与命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">易错点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD"><span class="toc-number">1.3.5.</span> <span class="toc-text">4.3.5 文件系统挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">常用操作说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E9%80%9F%E8%A7%88"><span class="toc-number">1.3.6.</span> <span class="toc-text">4.3.7 文件系统类型速览</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E7%96%91%E9%9A%BE%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 本章疑难点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6-open-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1. 打开文件 ( Open )
到底做了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2. 硬链接和软链接的区别</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/19/%E9%AB%98%E6%95%B0-%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E6%B1%82%E8%A7%A3/" title="高等数学-难点-高阶导数求解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6996f0a1d2628f800ee0f993.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高等数学-难点-高阶导数求解"/></a><div class="content"><a class="title" href="/2026/02/19/%E9%AB%98%E6%95%B0-%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E6%B1%82%E8%A7%A3/" title="高等数学-难点-高阶导数求解">高等数学-难点-高阶导数求解</a><time datetime="2026-02-19T12:00:27.000Z" title="发表于 2026-02-19 20:00:27">2026-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/26/%E8%AE%A1%E7%BB%845/" title="408-计算机组成原理-5-中央处理器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69872af342b1cbeca1f88f3d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="408-计算机组成原理-5-中央处理器"/></a><div class="content"><a class="title" href="/2026/01/26/%E8%AE%A1%E7%BB%845/" title="408-计算机组成原理-5-中央处理器">408-计算机组成原理-5-中央处理器</a><time datetime="2026-01-26T15:00:27.000Z" title="发表于 2026-01-26 23:00:27">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/26/%E8%AE%A1%E7%BB%844/" title="408-计算机组成原理-4-指令系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69872ac742b1cbeca1f88f3a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="408-计算机组成原理-4-指令系统"/></a><div class="content"><a class="title" href="/2026/01/26/%E8%AE%A1%E7%BB%844/" title="408-计算机组成原理-4-指令系统">408-计算机组成原理-4-指令系统</a><time datetime="2026-01-26T15:00:27.000Z" title="发表于 2026-01-26 23:00:27">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/14/%E8%AE%A1%E7%BB%843/" title="408-计算机组成原理-3-存储系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/69677a4999f37a647f58e412.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="408-计算机组成原理-3-存储系统"/></a><div class="content"><a class="title" href="/2026/01/14/%E8%AE%A1%E7%BB%843/" title="408-计算机组成原理-3-存储系统">408-计算机组成原理-3-存储系统</a><time datetime="2026-01-14T15:00:27.000Z" title="发表于 2026-01-14 23:00:27">2026-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/12/%E8%8B%B1%E8%AF%AD%E4%BB%8E%E5%8F%A5%E7%AE%80%E5%8C%96/" title="英语从句简化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6964b36351d5e4e5d5707e53.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="英语从句简化"/></a><div class="content"><a class="title" href="/2026/01/12/%E8%8B%B1%E8%AF%AD%E4%BB%8E%E5%8F%A5%E7%AE%80%E5%8C%96/" title="英语从句简化">英语从句简化</a><time datetime="2026-01-12T15:00:27.000Z" title="发表于 2026-01-12 23:00:27">2026-01-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#footer-type-tips", {
      strings: ["只要记住你的名字&#44; 不管你在世界的哪个地方&#44; 我一定&#44; 会去见你 !"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("footer-type-tips").innerHTML = '只要记住你的名字&#44; 不管你在世界的哪个地方&#44; 我一定&#44; 会去见你 !'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/sparkle520" title="sparkle">sparkle</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/sparkle520?tab=repositories" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size: 0.88rem;">408<sup>10</sup></a><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Deep-Learning/" style="font-size: 0.88rem;">Deep Learning<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/JSR303/" style="font-size: 0.88rem;">JSR303<sup>1</sup></a><a href="/tags/Matplotlib/" style="font-size: 0.88rem;">Matplotlib<sup>3</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c#<sup>2</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>4</sup></a><a href="/tags/npc%E5%88%86%E6%9E%90%E6%B3%95/" style="font-size: 0.88rem;">npc分析法<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>5</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>1</sup></a><a href="/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/" style="font-size: 0.88rem;">二次型<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%82/" style="font-size: 0.88rem;">你的名字。<sup>3</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">你的名字同名小说<sup>1</sup></a><a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E5%A4%96%E4%BC%A0%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">你的名字外传小说<sup>1</sup></a><a href="/tags/%E5%80%92%E8%A3%85%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">倒装结构<sup>1</sup></a><a href="/tags/%E5%86%99%E4%BD%9C/" style="font-size: 0.88rem;">写作<sup>4</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">包管理<sup>1</sup></a><a href="/tags/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/" style="font-size: 0.88rem;">卷积公式<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/" style="font-size: 0.88rem;">天气之子<sup>1</sup></a><a href="/tags/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%90%8C%E5%90%8D%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">天气之子同名小说<sup>1</sup></a><a href="/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/" style="font-size: 0.88rem;">定积分<sup>1</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">小说<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" style="font-size: 0.88rem;">数据校验<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 0.88rem;">概率论<sup>1</sup></a><a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" style="font-size: 0.88rem;">概率论与数理统计<sup>7</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 0.88rem;">汇编<sup>9</sup></a><a href="/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" style="font-size: 0.88rem;">泰勒展开<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%80%BC/" style="font-size: 0.88rem;">特征值<sup>1</sup></a><a href="/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" style="font-size: 0.88rem;">特征向量<sup>1</sup></a><a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 0.88rem;">线性代数<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/" style="font-size: 0.88rem;">英语听力<sup>1</sup></a><a href="/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 0.88rem;">英语语法<sup>16</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">计算机组成原理<sup>6</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/" style="font-size: 0.88rem;">词根词缀<sup>1</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" style="font-size: 0.88rem;">高等代数<sup>2</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">高等数学<sup>9</sup></a><a href="/tags/%E9%AB%98%E9%A2%91%E8%AF%8D%E7%BB%84/" style="font-size: 0.88rem;">高频词组<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.9.1/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://sparkle521.xyz',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://sparkle521.xyz',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://sparkle521.xyz',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>